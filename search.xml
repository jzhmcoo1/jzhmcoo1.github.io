<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++OJ环境搭建</title>
      <link href="2021/06/21/Cpp-OJ-Environment/"/>
      <url>2021/06/21/Cpp-OJ-Environment/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>由于之后可能要去复试机考，平时开发时用的都是前端和Node的一套，现在有必要把<code>cpp</code>捡起来了，本文将使用VSCode在MacOS上的<code>cpp17</code>开发环境，以及一些常用的<code>stl</code>和一些常用操作。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>首先要装Xcode，这里就略了</p><h2 id="VSCode安装插件"><a href="#VSCode安装插件" class="headerlink" title="VSCode安装插件"></a>VSCode安装插件</h2><ul><li><a href="https://github.com/microsoft/vscode-cpptools">microsoft/vscode-cpptools: Official repository for the Microsoft C/C++ extension for VS Code. (github.com)</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner">Code Runner - Visual Studio Marketplace</a></li></ul><h2 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h2><p>首先把三个常见的<code>cpp</code>配置文件列一下</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c_cpp_properties.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Mac&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;includePath&quot;</span>: [<span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;defines&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;macFrameworkPath&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;compilerPath&quot;</span>: <span class="string">&quot;/usr/bin/clang&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;cStandard&quot;</span>: <span class="string">&quot;c17&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;macos-clang-x64&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// launch.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 使用 IntelliSense 了解相关属性。</span></span><br><span class="line">  <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">  <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;clang++ - 生成和调试活动文件&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;lldb&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;C/C++: clang++ 生成活动文件&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppbuild&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;C/C++: clang++ 生成活动文件&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;/usr/bin/clang++&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;-std=c++17&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-stdlib=libc++&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-g&quot;</span>, <span class="comment">//调试时需要开启</span></span><br><span class="line">        <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">        <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;problemMatcher&quot;</span>: [<span class="string">&quot;$gcc&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;group&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;detail&quot;</span>: <span class="string">&quot;编译器: /usr/bin/clang++&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="设置选择cpp17"><a href="#设置选择cpp17" class="headerlink" title="设置选择cpp17"></a>设置选择cpp17</h2><p>如果不更改配置的话，使用cpp11+新语法会报错</p><h3 id="设置CodeRunner"><a href="#设置CodeRunner" class="headerlink" title="设置CodeRunner"></a>设置CodeRunner</h3><p>进入CodeRunner的设置文件，将<code>code-runner.executorMap</code>属性中的<code>cpp</code>属性的值改为</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;code-runner.executorMap&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;cpp&quot;</span>: <span class="string">&quot;cd $dir &amp;&amp; g++ -std=c++17 $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是多加了一个<code>std=c++17</code></p><h3 id="开启CodeRunner命令行"><a href="#开启CodeRunner命令行" class="headerlink" title="开启CodeRunner命令行"></a>开启CodeRunner命令行</h3><p>一般使用CodeRunner直接跑<code>cpp</code>是无法进行输入的，我们开启选项中的如下配置：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;code-runner.runInTerminal&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能过使用内置命令行进行交互输入了</p><h2 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h2><p>我们新建一个<code>cpp</code>程序</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> a, b;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用CodeRunner或者直接按F5运行，这里使用CodeRunner直接运行，可以直接进行输入并且有输出，测试完毕</p><h1 id="整理使用Cpp做OJ的常用基础和STL"><a href="#整理使用Cpp做OJ的常用基础和STL" class="headerlink" title="整理使用Cpp做OJ的常用基础和STL"></a>整理使用Cpp做OJ的常用基础和STL</h1><blockquote><p><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html">C++ 教程 | 菜鸟教程 (runoob.com)</a></p></blockquote><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table><thead><tr><th align="center">类型</th><th align="center">所占空间</th><th align="left">表示范围</th></tr></thead><tbody><tr><td align="center"><code>char</code></td><td align="center">1B</td><td align="left">-128 到 127 或者 0 到 255</td></tr><tr><td align="center"><code>int</code></td><td align="center">4B</td><td align="left">-2147483648 到 2147483647(即$2^{31}-1$)</td></tr><tr><td align="center"><code>unsigned int</code></td><td align="center">4B</td><td align="left">0 到 4294967295</td></tr><tr><td align="center"><code>long int</code></td><td align="center">8B</td><td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td align="center"><code>double</code></td><td align="center">8B</td><td align="left">双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td></tr><tr><td align="center"><code>string</code></td><td align="center">24B</td><td align="left"></td></tr></tbody></table><p>使用以下程序可以打印每个类型的最大值和所占的字节大小</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 输出8</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; numeric_limits&lt;<span class="keyword">long</span>&gt;::max() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 9223372036854775807</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; numeric_limits&lt;<span class="keyword">long</span>&gt;::min() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// -9223372036854775808</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td><td><code>0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1;</code></td></tr><tr><td>|</td><td>按位或</td><td>`0</td></tr><tr><td>^</td><td>按位异或</td><td><code>0^0=0;    0^1=1;    1^0=1;   1^1=0;</code></td></tr><tr><td>~</td><td>按位取反</td><td><code>~1=-2;    ~0=1;</code></td></tr><tr><td>&gt;&gt;</td><td>右移</td><td><code>100&gt;&gt;2=25</code></td></tr><tr><td>&lt;&lt;</td><td>左移</td><td><code>100&lt;&lt;2=400</code></td></tr></tbody></table><h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><p>首先引入<code>&lt;cmath&gt;</code>头文件</p><p>一些内置数学函数</p><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td><strong>double cos(double);</strong></td><td>求弧度角的cos值</td></tr><tr><td><strong>double log(double);</strong></td><td>求$ln(x)$</td></tr><tr><td><strong>double pow(double, double);</strong></td><td>求$x^y$</td></tr><tr><td><strong>double sqrt(double);</strong></td><td>求$\sqrt{x}$</td></tr><tr><td><strong>int abs(int);</strong></td><td>求$</td></tr><tr><td><strong>double floor(double);</strong></td><td>求$\lfloor x \rfloor$</td></tr></tbody></table><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>数组声明：<code>typename name[arraysize]</code>，如：<code>double balance[10];</code></p></li><li><p>初始化：<code>double balance[5] = &#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;;</code></p></li><li><p>向函数的形参传递数组：</p><ol><li>形参用指针接</li><li>形参用已定义大小的数组接</li><li>形参用未定义大小的数组接</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> *param)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction2</span><span class="params">(<span class="keyword">int</span> param[<span class="number">10</span>])</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction3</span><span class="params">(<span class="keyword">int</span> param[])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>从函数返回数组<ul><li>用指针接，但我看菜鸟上给的例子是用<code>static</code>修饰了一个数组，挺麻烦的，应该不常用</li></ul></li></ul><blockquote><p>另外，C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 <strong>static</strong> 变量。</p></blockquote><h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><blockquote><p><a href="http://c.biancheng.net/view/400.html">C++ string类（C++字符串）完全攻略 (biancheng.net)</a></p></blockquote><p>首先引入头文件<code>&lt;string&gt;</code></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;       <span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="number">4</span>, <span class="string">&#x27;k&#x27;</span>)</span></span>;   <span class="comment">//跟一个char字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// kkkk</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="string">&quot;1234567&quot;</span>, <span class="number">1</span>, <span class="number">3</span>)</span></span>;  <span class="comment">//从index为1开始,长度为3的子串构造新字符串</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 234</span></span><br></pre></td></tr></table></figure><h3 id="声明和赋值"><a href="#声明和赋值" class="headerlink" title="声明和赋值"></a>声明和赋值</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;      <span class="comment">//声明</span></span><br><span class="line">s1 = <span class="string">&quot;123456&quot;</span>;  <span class="comment">//赋值</span></span><br><span class="line"><span class="built_in">string</span> s5 = s1;  <span class="comment">//改变一个字符串不影响另一个</span></span><br><span class="line">s1 = <span class="string">&quot;321&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s5 = &quot;</span> &lt;&lt; s5 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 123456</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 = &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 321</span></span><br></pre></td></tr></table></figure><h3 id="求长度"><a href="#求长度" class="headerlink" title="求长度"></a>求长度</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; s5.length() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s5.size() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><p>可以使用<code>+=</code>或者成员函数<code>append</code>，会改变原字符串</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1(&quot;123&quot;), s2(&quot;abc&quot;);</span><br><span class="line">s1.append(s2);  <span class="comment">// s1 = &quot;123abc&quot;</span></span><br><span class="line">s1.append(s2, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// s1 = &quot;123abcbc&quot;</span></span><br><span class="line">s1.append(<span class="number">3</span>, <span class="string">&#x27;K&#x27;</span>);  <span class="comment">// s1 = &quot;123abcbcKKK&quot;</span></span><br><span class="line">s1.append(<span class="string">&quot;ABCDE&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// s1 = &quot;123abcbcKKKCDE&quot;，添加 &quot;ABCDE&quot; 的子串(2, 3)</span></span><br></pre></td></tr></table></figure><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>可以使用$≥,≤,==,!=,&gt;,&lt;$也可以用成员函数<code>compare()</code></p><p>compare 成员函数有以下返回值：</p><ul><li>小于 0 表示当前的字符串小；</li><li>等于 0 表示两个字符串相等；</li><li>大于 0 表示另一个字符串小。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1(&quot;hello&quot;), s2(&quot;hello, world&quot;);</span><br><span class="line"><span class="keyword">int</span> n = s1.compare(s2);</span><br><span class="line">n = s1.compare(<span class="number">1</span>, <span class="number">2</span>, s2, <span class="number">0</span>, <span class="number">3</span>);  <span class="comment">//比较s1的子串 (1,2) 和s2的子串 (0,3)</span></span><br><span class="line">n = s1.compare(<span class="number">0</span>, <span class="number">2</span>, s2);  <span class="comment">// 比较s1的子串 (0,2) 和 s2</span></span><br><span class="line">n = s1.compare(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">n = s1.compare(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Hello&quot;</span>);  <span class="comment">//比较 s1 的子串(1,2)和&quot;Hello”</span></span><br><span class="line">n = s1.compare(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//比较 s1 的子串(1,2)和 &quot;Hello&quot; 的子串(1,2)</span></span><br></pre></td></tr></table></figure><h3 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s6</span><span class="params">(<span class="string">&quot;I&#x27;mxxxxs6&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s7 = s6.substr(<span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// 从index为2的地方，截3的长度</span></span><br><span class="line"><span class="built_in">string</span> s8 = s6.substr(<span class="number">2</span>, <span class="number">100</span>);  <span class="comment">// 长度超了也只会截到最后</span></span><br><span class="line"><span class="built_in">string</span> s9 = s6.substr(<span class="number">2</span>);       <span class="comment">//长度没写就截到最后</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s7 &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">// mxx</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s8 &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">// mxxxxs6</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s9 &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">// mxxxxs6</span></span><br></pre></td></tr></table></figure><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s10</span><span class="params">(<span class="string">&quot;10&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s11</span><span class="params">(<span class="string">&quot;11&quot;</span>)</span></span>;</span><br><span class="line">s10.swap(s11);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s10 = &quot;</span> &lt;&lt; s10 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s11 = &quot;</span> &lt;&lt; s11 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h3 id="查找子串"><a href="#查找子串" class="headerlink" title="查找子串"></a>查找子串</h3><blockquote><p><code>string</code> 类有一些查找子串和字符的成员函数，它们的返回值都是子串或字符在 <code>string</code> 对象字符串中的位置（即下标）。如果查不到，则返回 <code>string::npos</code>。<code>string::npos</code> 是在 <code>string</code> 类中定义的一个静态常量。</p></blockquote><ul><li><code>find</code>：从前往后查找子串或字符出现的位置。</li><li><code>rfind</code>：从后往前查找子串或字符出现的位置。</li><li><code>find_first_of</code>：从前往后查找何处出现另一个字符串中包含的字符。例如：</li><li><code>s1.find_first_of(&quot;abc&quot;)</code>; //查找s1中第一次出现”abc”中任一字符的位置</li><li><code>find_last_of</code>：从后往前查找何处出现另一个字符串中包含的字符。</li><li><code>find_first_not_of</code>：从前往后查找何处出现另一个字符串中没有包含的字符。</li><li><code>find_last_not_of</code>：从后往前查找何处出现另一个字符串中没有包含的字符。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;Source Code&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">if</span> ((n = s1.find(<span class="string">&#x27;u&#x27;</span>)) != <span class="built_in">string</span>::npos)  <span class="comment">//查找 u 出现的位置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1) &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">//输出 l)2,urce Code</span></span><br><span class="line">  <span class="keyword">if</span> ((n = s1.find(<span class="string">&quot;Source&quot;</span>, <span class="number">3</span>)) == <span class="built_in">string</span>::npos)</span><br><span class="line">    <span class="comment">//从下标3开始查找&quot;Source&quot;，找不到</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2) &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;Not Found&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 2) Not Found</span></span><br><span class="line">  <span class="keyword">if</span> ((n = s1.find(<span class="string">&quot;Co&quot;</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">    <span class="comment">//查找子串&quot;Co&quot;。能找到，返回&quot;Co&quot;的位置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3) &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">//输出 3) 7, Code</span></span><br><span class="line">  <span class="keyword">if</span> ((n = s1.find_first_of(<span class="string">&quot;ceo&quot;</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">    <span class="comment">//查找第一次出现或 &#x27;c&#x27;、&#x27;e&#x27;或&#x27;o&#x27;的位置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4) &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">//输出 4) l, ource Code</span></span><br><span class="line">  <span class="keyword">if</span> ((n = s1.find_last_of(<span class="string">&#x27;e&#x27;</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">    <span class="comment">//查找最后一个 &#x27;e&#x27; 的位置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5) &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 5) 10, e</span></span><br><span class="line">  <span class="keyword">if</span> ((n = s1.find_first_not_of(<span class="string">&quot;eou&quot;</span>, <span class="number">1</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">    <span class="comment">//从下标1开始查找第一次出现非 &#x27;e&#x27;、&#x27;o&#x27; 或 &#x27;u&#x27; 字符的位置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;6) &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">//输出 6) 3, rce Code</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="替换子串"><a href="#替换子串" class="headerlink" title="替换子串"></a>替换子串</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;Real Steel&quot;</span>)</span></span>;</span><br><span class="line">  s1.replace(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;123456&quot;</span>, <span class="number">2</span>,</span><br><span class="line">             <span class="number">4</span>);       <span class="comment">//用 &quot;123456&quot; 的子串(2,4) 替换 s1 的子串(1,3)</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 R3456 Steel</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">&quot;Harry Potter&quot;</span>)</span></span>;</span><br><span class="line">  s2.replace(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;0&#x27;</span>);  <span class="comment">//用 5 个 &#x27;0&#x27; 替换子串(2,3)</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">//输出 Ha00000 Potter</span></span><br><span class="line">  <span class="keyword">int</span> n = s2.find(<span class="string">&quot;00000&quot;</span>);  <span class="comment">//查找子串 &quot;00000&quot; 的位置，n=2</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  s2.replace(n, <span class="number">5</span>, <span class="string">&quot;XXX&quot;</span>);  <span class="comment">//将子串(n,5)替换为&quot;XXX&quot;</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//输出 HaXXX Potter</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除子串"><a href="#删除子串" class="headerlink" title="删除子串"></a>删除子串</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;Real Steel&quot;</span>)</span></span>;</span><br><span class="line">s1.erase(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//删除子串(1, 3)，此后 s1 = &quot;R Steel&quot;</span></span><br><span class="line">s1.erase(<span class="number">5</span>);  <span class="comment">//删除下标5及其后面的所有字符，此后 s1 = &quot;R Ste&quot;</span></span><br></pre></td></tr></table></figure><h3 id="插入子串"><a href="#插入子串" class="headerlink" title="插入子串"></a>插入子串</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1(&quot;Limitless&quot;), s2(&quot;00&quot;);</span><br><span class="line">s1.insert(<span class="number">2</span>, <span class="string">&quot;123&quot;</span>);  <span class="comment">//在下标 2 处插入字符串&quot;123&quot;，s1 = &quot;Li123mitless&quot;</span></span><br><span class="line">s1.insert(<span class="number">3</span>, s2);  <span class="comment">//在下标 2 处插入 s2 , s1 = &quot;Li10023mitless&quot;</span></span><br><span class="line">s1.insert(<span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;X&#x27;</span>);  <span class="comment">//在下标 3 处插入 5 个 &#x27;X&#x27;，s1 = &quot;Li1XXXXX0023mitless&quot;</span></span><br></pre></td></tr></table></figure><h3 id="用-STL-算法操作-string-对象"><a href="#用-STL-算法操作-string-对象" class="headerlink" title="用 STL 算法操作 string 对象"></a>用 STL 算法操作 string 对象</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">&quot;afgcbed&quot;</span>)</span></span>;</span><br><span class="line">  <span class="built_in">string</span>::iterator p = find(s.begin(), s.end(), <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">if</span> (p != s.end()) <span class="built_in">cout</span> &lt;&lt; p - s.begin() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 3</span></span><br><span class="line">  sort(s.begin(), s.end());</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 abcdefg</span></span><br><span class="line">  next_permutation(s.begin(), s.end());</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 abcdegf</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><p>可以使用<code>typedef</code>最简单</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> book_id;</span><br><span class="line">  <span class="built_in">string</span> book_title;</span><br><span class="line">  <span class="built_in">string</span> author;</span><br><span class="line">  <span class="built_in">string</span> subject;</span><br><span class="line">&#125; Book;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  Book book1;</span><br><span class="line">  book1.book_title = <span class="string">&quot;JavaScript高级程序设计&quot;</span>; <span class="comment">// 写着cpp我还在想着js</span></span><br><span class="line">  book1.author = <span class="string">&quot;Nicolas&quot;</span>;</span><br><span class="line">  book1.subject = <span class="string">&quot;Web Development&quot;</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; book1.book_title &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">       &lt;&lt; book1.author &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">       &lt;&lt; book1.subject &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><p>使用<code>new</code>申请，使用<code>delete</code>释放</p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m; <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">  <span class="keyword">int</span> *<span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">// 动态分配,数组长度为 m</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123; <span class="built_in">cin</span> &gt;&gt; <span class="built_in">array</span>[i]; &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">&quot; &quot;</span>; &#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">delete</span>[] <span class="built_in">array</span>; <span class="comment">// 释放内存</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> **p;</span><br><span class="line"><span class="keyword">int</span> i, j;  <span class="comment">// p[4][8]</span></span><br><span class="line"><span class="comment">//开始分配4行8列的二维数据</span></span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">int</span> *[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  p[i] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">    p[i][j] = j * i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数据</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p[i][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始释放申请的堆</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">delete</span>[] p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;  <span class="comment">//声明</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;vector a&#x27;s length = &quot;</span> &lt;&lt; a.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// 插入5个值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    a.push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;vector a&#x27;s length = &quot;</span> &lt;&lt; a.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// 使用迭代器 iterator 访问值</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator v = a.begin();</span><br><span class="line">  <span class="keyword">while</span> (v != a.end()) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;value of v = &quot;</span> &lt;&lt; *v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    v++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a.begin(), a.end() - <span class="number">1</span>)</span></span>;  <span class="comment">//构造新的vector</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;vector b&#x27;s length = &quot;</span> &lt;&lt; b.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未完待续，接着刷题，碰到了继续整理</p>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OJ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的强缓存和协商缓存</title>
      <link href="2021/06/20/Browser-Cache/"/>
      <url>2021/06/20/Browser-Cache/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h1><p>强制缓存整体流程比较简单，就是在<strong>第一次访问服务器取到数据之后，在过期时间之内不会再去重复请求</strong>。实现这个流程的核心就是如何知道当前时间是否超过了<strong>过期时间</strong>。</p><p>强制缓存的过期时间通过第一次访问服务器时返回的响应头获取。在 <code>http 1.0</code> 和 <code>http 1.1</code> 版本中通过<strong>不同的响应头字段</strong>实现。</p><h2 id="http-1-0"><a href="#http-1-0" class="headerlink" title="http 1.0"></a>http 1.0</h2><p>在 <code>http 1.0</code> 版本中，强制缓存通过 <strong><code>Expires</code></strong> 响应头来实现。 <code>expires</code> 表示未来资源会过期的时间。也就是说，当发起请求的时间超过了 <code>expires</code> 设定的时间，即表示资源缓存时间到期，会发送请求到服务器重新获取资源。而如果发起请求的时间在 <code>expires</code> 限定的时间之内，浏览器会直接读取本地缓存数据库中的信息（<code>from memory</code> or <code>from disk</code>），两种方式<strong>根据浏览器的策略随机获取</strong>。</p><h2 id="http-1-1"><a href="#http-1-1" class="headerlink" title="http 1.1"></a>http 1.1</h2><p>在 <code>http 1.1</code> 版本中，强制缓存通过 <strong><code>Cache-Control</code></strong> 响应头来实现。<code>Cache-Control</code> 拥有多个值：</p><ul><li><strong>private</strong>：客户端可以缓存</li><li><strong>public</strong>：客户端和<strong>代理服务器</strong>均可缓存；</li><li><strong>max-age=xxx</strong>：缓存的资源将在 xxx 秒后过期；</li><li><strong>no-cache</strong>：需要<strong>使用协商缓存</strong>来验证是否过期；</li><li><strong>no-store</strong>：不可缓存</li></ul><p>最常用的字段就是 <code>max-age=xxx</code> ，表示缓存的资源将在 xxx 秒后过期。一般来说，<strong>为了兼容，两个版本的强制缓存都会被实现</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>强制缓存只有首次请求才会跟服务器通信，<strong>读取缓存资源时不会发出任何请求</strong>，资源的 <code>Status</code> 状态码为 <code>200</code>，资源的 <code>Size</code> 为 <code>from memory</code> 或者 <code>from disk</code> ，http 1.1 版本的实现<strong>优先级会高于</strong> http 1.0 版本的实现。</p><h1 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h1><p>协商缓存与强制缓存的不同之处在于，协商缓存<strong>每次读取数据时都需要跟服务器通信</strong>，并且会<strong>增加缓存标识</strong>。在第一次请求服务器时，服务器会返回资源，并且返回一个<strong>资源的缓存标识</strong>，一起存到浏览器的缓存数据库。当第二次请求资源时，浏览器<strong>会首先将缓存标识发送给服务器</strong>，服务器拿到标识后判断标识是否匹配，如果不匹配，表示资源有更新，服务器会将新数据和<strong>新的缓存标识</strong>一起返回到浏览器；如果缓存标识匹配，表示资源没有更新，并且<strong>返回</strong> <strong><code>304</code></strong> <strong>状态码</strong>，浏览器就<strong>读取本地</strong>缓存服务器中的数据。</p><p>在 http 协议的 <code>1.0</code> 和 <code>1.1</code> 版本中也有不同的实现方式。</p><h2 id="http-1-0-1"><a href="#http-1-0-1" class="headerlink" title="http 1.0"></a>http 1.0</h2><p>在 <code>http 1.0</code> 版本中，第一次请求资源时<strong>服务器通过</strong> <strong><code>Last-Modified</code></strong> 来<strong>设置响应头的缓存标识</strong>，并且把资源最后修改的时间作为值填入，然后将资源返回给浏览器。在<strong>第二次请求</strong>时，浏览器会<strong>首先带上</strong> <strong><code>If-Modified-Since</code></strong> <strong>请求头</strong>去访问服务器，服务器会<strong>将</strong> <strong><code>If-Modified-Since</code></strong> 中携带的时间与<strong>资源修改的时间****匹配</strong>，如果时间不一致，服务器会返回新的资源，并且将 <strong><code>Last-Modified</code></strong> 值更新，作为响应头返回给浏览器。如果时间一致，表示资源没有更新，服务器返回 <code>304</code> 状态码，浏览器拿到响应状态码后从本地缓存数据库中读取缓存资源。</p><p>这种方式有一个<strong>弊端</strong>，就是当服务器中的资源增加了一个字符，后来又把这个字符删掉，<strong>本身资源文件并没有发生变化，但修改时间发生了变化</strong>。当下次请求过来时，服务器也会把这个<strong>本来没有变化的资源重新返回给浏览器</strong>。</p><h2 id="http-1-1-1"><a href="#http-1-1-1" class="headerlink" title="http 1.1"></a>http 1.1</h2><p>在 <code>http 1.1</code> 版本中，服务器通过 <code>Etag</code> 来设置响应头缓存标识。<code>Etag</code> 的值由服务端生成。在第一次请求时，服务器会将资源和 <code>Etag</code> 一并返回给浏览器，浏览器将两者缓存到本地缓存数据库。在第二次请求时，浏览器会将 <strong><code>Etag</code></strong> 信息放到 <strong><code>If-None-Match</code></strong> 请求头去访问服务器，服务器收到请求后，<strong>会将服务器中的文件标识与浏览器发来的标识进行对比</strong>，如果不相同，服务器<strong>返回更新的资源</strong>和新的 <code>Etag</code> ，如果相同，<strong>服务器返回</strong> <strong><code>304</code></strong> <strong>状态码</strong>，浏览器读取缓存。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>协商缓存<strong>每次请求都会与服务器交互</strong>，第一次是<strong>拿数据和标识</strong>的过程，第二次开始，就是浏览器<strong>询问服务器资源是否有更新</strong>的过程。<strong>每次请求都会传输数据</strong>，如果命中缓存，则资源的 <code>Status</code> 状态码为 <code>304</code> 而不是 <code>200</code> 。同样的，一般来讲<strong>为了兼容</strong>，<strong>两个版本的协商缓存都会被实现</strong>，<code>http 1.1</code> 版本的实<strong>现优先级会高于</strong> <code>http 1.0</code> 版本的实现。</p><h1 id="参考原文"><a href="#参考原文" class="headerlink" title="参考原文"></a>参考原文</h1><blockquote><p><a href="https://segmentfault.com/a/1190000016199807?utm_source=sf-similar-article">10分钟彻底搞懂Http的强制缓存和协商缓存 - SegmentFault 思否</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器缓存 </tag>
            
            <tag> 前端面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法汇总</title>
      <link href="2021/06/17/Sorting/"/>
      <url>2021/06/17/Sorting/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="排序基本概念"><a href="#排序基本概念" class="headerlink" title="排序基本概念"></a>排序基本概念</h1><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>经过排序后，能使关键字相同的元素仍然保持原顺序中的相对位置不变，则称该排序算法是稳定的，否则是不稳定的。</p><p>算法是否具有稳定性，并不能衡量一个算法的优劣，它主要是对算法性质的描述。</p><p>如果待排序表中关键字不重复，那么选择排序算法时的稳定与否就无关紧要。</p><h2 id="排序分类"><a href="#排序分类" class="headerlink" title="排序分类"></a>排序分类</h2><p>根据数据元素是否完全在内存中，分为：</p><ol><li>内部排序：排序期间元素全部存放在内存中的排序。</li><li>外部排序：排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存中移动的排序。</li></ol><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(Elemtype A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="comment">// 依次将A[2]~A[n]插入到前面已经排序好的序列中</span></span><br><span class="line">        <span class="keyword">if</span> (A[i]&lt;A[i<span class="number">-1</span>])&#123;<span class="comment">// 若A[i]关键码小于其前驱，将A[i]插入有序表</span></span><br><span class="line">            A[<span class="number">0</span>] = A[i];<span class="comment">// 复制为哨兵，A[0]不存放元素</span></span><br><span class="line">            <span class="keyword">for</span> (j=i<span class="number">-1</span>;A[<span class="number">0</span>]&lt;A[j];j--)&#123;<span class="comment">// 从后往前查找插入位置</span></span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];<span class="comment">// 为待插入的元素腾挪空间</span></span><br><span class="line">            &#125;</span><br><span class="line">            A[j+<span class="number">1</span>] = A[<span class="number">0</span>];<span class="comment">// 将哨兵复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法性质分析"><a href="#算法性质分析" class="headerlink" title="算法性质分析"></a>算法性质分析</h3><ul><li>稳定性：稳定</li><li>适用性：适用于顺序存储和链式存储的线性表</li><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><h3 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h3><p>在直接插入排序算法中，每趟插入排序都进行了两项工作：</p><ol><li>从前面的有序子表中查找出待插入元素应该被插入的位置；</li><li>给插入位置腾出空间，将待插入元素复制到表中插入位置。</li></ol><p>该算法总是边比较边移动元素。</p><p>而折半插入排序将比较和移动分离，先进行折半查找，找到元素插入位置，然后统一移动插入位置后所有元素。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,low,mid,high;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="comment">// 依次将A[2]~A[n]插入前面已排序的序列</span></span><br><span class="line">        A[<span class="number">0</span>] = A[i];<span class="comment">// 将A[i]存入哨兵</span></span><br><span class="line">        low = <span class="number">1</span>; high = i<span class="number">-1</span>;<span class="comment">// 设置折半查找的范围</span></span><br><span class="line">        <span class="keyword">while</span> (low&lt;=high)&#123;<span class="comment">// 折半查找</span></span><br><span class="line">            mid = (low+high)/<span class="number">2</span>;<span class="comment">// 取中间点</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid]&gt;A[<span class="number">0</span>])</span><br><span class="line">                high = mid<span class="number">-1</span>;<span class="comment">// 查找左子表</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid+<span class="number">1</span>;<span class="comment">// 查找右子表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;--j)&#123;</span><br><span class="line">            A[j+<span class="number">1</span>] = A[j];<span class="comment">// 统一移动元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        A[high+<span class="number">1</span>] = A[<span class="number">0</span>];<span class="comment">// 插入操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法性质分析-1"><a href="#算法性质分析-1" class="headerlink" title="算法性质分析"></a>算法性质分析</h3><ul><li>稳定性：稳定</li><li>适用性：仅适合顺序表</li><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>待续</p><h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><blockquote><p>所谓交换，是指序列中两个元素关键字的对比结果来对换两个记录在序列中的位置。</p></blockquote><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>基本思想：从后往前（或者从前往后）两两比较相邻元素的值，若为逆序(<code>A[i-1]&gt;A[i]</code>)，则交换它们，直到序列比较完。我们称它为第一趟冒泡，结果是将最小的元素交换到待排序列的第一个位置(或将最大的元素交换到待排序列的最后一个位置)。</p><p>下一趟冒泡时，前一趟确定的最小元素不再参与比较。如果某一趟排序没有发生交换，则说明表已有序，冒泡排序结束。</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;<span class="comment">// 表示本趟排序是否发生交换</span></span><br><span class="line">        <span class="keyword">for</span> (j=n<span class="number">-1</span>;j&gt;i;j--)&#123;<span class="comment">// 一趟冒泡的过程</span></span><br><span class="line">            <span class="keyword">if</span> (A[j<span class="number">-1</span>]&gt;A[j])&#123;<span class="comment">// 若为逆序</span></span><br><span class="line">                swap(A[j<span class="number">-1</span>],A[j]);<span class="comment">// 交换</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>)<span class="comment">// 本趟排序没有发生交换，排序结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法性质分析-2"><a href="#算法性质分析-2" class="headerlink" title="算法性质分析"></a>算法性质分析</h3><ul><li>稳定性：稳定</li><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot_pos = Partition(A, low, high); <span class="comment">//划分</span></span><br><span class="line">        QuickSort(A, low, pivot_pos<span class="number">-1</span>); <span class="comment">//依次对两个子表进行递归排序</span></span><br><span class="line">        QuickSort(A, pivot_pos+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 划分函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    ElemType pivot = A[low];<span class="comment">// 将当前表中第一个元素作为枢轴，对表进行划分</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) --high;</span><br><span class="line">        A[low] = A[high];<span class="comment">// 将比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) ++low;</span><br><span class="line">        A[high] = A[low];<span class="comment">// 将比枢轴元素大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;<span class="comment">// 枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;<span class="comment">// 返回枢轴元素最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法性质分析-3"><a href="#算法性质分析-3" class="headerlink" title="算法性质分析"></a>算法性质分析</h3><ul><li>稳定性：不稳定</li><li>时间复杂度：<ul><li>快速排序的运行时间和划分是否对称有关。最坏情况发生在两个区域分别包含$n-1$个和$0$个元素时。这种最大程度的不对称性发生在每层递归上。即对应于初始排序表基本有序或者基本逆序时，<strong>最坏的时间复杂度为$O(n^2)$</strong></li><li>最理想的状态下，快速排序将两个子问题划分的大小都不可能大于$n/2$，这种情况下快速排序的运行速度大大提升，此时时间复杂度为$O(log_2n)$</li><li>快速排序的平均运行时间和最佳运行时间接近，是所有内部排序算法中平均性能最好的排序算法</li></ul></li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序的基本思想是：每一趟排序$i$，在后面$n-i+1;(i=1,2,…,n-1)$个待排序元素中，选取关键字最小的元素，作为有序子序列的第$i$个元素，直到第$n-1$趟做完，待排序元素只剩下一个，就不用再选了。</p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j]&lt;A[min]) min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != j) swap(A[i],A[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法性质分析-4"><a href="#算法性质分析-4" class="headerlink" title="算法性质分析"></a>算法性质分析</h3><ul><li>稳定性：不稳定</li><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><blockquote><p>n个关键字序列$L[1…n]$称为堆，当且仅当该序列满足：</p><ol><li>$L[i]≥L[2i]且L[i]≥L[2i+1]$或</li><li>$L[i]≤L[2i]且L[i]≤L[2i+1]$   $(1≤i≤ \lfloor n/2 \rfloor)$</li></ol></blockquote><p>将该一维数组视为一棵完全二叉树</p><ul><li>满足条件①的堆称为大根堆，大根堆最大元素存放在根结点，且任一非根结点的值小于等于其双亲结点值。</li><li>满足条件②的堆称为小根堆，小根堆的定义刚好相反，根结点是最小元素。</li></ul><p>以大根堆为例，堆排序为升序排列。堆排序步骤：</p><ol><li>首先将初始数组构造大根堆</li><li>输出根结点(当前最大值)</li><li>根结点与最后一个元素交换位置，然后删除最后一个元素(最后一个元素为最大值，已经调整到了对应的位置，不参与下一轮的排序)</li><li>此时的数组已经不是大根堆，调整根结点的位置使其再次成为大根堆。</li><li>如此重复直到堆中只剩下一个元素，排序完成</li></ol><p>需要解决两个问题：</p><ol><li>如果构造初始堆</li><li>输出堆顶元素后，如何调整新的堆</li></ol><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="建立大根堆的算法"><a href="#建立大根堆的算法" class="headerlink" title="建立大根堆的算法"></a>建立大根堆的算法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;<span class="comment">// 从i=[n/2]~1，反复调整堆</span></span><br><span class="line">    HeadAdjust(A, i, len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数HeadAdjust将元素k为跟的子树进行调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(ElemType A[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  A[<span class="number">0</span>] = A[k];<span class="comment">// 将A[0]暂存子树的根结点，实际存放元素的地址为A[1~len]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>*k;i&lt;=len;i*=<span class="number">2</span>)&#123;<span class="comment">// 沿key较大的子结点向下筛选</span></span><br><span class="line">    <span class="keyword">if</span> (i&lt;len &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])<span class="comment">// 取key较大的子结点下标</span></span><br><span class="line">      i++;</span><br><span class="line">    <span class="keyword">if</span> (A[<span class="number">0</span>]&gt;=A[i]) <span class="keyword">break</span>;<span class="comment">// 筛选结束</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      A[k] = A[i];<span class="comment">// 将A[i]调整到双亲结点上</span></span><br><span class="line">      k = i;<span class="comment">// 修改k的值，以便继续向下筛选</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  A[k] = A[<span class="number">0</span>];<span class="comment">// 被筛选的结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  BuildMaxHeap(A, len);<span class="comment">// 建初始堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=len; i&gt;<span class="number">1</span>; i--)&#123;<span class="comment">// n-1趟的交换和建堆过程</span></span><br><span class="line">    Swap(A[i],A[<span class="number">1</span>]);<span class="comment">// 输出堆顶元素(和堆底元素交换)</span></span><br><span class="line">    HeadAdjust(A, <span class="number">1</span>, i<span class="number">-1</span>);<span class="comment">// 调整，把剩余i-1个元素整理成堆</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法性质分析-5"><a href="#算法性质分析-5" class="headerlink" title="算法性质分析"></a>算法性质分析</h3><ul><li>稳定性：不稳定</li><li>时间复杂度：$O(nlog_2n)$<ul><li>建堆时间：$O(n)$</li><li>之后有$n-1$次向下调整操作，每次调整的时间复杂度为$O(h)$</li></ul></li><li>空间复杂度：$O(1)$</li></ul><h1 id="归并排序和基数排序"><a href="#归并排序和基数排序" class="headerlink" title="归并排序和基数排序"></a>归并排序和基数排序</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>归并的含义是：将两个或两个以上的有序表组合成一个新的有序表。假定待排序的有序表含有$n$个记录，则可将其视为$n$个有序子表，每个子表的长度为$1$，然后两两归并，得到$\lceil n/2 \rceil$个长度为2或1的有序表；继续两两归并……如此重复，直到合并成一个长度为$n$的有序表为止，这种排序方法称为$2$路归并排序</p></blockquote><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ElemType * B = (ElemType *)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="keyword">sizeof</span>(ElemType)); <span class="comment">//创建辅助数组B</span></span><br><span class="line"><span class="comment">// Merge函数将前后相邻的两个有序表归并为一个有序表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 表A的两段[low...mid]和A[mid+1...high]各自有序，将它们合并为一个有序表</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k=low;k&lt;=high;k++)&#123;</span><br><span class="line">    B[k] = A[k];<span class="comment">// 将A中所有的元素复制到B中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (B[i] &lt; B[j])&#123;<span class="comment">// 将较小值复制到A中</span></span><br><span class="line">      A[k] = B[i++];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      A[k] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i&lt;=mid) A[k++] = B[i++];</span><br><span class="line">  <span class="keyword">while</span> (j&lt;=high) A[k++] = B[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    MergeSort(A, low, mid);<span class="comment">// 对左侧子序列进行归并排序</span></span><br><span class="line">    MergeSort(A, mid+<span class="number">1</span>, high);<span class="comment">// 对右侧子序列进行归并排序</span></span><br><span class="line">    Merge(A, low, mid, high);<span class="comment">// 合并左右子序列</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法性质分析-6"><a href="#算法性质分析-6" class="headerlink" title="算法性质分析"></a>算法性质分析</h3><p>2路归并算法性能分析：</p><ul><li>稳定性：稳定</li><li>时间复杂度：每趟归并的时间复杂度为$O(n)$，共需进行$\lceil log_2n \rceil$趟归并，总共时间复杂度为$O(nlog_2n)$</li><li>空间复杂度：<code>Merge</code>操作中，辅助空间的大小为$n$个单元，所以空间复杂度为$O(n)$</li></ul><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><blockquote><p>基数排序不基于比较和移动进行排序，而是基于关键字各位的大小进行排序。</p><p>基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。</p></blockquote><p>假设长度为$n$的线性表中每一个结点$a_j$的关键字由$d$元组$(k_j^{d-1},k_j^{d-2},…k_j^0)$组成，满足$0≤k_j^i≤r-1;(0≤j&lt;n,0≤i≤d-1)$。其中$k_j^{d-1}$为主关键字，$k_j^0$为最次位关键字。</p><p>通常有两种方法实现基数(多关键字)排序</p><ol><li>最高位优先法(MSD)，按关键字位权重一次递减逐层划分成若干更小的子序列，最后将所有的子序列依次连接成一个有序序列。</li><li>最低位优先法(LSD)，按关键字权重递增依次进行排序，最后形成一个有序序列。</li></ol><h3 id="基础排序过程"><a href="#基础排序过程" class="headerlink" title="基础排序过程"></a>基础排序过程</h3><p>以$r$为基数的最低位优先基数排序过程，使用了$r$个队列：$Q_0,Q_1,…,Q_{r-1}$</p><p>对$i=0,1,…,d-1$依次做一次“分配”和“收集”</p><ul><li>分配：开始时，所有队列为空，依次考察线性表中每个结点对应关键字的值，若$a_j$的关键字$k_j^i=k$，就放入$Q_k$队列中</li><li>收集：把$Q_0,Q_1,…,Q_{r-1}$各个队列中的结点依次首尾相接，得到新的结点序列，组成新的线性表。</li></ul><h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><ol><li>数据元素的关键字可以方便地拆分为$d$组，且$d$较小，</li><li>每组关键字的取值范围不大，即$r$较小</li><li>数据元素个数$n$较大</li></ol><h3 id="算法性质分析-7"><a href="#算法性质分析-7" class="headerlink" title="算法性质分析"></a>算法性质分析</h3><ul><li>稳定性：稳定</li><li>时间复杂度：基数排序需要进行$d$趟分配和收集，一趟分配需要$O(n)$，一趟收集需要$O(r)$，所以基数排序的时间复杂度为$O(d(n+r))$，它与序列的初始状态无关。</li><li>空间复杂度：一趟排序需要辅助存储空间$r$($r$个队列)并且可以重复使用，所以空间复杂度为$O(r)$</li></ul><h1 id="内部排序算法比较及应用"><a href="#内部排序算法比较及应用" class="headerlink" title="内部排序算法比较及应用"></a>内部排序算法比较及应用</h1><h2 id="内部排序算法比较"><a href="#内部排序算法比较" class="headerlink" title="内部排序算法比较"></a>内部排序算法比较</h2><table><thead><tr><th align="center">算法种类</th><th align="center">最好时间复杂度</th><th align="center">平均时间复杂度</th><th align="center">最坏时间复杂度</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">直接插入排序</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">稳定</td></tr><tr><td align="center">冒泡排序</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">稳定</td></tr><tr><td align="center">简单选择排序</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">希尔排序</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">快速排序</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(log_2n)$</td><td align="center">不稳定</td></tr><tr><td align="center">堆排序</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">2路归并排序</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(nlog_2n)$</td><td align="center">$O(n)$</td><td align="center">稳定</td></tr><tr><td align="center">基数排序</td><td align="center">$O(d(n+r))$</td><td align="center">$O(d(n+r))$</td><td align="center">$O(d(n+r))$</td><td align="center">$O(r)$</td><td align="center">稳定</td></tr></tbody></table><h2 id="内部排序算法应用"><a href="#内部排序算法应用" class="headerlink" title="内部排序算法应用"></a>内部排序算法应用</h2><p>选取排序算法时，应该考虑的因素：</p><ol><li>待排序的元素数目$n$，</li><li>元素本身信息量的大小</li><li>关键字的结构及其分布情况</li><li>稳定性的要求</li><li>语言工具的条件、存储结构、辅助空间的大小</li></ol><h2 id="排序算法小结"><a href="#排序算法小结" class="headerlink" title="排序算法小结"></a>排序算法小结</h2><ol><li>若$n$较小，可采用直接插入排序或简单选择排序。由于直接插入排序需要移动的记录次数较多，因此当记录本身信息量比较大时，用简单选择排序比较好。</li><li>若初始状态基本有序，则使用直接插入排序或冒泡排序</li><li>若$n$较大，则应采用时间复杂度为$O(nlog_2n)$的排序方法：快速排序，堆排序或归并排序。<ol><li>快速排序被认为是基于比较的内部排序中最好的方法，当待排序的关键字随机分布时，快速排序的平均时间较短。</li><li>堆排序所需要的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况，这两种排序都是不稳定的。</li><li>若要求排序稳定并且时间复杂度为$O(nlog_2n)$，则可选归并排序。</li></ol></li><li>基于比较的排序方法中，每次比较两个关键字的大小后，仅出现两种可能的转移，因此可以用一棵二叉树来描述比较判定的过程，由此可以证明：当文件的$n$个关键字随机分布时，任何借助于比较的排序算法，至少需要$O(nlog_2n)$的时间。</li><li>若$n$很大，记录的关键字位数较少、且可以分解时，采用基数排序较好。</li><li>当记录本身信息量很大时，为避免移动耗费大量的时间，可使用链表作为存储结构。</li></ol><h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><h2 id="外部排序内容"><a href="#外部排序内容" class="headerlink" title="外部排序内容"></a>外部排序内容</h2><ol><li>外部排序指待排序文件较大，内存一次放不下，需要存放在外存的文件的排序</li><li>为减少平衡归并中外存读写次数所采用的方法：<ol><li>增加归并路数——利用败者树(减少关键字对比次数)</li><li>减少归并段数——利用置换-选择排序增大归并段长度以减少归并段个数</li></ol></li><li>长度不等的归并段，进行多路平衡归并，需要构造最佳归并树</li></ol><p>一般情况下：<br>$$<br>外部排序时间=内部排序时间+外存信息读写时间+内部归并所需的时间<br>$$<br>对$r$个初始归并段，做$k$路平衡归并，归并树可以用严格$k$叉树(只有度为$0或k$的结点)来表示。第一趟可将$r$个初始归并段归并为$\lceil r/k\rceil$归并段，以后每趟归并将$m$个归并段归并成$\lceil m/k \rceil$个归并段，直至最后形成一个大的归并段为止。<br>$$<br>树的高度=\lceil log_kr \rceil =归并趟树S<br>$$<br>可见，只要增大归并路数$k$，或减少初始归并段个数$r$，都能减少归并趟数$S$，进而减少磁盘读写次数，达到提高外部排序速度的目的。</p><h2 id="多路平衡归并与败者树-减少关键字对比次数"><a href="#多路平衡归并与败者树-减少关键字对比次数" class="headerlink" title="多路平衡归并与败者树(减少关键字对比次数)"></a>多路平衡归并与败者树(减少关键字对比次数)</h2><p>做内部归并时，在$k$个元素中选择关键字最小的记录需要比较$k-1$次。每趟归并$n$个元素需要做$(n-1)(k-1)$次比较，$S$趟归并总共需要比较的次数为<br>$$<br>S(n-1)(k-1)=\lceil log_kr \rceil (n-1)(k-1)=\frac{\lceil log_2r \rceil}{\lceil log_2k \rceil} \cdot(n-1)(k-1)<br>$$<br>为了使内部归并不受$k$增大的影响，引入了<strong>败者树</strong>。败者树是树形选择排序的一种变体，可视为一棵完全二叉树。</p><p>$k$个叶结点分别存放$k$个归并段在归并过程中参加比较的记录，内部结点用来记忆左右子树中的“失败者”，而胜者继续上升进行比较，一直到根结点。</p><img src= "/img/loading.gif" data-lazy-src="https://jzhmcoo1-1258918430.cos.ap-shanghai.myqcloud.com/markdown/20210619154736-败者树.png" alt="败者树" style="zoom:50%;" /><p>$k$路归并的败者树深度为$\lceil log_2k \rceil$，因此$k$个记录中选择最小关键字，最多需要$\lceil log_2k \rceil$次比较。所以需要总的比较次数为<br>$$<br>S(n-1) \lceil log_2k \rceil = \lceil log_kr \rceil(n-1)\lceil log_2k \rceil = (n-1)\lceil log_2r \rceil<br>$$<br>使用败者树后，内部归并的次数与$k$无关了。因此，只要内存空间允许，增大归并路数$k$将有效地减少归并树的高度，从而减少$I/O$的次数，提高外部排序的速度。</p><p>归并路数$k$并不是越大越好。归并路数$k$增大时，相应地需要增加输入缓存区的个数。若内存空间大小不变，势必要减少每个输入缓存区的容量，会使得内存、外存交换数据次数增大。</p><h2 id="置换-选择排序-减少初始归并段"><a href="#置换-选择排序-减少初始归并段" class="headerlink" title="置换-选择排序(减少初始归并段)"></a>置换-选择排序(减少初始归并段)</h2><p>减少初始归并段的个数$r$也可以减少归并趟数$S$。若总的记录个数为$n$，每个归并段的长度为$l$，则归并段的个数$r=\lceil n/l \rceil$。采用内部排序方法得到的各个初始归并段长度都相同(除最后一段外)，它依赖于内部排序时可用内存工作区的大小。</p><p>因此需要使用置换选择算法来产生更长的初始归并段。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>假设初始待排文件尾FI，初始输出文件尾FO，内存工作区为WA，FO和WA初始为空，WA可容纳$w$个记录</p><ol><li>从FI中输入$w$个记录到工作区WA，</li><li>从WA中选取关键字最小的记录，记为$MINMAX$</li><li>将$MINMAX$输出到FO中</li><li>若FI不为空，继续读入下一个记录到WA中</li><li>从WA中所有关键字比MINMAX记录的关键字大的记录中选取最小关键字记录，作为新的$MINMAX$记录</li><li>重复3~5，直到WA中选不出一个比MINMAX大的记录为止，由此得到一个初始归并段</li><li>重复2~6，直到WA为空。由此得到全部的初始归并段</li></ol><p>上述算法中，WA中选择$MINIMAX$记录的过程需要使用<strong>败者树</strong>实现。</p><h2 id="最佳归并树-使I-O次数最少"><a href="#最佳归并树-使I-O次数最少" class="headerlink" title="最佳归并树(使I/O次数最少)"></a>最佳归并树(使I/O次数最少)</h2><p>文件经过置换-选择排序后，得到的是长度不相等的初始归并段。构造最佳归并树，组织长度不相等的初始归并段的归并顺序，使得I/O次数最少。</p><p>将哈夫曼树的思想推广到$m$叉树的情形，在归并树中，让记录数少的初始归并段最先归并，记录多的初始归并段最晚归并，就可以建立总的I/O次数最少的最佳归并树。</p><h3 id="构造最佳归并树"><a href="#构造最佳归并树" class="headerlink" title="构造最佳归并树"></a>构造最佳归并树</h3><ul><li>严格$k$叉树：树中只有度为$0$或度为$k$的结点。</li></ul><p>若初始归并段不足以构成一棵严格的$k$叉树时，添加长度为$0$的“虚段”，按照哈夫曼树的规则，权为$0$的结点应该离树根最远。</p><p>如何判断添加虚段的数目？设度为$0$的节点有$n_0(=n)$个，度为$k$的结点有$n_k$个，则对严格$k$叉树有$n_0=(k-1)n_k+1$，由此可得$n_k=(n_0-1)/(k-1)$</p><ul><li>若$(n_0-1) mod (k-1)=0$，则说明这$n_0$个叶结点，正好可以构成$k$叉归并树，此时内结点有$n_k$个</li><li>若$(n_0-1) mod (k-1)=u≠0$，则说明这$n_0$个结点有$u$个多余，不能包含在$k$叉归并树中。需要再加上$k-u-1$个空归并段。</li></ul><h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><p>《王道-数据结构考研复习指导》</p>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>散列表查找</title>
      <link href="2021/06/17/Hash/"/>
      <url>2021/06/17/Hash/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="散列表基本概念"><a href="#散列表基本概念" class="headerlink" title="散列表基本概念"></a>散列表基本概念</h1><ul><li>散列函数：把关键字映射成对应地址的函数，记为$Hash(key)=Addr$</li><li>冲突：散列函数可能把两个或以上不同关键字映射为同一地址</li><li>散列表：根据关键字进行直接访问的数据结构</li></ul><h1 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h1><ol><li>散列函数定义域必须包含全部关键字，值域范围取决于散列表大小</li><li>散列函数计算的地址应该能等概率、均匀分布在整个地址空间中，从而减少冲突的发生。</li><li>散列函数应该尽量简单，尽快算出任一关键字对应的地址。</li></ol><h1 id="常用散列函数"><a href="#常用散列函数" class="headerlink" title="常用散列函数"></a>常用散列函数</h1><h2 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h2><p>使用某个线性函数值作为散列地址，散列函数为<br>$$<br>H(key) = key ; 或 ; H(key)=a\times key+b<br>$$<br>式中$a,b$为常数。</p><ul><li>优点：计算简单，且不会产生冲突。<strong>适合关键字的分布基本连续</strong>。</li><li>缺点：关键字分布不连续空位多，浪费地址空间</li></ul><h2 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h2><p>假设散列表的长度为$m$，选一个不大于$m$但最接近或等于$m$的质数$p$，利用下列公式进行转换<br>$$<br>H(key) = key ;  % ; p<br>$$</p><h2 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h2><p>设关键字为$r$进制数，在各位上，各个数码出现频率不相同，选取那些分布比较均匀的若干位作为散列地址。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造散列函数</p><h2 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h2><p>取关键字平方值的中间几位作为散列地址。这种方法得到的散列地址与关键字每位都有关系，因此得到的散列地址分布比较均匀。适合于关键字每位取值都不够均匀或均小于散列地址所需的位数。</p><h1 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h1><h2 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h2><h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><p>每次出现冲突就往后再找一位</p><p>缺点：造成大量元素在相邻散列地址上<strong>堆积</strong></p><h3 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h3><p>以$d_i=0^2,1^2,-1^2,2^2,-2^2…,k^2,-k^2$的顺序进行查找，其中$k≤m/2$，散列表长度$m$必须是一个可以表示为$4j+3$的质数时，才能探测完所有的地址</p><h3 id="再散列法"><a href="#再散列法" class="headerlink" title="再散列法"></a>再散列法</h3><p>发生冲突时，使用另一个散列函数在计算地址。具体散列函数形式如下：<br>$$<br>H_i = (H(key)+i\times Hash_2(key));%;m<br>$$<br>$i$是冲突的次数，初始为0。最多经过$m-1$次探测就会遍历表中所有位置，回到$H_0$</p><h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><p>为了避免非同义词发生冲突，可以把所有同义词存储到一个线性链表中。适用于经常插入和删除的情况。</p><p><img src= "/img/loading.gif" data-lazy-src="https://jzhmcoo1-1258918430.cos.ap-shanghai.myqcloud.com/markdown/20210617204632.png" alt="hash表"></p><h1 id="散列查找性能分析"><a href="#散列查找性能分析" class="headerlink" title="散列查找性能分析"></a>散列查找性能分析</h1><h2 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h2><p>虽然散列表在关键字与存储位置间建立了映射，但由于冲突的产生，使得散列表查找过程中仍需要与关键字进行比较。因此仍然需要以平均查找长度$ASL$作为衡量散列表查找效率的度量</p><h2 id="散列表查询效率"><a href="#散列表查询效率" class="headerlink" title="散列表查询效率"></a>散列表查询效率</h2><p>取决于：散列函数、冲突处理方法、装填因子</p><h3 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h3><p>散列表的装填因子记为$\alpha$，定义为一个表的装满程度<br>$$<br>\alpha = \frac{表中记录数n}{散列表长度m}<br>$$<br>散列表的平均查找长度依赖于散列表的装填因子，而不直接依赖于$n$或者$m$。</p><p>$\alpha$越大，发生冲突的可能性越大，反之则越小。</p><h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><p>《王道数据结构考研复习指导》</p>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Hash表 </tag>
            
            <tag> 散列表 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP和HTTPS对比</title>
      <link href="2021/06/13/HTTP-&amp;-HTTPS/"/>
      <url>2021/06/13/HTTP-&amp;-HTTPS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p> <a href="https://juejin.cn/post/6844903830916694030">https://juejin.cn/post/6844903830916694030</a></p></blockquote><blockquote><p> <a href="https://www.nowcoder.com/tutorial/96/4700c6f1f3334c9191a38406002efa65">https://www.nowcoder.com/tutorial/96/4700c6f1f3334c9191a38406002efa65</a></p></blockquote><p><strong>HTTPS是HTTP在传输层上进行SSL加密实现的</strong></p><p>http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（<strong>TCP</strong>），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p><strong>HTTPS主要作用</strong>是：</p><p>（1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;</p><p>（2）对网站服务器进行真实身份认证。</p><h1 id="HTTP存在的问题"><a href="#HTTP存在的问题" class="headerlink" title="HTTP存在的问题"></a>HTTP存在的问题</h1><ul><li>通信使用明文（不加密），内容可能被窃听</li><li>无法证明报文的完整性，所以可能遭篡改</li><li>不验证通信方的身份，因此有可能遭遇伪装</li></ul><h1 id="HTTPS优势"><a href="#HTTPS优势" class="headerlink" title="HTTPS优势"></a>HTTPS优势</h1><ul><li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li><li>数据完整性：内容传输经过完整性校验</li><li>身份认证：第三方无法伪造服务端（客户端）身份</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;</li><li>HTTPS需要用到SSL证书，而HTTP不用;</li><li>HTTPS标准端口443，HTTP标准端口80;</li><li>HTTPS基于传输层，HTTP基于应用层;</li><li>HTTPS在浏览器显示绿色安全锁，HTTP没有显示;</li></ul><h1 id="HTTPS如何解决上述问题？"><a href="#HTTPS如何解决上述问题？" class="headerlink" title="HTTPS如何解决上述问题？"></a>HTTPS如何解决上述问题？</h1><p>HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。</p><p>通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，<strong>所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://jzhmcoo1-1258918430.cos.ap-shanghai.myqcloud.com/markdown/20210613103539-https-essence.png" alt="image.png"></p><h2 id="解决内容被窃听——加密"><a href="#解决内容被窃听——加密" class="headerlink" title="解决内容被窃听——加密"></a>解决内容被窃听——加密</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>加密和解密同用一个密钥。加密和解密都会用到密钥。<strong>没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了</strong>。</p><p>以<strong>对称加密方式加密时必须将密钥也发给对方</strong>。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，<strong>私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得</strong>。</p><p>使用公开密钥加密方式，发送密文的一方使用<strong>对方的公开密钥****进行加密处理</strong>，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</p><p>非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。</p><p>这种方式有以下缺点：</p><ul><li>公钥是公开的，所以针对私钥加密的信息，黑客截获后可以使用公钥进行解密，获取其中的内容；</li><li>公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，<strong>服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改；</strong></li><li>使用非对称加密<strong>在数据加密解密过程需要消耗一定时间</strong>，降低了数据传输效率；</li></ul><h3 id="对称加密-非对称加密-HTTPS采用这种方式"><a href="#对称加密-非对称加密-HTTPS采用这种方式" class="headerlink" title="对称加密+非对称加密(HTTPS采用这种方式)"></a>对称加密+非对称加密(HTTPS采用这种方式)</h3><p>（<strong>交换密钥时，使用非对称；传输信息时，使用对称</strong>）</p><p>使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。</p><p>将对称加密与非对称加密结合起来,充分利用两者各自的优势，<strong>在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式</strong>。</p><p>具体做法是：<strong>发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信</strong>。所以，HTTPS采用对称加密和非对称加密两者并用的混合加密机制。</p><h2 id="解决报文遭篡改——数字签名"><a href="#解决报文遭篡改——数字签名" class="headerlink" title="解决报文遭篡改——数字签名"></a>解决报文遭篡改——数字签名</h2><p>网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？—-校验数字签名。</p><h3 id="数字签名作用"><a href="#数字签名作用" class="headerlink" title="数字签名作用"></a>数字签名作用</h3><ul><li>能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。</li><li>数字签名能确定消息的完整性,证明数据是否未被篡改过。</li></ul><h3 id="如何生成数字签名"><a href="#如何生成数字签名" class="headerlink" title="如何生成数字签名"></a>如何生成数字签名</h3><p>将一段文本<strong>先用Hash函数生成消息摘要</strong>，然后<strong>用发送者的私钥加密生成数字签名</strong>，与原文文一起传送给接收者。</p><p><img src= "/img/loading.gif" data-lazy-src="https://jzhmcoo1-1258918430.cos.ap-shanghai.myqcloud.com/markdown/20210613103406-generate-digital-sign.png" alt="image.png"></p><p>接下来就是<strong>接收者校验数字签名</strong>的流程了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://jzhmcoo1-1258918430.cos.ap-shanghai.myqcloud.com/markdown/20210613103454-check-digital-sign.png" alt="image.png"></p><p>接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</p><h2 id="解决通信方伪装——数字证书"><a href="#解决通信方伪装——数字证书" class="headerlink" title="解决通信方伪装——数字证书"></a>解决通信方伪装——数字证书</h2><p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。</p><ul><li>服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;</li><li>CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;</li><li>如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中<strong>签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名;</strong></li><li>客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;</li><li>客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。</li><li>客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。</li></ul><h1 id="HTTPS工作流程"><a href="#HTTPS工作流程" class="headerlink" title="HTTPS工作流程"></a>HTTPS工作流程</h1><p><img src= "/img/loading.gif" data-lazy-src="https://jzhmcoo1-1258918430.cos.ap-shanghai.myqcloud.com/markdown/20210613103228-https-work-process.png" alt="image.png"></p><ol><li>Client<strong>发起一个HTTPS的请求</strong>，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。</li><li>Server把事先配置好的<strong>公钥证书</strong>（public key certificate）返回给客户端。</li><li>Client验证公钥证书：比如是否在<strong>有效期</strong>内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</li><li>Client使用<strong>伪随机数生成器生成加密所使用的对称密钥</strong>，然后<strong>用证书的公钥加密这个对称密钥</strong>，发给Server。</li><li>Server使用自己的<strong>私钥</strong>（private key）<strong>解密</strong>这个消息，<strong>得到****对称密钥</strong>。至此，Client和Server<strong>双方都持有了相同的对称密钥</strong>。</li><li>Server使用<strong>对称密钥加密“明文内容A”</strong>，发送给Client。</li><li>Client使用<strong>对称密钥解密响应的密文</strong>，得到“明文内容A”。</li><li>Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。</li></ol>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
            <tag> HTTP </tag>
            
            <tag> HTTPS </tag>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack打包CSS</title>
      <link href="2021/02/23/Webpack%E6%89%93%E5%8C%85css/"/>
      <url>2021/02/23/Webpack%E6%89%93%E5%8C%85css/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>此篇接<a href="/2021/02/06/Webpack%E6%89%93%E5%8C%85ts/">Webpack打包ts</a></p><h1 id="Webpack打包css"><a href="#Webpack打包css" class="headerlink" title="Webpack打包css"></a>Webpack打包css</h1><h2 id="安装less的依赖"><a href="#安装less的依赖" class="headerlink" title="安装less的依赖"></a>安装less的依赖</h2><p>一共安装四个包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -D less less-loader css-loader style-loader</span><br></pre></td></tr></table></figure><h2 id="修改webpack配置来加载css"><a href="#修改webpack配置来加载css" class="headerlink" title="修改webpack配置来加载css"></a>修改webpack配置来加载css</h2><p>此处也要注意，先用的加载器放在最后</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 指定webpack打包时使用的模块</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 指定加载规则</span></span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 指定ts规则</span></span><br><span class="line">      &#123;...</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 指定less/css规则</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">          <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">          <span class="string">&quot;less-loader&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="安装postcss兼容旧版本浏览器"><a href="#安装postcss兼容旧版本浏览器" class="headerlink" title="安装postcss兼容旧版本浏览器"></a>安装postcss兼容旧版本浏览器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -D postcss postcss-loader postcss-preset-env</span><br></pre></td></tr></table></figure><p>再次修改webpack配置，加入postcss配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定less/css规则</span></span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">      <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">      <span class="comment">// 引入postcss</span></span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          postcssOptions: &#123;</span><br><span class="line">            plugins: [</span><br><span class="line">              [</span><br><span class="line">                <span class="string">&quot;postcss-preset-env&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                  browsers: <span class="string">&#x27;last 2 versions&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;less-loader&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack打包TypeScript</title>
      <link href="2021/02/06/Webpack%E6%89%93%E5%8C%85ts/"/>
      <url>2021/02/06/Webpack%E6%89%93%E5%8C%85ts/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Webpack打包Typescript"><a href="#Webpack打包Typescript" class="headerlink" title="Webpack打包Typescript"></a><code>Webpack</code>打包<code>Typescript</code></h1><h2 id="新建npm包管理文件"><a href="#新建npm包管理文件" class="headerlink" title="新建npm包管理文件"></a>新建<code>npm</code>包管理文件</h2><p>首先在项目根目录中使用<code>npm init -y</code>命令，新建<code>package.json</code>文件（<code>-y</code>表示默认）</p><h2 id="使用npm命令安装包"><a href="#使用npm命令安装包" class="headerlink" title="使用npm命令安装包"></a>使用<code>npm</code>命令安装包</h2><p>使用以下命令进行安装，分别是<code>webpack</code>核心代码，命令行工具，<code>typescript</code>核心代码和<code>ts加载器</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -D webpack webpack-cli typescript ts-loader</span><br></pre></td></tr></table></figure><p>得到如下的<code>package.json</code>文件</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;03_webpack&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;html-webpack-plugin&quot;</span>: <span class="string">&quot;^5.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ts-loader&quot;</span>: <span class="string">&quot;^8.0.17&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;typescript&quot;</span>: <span class="string">&quot;^4.1.5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span>: <span class="string">&quot;^5.24.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-cli&quot;</span>: <span class="string">&quot;^4.5.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写webpack配置文件"><a href="#编写webpack配置文件" class="headerlink" title="编写webpack配置文件"></a>编写<code>webpack</code>配置文件</h2><p>根目录新建<code>webpack.config.js</code>，写入如下内容：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入一个包</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack中的所有的配置信息都应该卸载module.exports中</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 指定入口文件</span></span><br><span class="line">  entry: <span class="string">&#x27;./src/index.ts&#x27;</span>,</span><br><span class="line">  <span class="comment">// 指定打包文件所在的目录</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 指定打包后的目录</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="comment">// 打包后文件的名字</span></span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 指定webpack打包时使用的模块</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 指定加载规则</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// test指定规则生效的文件</span></span><br><span class="line">        <span class="comment">// 用ts-loader处理以ts结尾的文件</span></span><br><span class="line">        test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">        <span class="comment">// 指定要排除的文件(夹)</span></span><br><span class="line">        exclude: <span class="regexp">/node_moudles/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>package.json</code>文件中新加入一条<code>build</code>命令来进行打包</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="使用npm命令打包"><a href="#使用npm命令打包" class="headerlink" title="使用npm命令打包"></a>使用<code>npm</code>命令打包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>根目录下出现<code>dist/bundle.js</code>，打包成功</p><h2 id="自动生成html文件"><a href="#自动生成html文件" class="headerlink" title="自动生成html文件"></a>自动生成<code>html</code>文件</h2><p>安装<code>html-webpack-plugin</code>来自动生成<code>html</code>文件，而不用自己手动引入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -D html-webpack-plugin</span><br></pre></td></tr></table></figure><p>在<code>webpack.config.js</code>文件中新增如下配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 引入html插件</span></span><br><span class="line"><span class="keyword">const</span> HTMLWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="comment">// webpack中的所有的配置信息都应该卸载module.exports中</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 指定入口文件</span></span><br><span class="line">  entry: <span class="string">&#x27;./src/index.ts&#x27;</span>,</span><br><span class="line">  <span class="comment">// 指定打包文件所在的目录</span></span><br><span class="line">  output: &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 指定webpack打包时使用的模块</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 配置webpack插件</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HTMLWebpackPlugin(),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完成后，再次执行<code>npm run build</code>，<code>dist</code>目录下生成了<code>index.html</code>文件</p><h2 id="自定义生成的html文件"><a href="#自定义生成的html文件" class="headerlink" title="自定义生成的html文件"></a>自定义生成的<code>html</code>文件</h2><p>在<code>webpack.config.js</code>文件的<code>plugins</code>配置中修改配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 配置webpack插件</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HTMLWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">&#x27;这是一个自定义的title&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完成后，再次执行<code>npm run build</code>，查看生成的<code>index.html</code>文件，<code>title</code>成功修改为自定义</p><h2 id="webpack定义网页模版"><a href="#webpack定义网页模版" class="headerlink" title="webpack定义网页模版"></a><code>webpack</code>定义网页模版</h2><p>在<code>webpack.config.js</code>文件的<code>plugins</code>配置中修改配置，新增<code>template</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 配置webpack插件</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HTMLWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// title: &#x27;这是一个自定义的title&#x27;</span></span><br><span class="line">      template: <span class="string">&#x27;src/index.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，在<code>src</code>目录下新建<code>index.html</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>这是一个网页模版<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>我是box1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再次构建，查看<code>dist</code>目录下的<code>index.html</code>，成功生成模版</p><h2 id="Webpack开发服务器"><a href="#Webpack开发服务器" class="headerlink" title="Webpack开发服务器"></a><code>Webpack</code>开发服务器</h2><p>使用如下命令安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -D webpack-dev-server</span><br></pre></td></tr></table></figure><p>在<code>package.json</code>文件下增加命令</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">  &quot;start&quot;: &quot;webpack serve --open &#x27;google chrome&#x27;&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>此处是<code>Mac</code>电脑的配置命令，Windows写成<code>webpack serve --open chrome.exe</code>即可</p><p>使用<code>npm start</code>，启动了webpack内置服务器，显示出了<code>index.html</code></p><h2 id="清空dist目录的插件"><a href="#清空dist目录的插件" class="headerlink" title="清空dist目录的插件"></a>清空<code>dist</code>目录的插件</h2><p>清空<code>dist</code>目录的插件，确保当前是最新的文件</p><p>使用如下命令安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -D clean-webpack-plugin</span><br></pre></td></tr></table></figure><p>修改<code>webpack.config.js</code>文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line"><span class="comment">// 引入clean插件</span></span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 配置webpack插件</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HTMLWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// title: &#x27;这是一个自定义的title&#x27;</span></span><br><span class="line">      template: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack配置ts模块化引入"><a href="#webpack配置ts模块化引入" class="headerlink" title="webpack配置ts模块化引入"></a>webpack配置ts模块化引入</h2><p>默认情况下不支持ts的模块化引入，需要在<code>webpack.config.js</code>文件中修改如下配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack中的所有的配置信息都应该卸载module.exports中</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 用来设置引用模块</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="babel转译ts支持老版本浏览器"><a href="#babel转译ts支持老版本浏览器" class="headerlink" title="babel转译ts支持老版本浏览器"></a><code>babel</code>转译<code>ts</code>支持老版本浏览器</h1><h2 id="安装babel的依赖包"><a href="#安装babel的依赖包" class="headerlink" title="安装babel的依赖包"></a>安装<code>babel</code>的依赖包</h2><p>使用如下命令进行安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -D @babel/core @babel/preset-env babel-loader core-js</span><br></pre></td></tr></table></figure><h2 id="修改webpack-config-js"><a href="#修改webpack-config-js" class="headerlink" title="修改webpack.config.js"></a>修改<code>webpack.config.js</code></h2><p><strong>要注意的是，<code>use</code>中的加载器，执行顺序是从后往前的，最先执行的加载器应该写在最后</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 指定webpack打包时使用的模块</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 指定加载规则</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// test指定规则生效的文件</span></span><br><span class="line">        <span class="comment">// 用ts-loader处理以ts结尾的文件</span></span><br><span class="line">        test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// 配置babel</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 指定加载器</span></span><br><span class="line">            loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">            <span class="comment">// 设置babel</span></span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// 设置预置环境(在哪些浏览器中运行)</span></span><br><span class="line">              presets: [</span><br><span class="line">                [</span><br><span class="line">                  <span class="comment">// 指定环境插件</span></span><br><span class="line">                  <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">                  <span class="comment">// 配置信息</span></span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="comment">// 要兼容的目标浏览器</span></span><br><span class="line">                    targets: &#123;</span><br><span class="line">                      <span class="string">&quot;ie&quot;</span>: <span class="string">&#x27;11&#x27;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">// 指定corejs的版本</span></span><br><span class="line">                    <span class="string">&quot;corejs&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">                    <span class="comment">// 使用corejs的方式(&quot;usage&quot;表示按需加载)</span></span><br><span class="line">                    <span class="string">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&#x27;ts-loader&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时执行<code>npm run build</code>在<code>IE11</code>中运行发现还是报错了，原因是最外层使用了箭头函数，需要在<code>webpack.config.js</code>中禁止使用箭头函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 指定入口文件</span></span><br><span class="line">  entry: <span class="string">&#x27;./src/index.ts&#x27;</span>,</span><br><span class="line">  <span class="comment">// 指定打包文件所在的目录</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 指定打包后的目录</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="comment">// 打包后文件的名字</span></span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 告诉webpack不使用箭头函数</span></span><br><span class="line">    environment: &#123;</span><br><span class="line">      arrowFunction: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux ssh 工作原理</title>
      <link href="2020/11/01/Linux-ssh/"/>
      <url>2020/11/01/Linux-ssh/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>参考：<a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">SSH原理与运用（一）：远程登录/作者：阮一峰</a></p></blockquote><h1 id="SSH基本用法"><a href="#SSH基本用法" class="headerlink" title="SSH基本用法"></a>SSH基本用法</h1><p>以用户名<code>user</code>登录远程主机<code>host</code>，则使用以下命令登录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh user@host</span><br></pre></td></tr></table></figure><p>如果本地用户名和远程用户名相同，可以省略username</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh host</span><br></pre></td></tr></table></figure><p>默认的ssh端口是22，如果要指定其他端口，使用<code>-p</code>参数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p 2222 user@host</span><br></pre></td></tr></table></figure><h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><h2 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h2><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。</p><p>公钥加密过程：</p><ol><li>远程主机收到用户的登录请求，把自己的公钥发给用户。</li><li>用户使用这个公钥，将登录密码加密后，发送回来。</li><li>远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</li></ol><p>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人<strong>截获了登录请求</strong>，然后<strong>冒充远程主机</strong>，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p><p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的<a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack">“中间人攻击”</a>（Man-in-the-middle attack）。</p><h1 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h1><h1 id="免密登录（公钥登录）"><a href="#免密登录（公钥登录）" class="headerlink" title="免密登录（公钥登录）"></a>免密登录（公钥登录）</h1><p>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。</p><p>所谓”公钥登录”，原理很简单，就是用户<strong>将自己的公钥储存在远程主机上</strong>。</p><ol><li>登录的时候，远程主机会向用户发送一段随机字符串，使用公钥加密</li><li>用户用自己的私钥解密后，再发回来。</li><li>远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</li></ol><p><a href="https://www.jianshu.com/p/33461b619d53">https://www.jianshu.com/p/33461b619d53</a></p>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理层——通信基础</title>
      <link href="2020/10/14/Computer-Network-Physical-Layer-Communication/"/>
      <url>2020/10/14/Computer-Network-Physical-Layer-Communication/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>物理层考虑的是怎样才能连接各台计算机的传输媒体上传输数据的比特流，而不是连接计算机的具体物理设备或具体传输媒体。</p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="数据、信号、码元"><a href="#数据、信号、码元" class="headerlink" title="数据、信号、码元"></a>数据、信号、码元</h2><p><strong>数据</strong>是指传松信息的实体。</p><p><strong>信号</strong>是指数据的电气或电磁表现，是数据在传输过程中的存在形式。</p><p>数据和信号都可以用<strong>模拟</strong>或<strong>数字</strong>来修饰</p><p><strong>模拟数据（信号）</strong>是连续变化的数据（或信号）</p><p><strong>数字数据（信号）</strong>是取值仅允许为<strong>有限个的几个离散数值</strong>的数据（或信号）</p><h3 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h3><ul><li>串行传输：一个一个比特按照时间顺序传输（经济考虑，远距离传输通常采用串行传输）</li><li>并行传输：多个比特通过多条信道同时传输</li></ul><p><strong>码元</strong>指一个固定时长的信号波形（数字脉冲）表示一个$k$进制数字，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为**$k$进制码元**，该时长称为 <strong>码元宽度</strong>。</p><p>1个码元可以携带多个比特的信息量。例如使用二进制编码时，只有两种不同的码元：0、1</p><h2 id="信源、信道、信宿"><a href="#信源、信道、信宿" class="headerlink" title="信源、信道、信宿"></a>信源、信道、信宿</h2><p><strong>信源</strong>是产生和发送数据的源头。</p><p><strong>信宿</strong>是接受数据的终点。</p><p>发送端信源发送的信息需要通过 <strong>变换器</strong>转换成适合于在信道上传输的信号，而通过信道传输到接收端的信号先由 <strong>反变换器</strong> 转换成原始信息，再发给信宿。</p><p><strong>信道</strong>与电路并不等同，信道是信号的传输媒介。一个信道可视为一条线路的逻辑部件，一般用来表示 <strong>向某个方向传送信息的介质</strong>，因此一条通信线路往往包含一条发送信道和一条接收信道。</p><p><strong>噪声源</strong>是信道上的噪声（对信号的干扰）及分散在通信系统其它各处的噪声的集中表示。</p><h3 id="基带信号和宽带信号"><a href="#基带信号和宽带信号" class="headerlink" title="基带信号和宽带信号"></a>基带信号和宽带信号</h3><p><strong>基带信号</strong>：将数字信号$1$和$0$直接用两种不同的电压表示，然后送到数字信道上传输；</p><p><strong>宽带信号</strong>：将基带信号进行<strong>调制</strong>后形成<strong>频分复用模拟信号</strong>，然后传送到模拟信道上传输。</p><h3 id="通信双方信息的交互方式"><a href="#通信双方信息的交互方式" class="headerlink" title="通信双方信息的交互方式"></a>通信双方信息的交互方式</h3><ol><li><strong>单工通信</strong>：只有一个方向的通信而没有反方向的交互，仅需要一条信道。例如：无线电广播、电视广播；</li><li><strong>半双工通信</strong>：通信双方都可以发送或接收信息，但不能同时发送和接收信息，此时需要两条信道；</li><li><strong>全双工通信</strong>：通信双方可以同时发送和接收信息，也需要两条信道。</li></ol><p><strong>信道的极限容量</strong>：信道的最高码元传输速率 或 信道的极限信息传输速率。</p><h2 id="速率、波特、带宽"><a href="#速率、波特、带宽" class="headerlink" title="速率、波特、带宽"></a>速率、波特、带宽</h2><p><strong>速率</strong>：也称数据率，指的是数据的传输速率，表示单位时间内传输的数据量。可以用码元传输速率和信息传输速率表示。</p><ol><li><p><strong>码元传输速率</strong>：又称码元速率、波形速率，表示<strong>单位时间内数字通信系统所传输的码元个数</strong>，单位是<strong>波特</strong>（Baud）</p><p> 1波特表示数字通信系统每秒传输1个码元。<strong>码元可以是多进制的</strong>，也可以是二进制的，但<strong>码元速率与进制数无关</strong>。</p></li><li><p><strong>信息传输速率</strong>：又称信息速率、比特率，表示单位时间内数字通信系统传输的<strong>二进制码元个数</strong>（即<strong>比特数</strong>）单位是<strong>比特/秒（b/s)</strong></p></li></ol><p>若一个码元携带$n$比特信息量，则$M$波特率的码元传输速率所对应的信息传输速率为$Mn$比特/秒</p><p><strong>带宽</strong>：原指信号具有的频带宽度，单位是赫兹（Hz）。在实际网络中，由于数据率是信道最重要的指标之一，而带宽和数据率存在数值上的互换关系，因此常用来表示网络的通信线路所能传输数据的能力。因此，带宽表示 <strong>单位时间内从网络中的某一点到另一点所能通过的“最高数据率”</strong>，单位为 <strong>b/s</strong></p><h1 id="奈奎斯特定理与香农定理"><a href="#奈奎斯特定理与香农定理" class="headerlink" title="奈奎斯特定理与香农定理"></a>奈奎斯特定理与香农定理</h1><h2 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h2><p>在理想低通（没有噪声、带宽有限）的信道中，<strong>极限码元传输为$2W$波特</strong>，其中**$W$是理想低通信道的带宽**，单位为Hz。</p><p>若$V$表示每个码元离散电平的数目（码元的离散电平的数目是指：<strong>有多少种不同的码元</strong>，比如有16种码元，则需要4位二进制位，因此数据传输率是码元传输率的4倍），则极限数据率为<br>$$<br>理想低通信道下的极限数据传输率=2Wlog_2{V}<br>$$<br>单位为（b/s)</p><h3 id="奈氏准则的结论"><a href="#奈氏准则的结论" class="headerlink" title="奈氏准则的结论"></a>奈氏准则的结论</h3><ol><li>任何信道中，<strong>码元传输速率是有上限的</strong>。若传输速率超过上限，就会出现严重的码间串扰问题，接收端不能完全正确识别码元。</li><li>信道的<strong>频带越宽</strong>（通过的信号高频分量越多），就可用更高的速率进行码元的有效传输。</li><li>未对信息传输速率给出限制，即<strong>未对一个码元可以对应多少个二进制位给出限制</strong>。</li></ol><h2 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h2><p>香农定理给出了带宽受限且有高斯白噪声的信道的极限数据传输率，当用此速率进行传输时，可以做到不产生误差。香农定理定义为<br>$$<br>信道的极限数据传输率=Wlog_2(1+S/N)<br>$$<br>（单位为b/s）</p><p><strong>$W$为信道的带宽</strong>，**$S$为信道所传输信号的平均功率<strong>，</strong>$N$为信道内部的高斯噪声功率<strong>。</strong>$S/N$为信噪比**，即信号的平均功率与噪声的平均功率之比，$信噪比=10log_{10}(S/N)$（单位为dB）。例如当$S/N=10$时，信噪比为10dB，而当$S/N=1000$时，信噪比为30dB。</p><h3 id="香农定理的结论"><a href="#香农定理的结论" class="headerlink" title="香农定理的结论"></a>香农定理的结论</h3><ol><li>信道的带宽或信道中的<strong>信噪比越大</strong>，<strong>信息的极限传输速率越高</strong>。</li><li>对一定的传输带宽和一定的信噪比，<strong>信息传输速率的上限是确定的</strong>。</li><li>只要信息的传输速率<strong>低于信道的极限传输速率</strong>，就能找到某种方法来实现<strong>无差错传输</strong>。</li><li>香农定理得出的是极限信息传输速率，实际信道能达到的传输速率比它低不少。</li></ol><p>若信道带宽$W$或信噪比$S/N$没有上限（理想情况），则信道的极限信息传输速率也没有上限。</p><blockquote><p>奈氏准则只考虑了带宽与极限码元传输速率的关系，而香农定理不仅考虑到了带宽，也考虑到了信噪比。</p><p>从另一个侧面表明，<strong>一个码元对应的二进制位数是有限的</strong>。</p></blockquote><h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><p>数据无聊是数字的还是模拟的，<strong>为了传输的目的，都必须转变成信号</strong>。</p><p>把数据变换为模拟信号的过程称为<strong>调制</strong></p><p>把数据变换为数字信号的过程称为<strong>编码</strong></p><p>信号是数据的具体表示形式，它和数据有一定的关系，但又和数据不同。</p><ul><li>数字数据可以通过数字发送器转换为数字信号传输，也可以通过调制器转换成模拟信号传输；</li><li>模拟数据可以通过PCM编码器转换成数字信号传输，也可以通过放大器调制器转换成模拟信号传输。</li></ul><h2 id="四种编码方式"><a href="#四种编码方式" class="headerlink" title="四种编码方式"></a>四种编码方式</h2><h3 id="1-数字数据编码为数字信号"><a href="#1-数字数据编码为数字信号" class="headerlink" title="1. 数字数据编码为数字信号"></a>1. 数字数据编码为数字信号</h3><p>用于<strong>基带传输</strong>，基本不改变数字数据信号频率的情况下，直接传输数字信号。</p><h4 id="常用编码方式"><a href="#常用编码方式" class="headerlink" title="常用编码方式"></a>常用编码方式</h4><ol><li><p>归零编码（RZ）</p><p> 高电平代表1、低电平代表0（或者相反），<strong>每个时钟周期的中间均跳变到低电平</strong>（归零），接收方根据该跳变调整本方的时钟基准，<strong>为传输双方提供了自同步机制</strong>。由于<strong>归零需要占用一部分带宽</strong>，因此传输效率受到了一定的影响。</p></li><li><p>非归零编码（NRZ）</p><p> 与RZ的区别是<strong>不用归零</strong>，<strong>一个周期可以全部用来传输数据</strong>。但NRZ无法传递时钟信号，<strong>双方难以同步</strong>，若想传输高速同步数据，则<strong>需要都带有时钟线</strong>。</p></li><li><p>反向归零编码（NRZI）</p><p> <strong>用信号翻转代表0、信号不变代表1。</strong>翻转的信号本身可以作为一种通知机制。这种编码方式集成了前两种编码的优点，既能传输时钟信号，又能尽量不损失系统带宽。<strong>USB 2.0</strong>通信的编码方式就是NRZI编码</p></li><li><p>曼彻斯特编码（Manchester Encoding）</p><p> 将一个码元分成<strong>两个相等的间隔</strong>，前一个间隔为高电平而后一个间隔为低电平表示码元1；码元0的表示方法正好相反。也可以采用相反的规则。该编码的特点是：每个码元的中间出现电平跳变，位中间的跳变既作为时钟信号（可用于同步），又作为数据信号但它所占的频带宽度是原始系带宽度的两倍。</p><p> 以太网使用的编码方式就是曼彻斯特编码。</p></li><li><p>差分曼彻斯特编码</p><p> 常用于局域网传输，其规则为：若码元为1，则<strong>前半个码元的电平与上一个码元的后半个码元相同</strong>；若码元为0，则情形相反。该编码的特点是，在每个码元的<strong>中间都有一次电平的跳转</strong>，可以实现自同步，且抗干扰性较好。</p></li></ol><h3 id="2-数字数据调制为模拟信号"><a href="#2-数字数据调制为模拟信号" class="headerlink" title="2. 数字数据调制为模拟信号"></a>2. 数字数据调制为模拟信号</h3><p>在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应调制解调器的调制和解调过程。</p><h4 id="基本调制方式"><a href="#基本调制方式" class="headerlink" title="基本调制方式"></a>基本调制方式</h4><ol><li><p>幅移键控（ASK）</p><p> 通过<strong>改变载波信号的振幅</strong>来表示数字信号1和0，而载波的<strong>频率和相位都不变</strong>。比较容易实现，但抗干扰能力差。</p></li><li><p>频移键控（FSK）</p><p> 通过<strong>改变载波信号的频率</strong>来表示数字信号1和0，而载波的<strong>振幅和相位都不变</strong>。容易实现，抗干扰能力强，目前应用较为广泛。</p></li><li><p>相移键控（PSK）</p><p> 通过<strong>改变载波信号的相位</strong>来表示数字信号1和0，而载波的<strong>振幅和频率都不变</strong>。又分为绝对调相和相对调相。</p></li><li><p>正交振幅调制（QAM）</p><p> 在频率相同的前提下，将ASK和PSK结合起来，形成叠加信号。</p><p> 设波特率为$B$，采用$M$个相位，每个相位有$n$种振幅，则该QAM技术的数据传输率$R$为：<br> $$<br> R=Blog_2{(mn)}<br> $$<br> 单位为：$b/s$</p></li></ol><h3 id="3-模拟数据编码为数字信号"><a href="#3-模拟数据编码为数字信号" class="headerlink" title="3. 模拟数据编码为数字信号"></a>3. 模拟数据编码为数字信号</h3><p>对音频信号进行编码的<strong>脉码调制</strong>（PCM），主要包括三个步骤：采样、量化、编码。</p><p><strong>采样定理</strong>：将模拟信号转换为数字信号时，假设原信号中的最大频率为$f$，那么采样频率$f_{采样}$必须大于等于$f$的两倍，才能保证采样后的数字信号完整保留原始模拟信号的信息。又称<strong>奈奎斯特定理</strong>。</p><h3 id="4-模拟数据调制为模拟信号"><a href="#4-模拟数据调制为模拟信号" class="headerlink" title="4. 模拟数据调制为模拟信号"></a>4. 模拟数据调制为模拟信号</h3><p>使用频分复用（FDM)</p><h1 id="电路交换、报文交换、分组交换"><a href="#电路交换、报文交换、分组交换" class="headerlink" title="电路交换、报文交换、分组交换"></a>电路交换、报文交换、分组交换</h1><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>在进行数据传输前，两个结点之间必须先建立一条专用（双方独占）的物理通信路径（由通信双方之间的交换设备和链路逐段连接而成），该路径可能经过许多中间结点。这一路径在整个数据传输期间一直被独占，直到通信结束后才释放。</p><p>因此电路交换分为三个阶段：连接建立、数据传输、连接释放。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>通信时延小：数据直达，传输数据的时延非常小；</li><li>有序传输：按发送顺序传输数据；</li><li>没有冲突：不会出现争用物理信道的问题；</li><li>适用范围广：可传输模拟信号、数字信号；</li><li>实时性强：物理通路一旦建立，双方就可以随时通信；</li><li>控制简单：电路交换的交换设备（交换机）及控制均较简单。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>建立连接时间长：平均连接建立时间长；</li><li>线路独占：使用效率低；</li><li>灵活性差：只要在通信双方建立的通路中的任何一点出了故障，就必须重新拨号建立新连接；</li><li>难以规格化：不同类型、不同规格、不同速率的终端难以相互通信，难以进行差错控制。</li></ol><h2 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h2><p>数据交换的单位是<strong>报文</strong>，报文携带有<strong>目标地址、源地址</strong>等信息。报文交换在交换结点采用的是<strong>存储-转发</strong>的传输方式</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol><li>无需建立连接：不需要为通信双方预先建立一条专用的通信线路，不存在建立连接时延。</li><li>动态分配线路：交换设备先存储整个报文，然后选择一条合适的空闲线路发送。</li><li>提高线路可靠性：某条传输路径发生故障，可以重新选择另一条路径传输数据。</li><li>提高线路利用率：通信双方不是固定占用一条通信线路，而是在不同的时间一段一段地部分占用这条物理通信通道。</li><li>提高多目标服务：一个报文可以同时发送给多个目的地址。</li></ol><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>数据进入交换结点后要经历存储、转发这一过程，因此会<strong>引发转发时延</strong>（包括接收报文、检验正确性、排队、发送时间等）</li><li>报文交换对报文的大小没有限制，这就<strong>要求网络结点需要有较大的缓存空间</strong>。</li></ol><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>也采用<strong>存储-转发</strong>方式，但限制每次传送的数据块大小的上限，把大的数据块划分为合理的小数据块，再加上一些必要的控制信息（源地址、目的地址、编号信息），构成分组（Packet）</p><p>网络结点根据控制信息把分组送到下一结点，下一结点接收到分组后，暂时保存并排队等待传输，然后根据分组控制信息选择它的下一个结点，直到到达目的结点。</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ol><li>无建立时延：不需要事先建立专用通信线路，不存在连接建立时延</li><li>线路利用率高</li><li>简化了存储管理：分组的长度固定，相应的缓冲区大小固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理</li><li>加速传输：可是后一个分组和前一个分组转发操作并行，流水线方式减少了报文传输时间。传输一个分组所需的缓冲区比传输一次报文所需的缓冲区小得多，就不用因缓冲区不足而等待发送。</li><li>减少了出错概率和重发数据量：分组较短，出错概率较小，每次重发的数据量大大减少，提高了可靠性，减少了传输时延。</li></ol><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ol><li><p>存在传输时延</p></li><li><p>需要传输额外信息：每个小数据块都要加上源地址、目的地址和分组编号等信息，从而构成分组，因此使得传送的信息量增大了5%~10%</p></li><li><p>当分组交换采用数据报服务时，可能会出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号排序；</p><p> 若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。</p></li></ol><h1 id="数据报和虚电路"><a href="#数据报和虚电路" class="headerlink" title="数据报和虚电路"></a>数据报和虚电路</h1><p>分组交换根据其<strong>通信子网向端点系统提供的服务</strong>，还可进一步分为<strong>面向连接的虚电路方式</strong>和<strong>无连接的数据报方式</strong>。这两种服务方式都由<strong>网络层</strong>提供。</p><h2 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a>数据报</h2><p>在端系统中实现的高层协议先把报文拆成若干带有序号的数据单元，并在网络层加上地址等控制信息后形成数据报分组（即网络层PDU）中间结点存储分组很短一段时间，找到最佳的路由后，尽快转发每个分组。每个分组可以走不同的路径，也可以按不同的顺序到达目的结点。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p>发送分组不需要建立连接。</p></li><li><p>网络<strong>尽最大努力交付</strong>，不保证传输可靠性，有可能丢失；每个分组<strong>独立地选择路由</strong>，转发路径可能不同，因而分组不一定按照顺序到达目的结点。</p></li><li><p>发送的分组中要包括<strong>发送端和接收端的完整地址</strong>，以便可以自由传输。</p></li><li><p>存储转发会带来排队时延。</p></li><li><p>网络具有冗余路径，当某一交换结点或一段链路出现故障时，可以寻找另一条路径转发分组，对故障适应能力强</p></li></ol><h2 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h2><p>虚电路试图将<strong>数据报方式与电路交换方式结合</strong>。分组发送前，要求在发送方和接收方建立一条逻辑上相连的虚电路，并且连接一旦建立，就固定了虚电路所对应的物理路径。与电路交换类似，整个通信过程分为三个阶段：虚电路建立、数据传输与虚电路释放。</p><p>在虚电路方式中，端系统每次建立虚电路时，选择一个未使用过的虚电路号分配给该虚电路，以区别本系统中的其他虚电路。传输数据时，每个数据分组要有<strong>分组号、校验和控制信息、虚电路号</strong>，以区别其他虚电路上的分组。</p><p>虚电路网络中的每个借点还要维护一张<strong>虚电路表</strong>，表中的每项记录了一个打开的虚电路的信息，包括在接收链路和发送链路上的虚电路号、前一结点和后一结点的标识。数据的传输是双向进行的，上述信息是在虚电路建立过程中确定的。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li><p>虚电路通信链路建立和拆除需要时间开销，对交互式和小量的短分组情况浪费，对长时间、频繁的数据交换效率较高</p></li><li><p>虚电路路由选择体现在连接建立阶段，连接建立后就确定了传输路径</p></li><li><p>提供了可靠的通信功能，保证每个分组正确、有序到达。还可以对两个数据端点进行流量控制。</p></li><li><p>虚电路有一个致命的弱点，即当网络中某个结点或某条链路出现故障而彻底失效时，所有经过该结点或该链路的虚电路将遭到破坏。</p></li><li><p>分组首部不包含目的地址，而包含虚电路标识符，相对数据报方式开销较小。</p></li></ol><blockquote><p>虚电路之所以是“虚”的，是因为这条电路不是专用的，每个结点到其他结点之间的链路可能同时有若干虚电路通过，也可能同时与多个结点之间建立虚电路。每条虚电路支持特定的两个端系统之间的数据传输，两个端系统之间也可以有多条虚电路为不同的进程服务，这些虚电路的实际路由可能相同也可能不同。</p></blockquote><h2 id="数据报服务和虚电路服务的比较"><a href="#数据报服务和虚电路服务的比较" class="headerlink" title="数据报服务和虚电路服务的比较"></a>数据报服务和虚电路服务的比较</h2><table><thead><tr><th align="center"></th><th align="center">数据报服务</th><th align="center">虚电路服务</th></tr></thead><tbody><tr><td align="center">连接的建立</td><td align="center">不需要</td><td align="center">必须有</td></tr><tr><td align="center">目的地址</td><td align="center">每个分组都有完整的目的地址</td><td align="center">仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号</td></tr><tr><td align="center">路由选择</td><td align="center">每个分组独立进行路由选择和转发</td><td align="center">属于同一条虚电路的分组按照同一路由转发</td></tr><tr><td align="center">分组顺序</td><td align="center">不保证分组的有序到达</td><td align="center">保证分组的有序到达</td></tr><tr><td align="center">可靠性</td><td align="center">不保证可靠通信，可靠性由用户主机来保证</td><td align="center">可靠性由网络保证</td></tr><tr><td align="center">对网络故障的适应性</td><td align="center">出故障的结点丢失分组，其他分组路径选择发生变化时可以正常传输</td><td align="center">所有经过故障结点的虚电路均不能正常工作</td></tr><tr><td align="center">差错处理和流量控制</td><td align="center">由用户主机进行流量控制，不保证数据报的可靠性</td><td align="center">可由分组交换网负责，也可由用户主机负责</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISO/OSI参考模型和TCP/IP模型</title>
      <link href="2020/10/06/Computer-Network-OSI-TCP/"/>
      <url>2020/10/06/Computer-Network-OSI-TCP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h1><p>全称为：<strong>开发系统互连参考模型（OSI/RM)</strong></p><p>简称为：<strong>OSI参考模型</strong></p><p>自下而上依次分别为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><ul><li><p>低三层统称为：<strong>通信子网</strong>，它是为了联网而附近的通信设备，完成<strong>数据的传输</strong>功能；</p></li><li><p>高三层统称为：<strong>资源子网</strong>，它相当于计算机系统，完成<strong>数据的处理</strong>等功能。</p></li><li><p>传输层<strong>承上启下</strong>。</p></li></ul><h2 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h2><p>传输单位是<strong>比特</strong>，任务是透明的传输比特流，功能是在物理媒体上为数据端设备<strong>透明地传输原始比特流</strong>。</p><p>物理层接口标准很多，如果<code>EIA-232C</code>、<code>EIA/TIA RS-449</code>、<code>CCITT的X.21</code></p><p>物理层规定了电路接口的一些参数，如机械形状和尺寸、交换电路的数量和排列等。例如笔记本电脑上的网线接口。</p><p>物理层也规定了通信链路上传输的信号的意义和电气特征。</p><h2 id="数据链路层（Data-Link-Layer）"><a href="#数据链路层（Data-Link-Layer）" class="headerlink" title="数据链路层（Data Link Layer）"></a>数据链路层（Data Link Layer）</h2><p>传输单位是<strong>帧</strong>，任务是将网络层传来的<code>IP</code>数据报组装成帧。数据链路层功能可以概括为：<strong>成帧、差错控制、流量控制、传输管理</strong>。</p><ul><li><strong>差错控制</strong>：由于外界噪声的干扰，原始的物理连接在传输比特流时发生错误。如果两个结点之间规定了数据链路层协议，就可以检测出这些差错，将错误信号丢弃。</li><li><strong>流量控制</strong>：两个相邻结点传送数据时，由于两个结点性能不同，可能A导致发送数据的速率会比B接受速率快，如果不加以控制，结点B就会丢弃很多来不及接收的正确数据。流量控制可以协调两个结点的速率。</li></ul><h3 id="典型的数据链路层协议"><a href="#典型的数据链路层协议" class="headerlink" title="典型的数据链路层协议"></a>典型的数据链路层协议</h3><p><code>SDLC</code>，<code>HDLC</code>，<code>PPP</code>，<code>STP</code>和<code>帧中继</code></p><h2 id="网络层（Network-Layer）"><a href="#网络层（Network-Layer）" class="headerlink" title="网络层（Network Layer）"></a>网络层（Network Layer）</h2><p>传输单位是<strong>数据报</strong>，它关心的是通信子网的运行控制，主要任务是把网络层的<strong>协议数据单元</strong>（分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行<strong>路由选择</strong>，并实现<strong>流量控制、拥塞控制、差错控制、网际互联</strong>等功能。</p><ul><li><p><strong>路由选择</strong>：有许多可以选择的路由，网络层通过相应的路由算法计算出一条合适的路径。</p></li><li><p><strong>拥塞控制</strong>：如果结点都处于来不及接收分组而要丢弃大量分组的情况，那么网络处于拥塞状态，使得网络中的两个结点无法正常通信。网络层要采取一定的措施来缓解这种拥塞，就是拥塞控制。</p></li></ul><blockquote><p>因特网是一个很大的互联网，它由大量异构网络通过路由器（Router）相互连接起来。因特网的主要网络层协议是无连接的网际协议（Internet Protocol，IP）和许多路由选择协议，因此因特网的网络层也称为<strong>网际层</strong>或 <strong>IP层</strong></p></blockquote><h3 id="网络层的协议"><a href="#网络层的协议" class="headerlink" title="网络层的协议"></a>网络层的协议</h3><p><code>IP</code>、<code>IPX</code>、<code>ICMP</code>、<code>IGMP</code>、<code>ARP</code>、<code>RARP</code>、<code>OSPF</code></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>也称运输层，传输单位是：<strong>报文段</strong>（TCP）或<strong>用户数据报</strong>（UDP）</p><p>传输层负责主机中两个<strong>进程之间的通信</strong>，功能是为<strong>端到端</strong>连接提供可靠的传输服务，为端到端连接提供<strong>流量控制、差错控制、服务质量、数据传输管理</strong>等服务。</p><blockquote><p><em>数据链路层提供点到点的通信，传输层负责端到端的通信</em>，点到点可以理解为一个硬件地址或IP地址，网络中参与通信的主机是通过硬件地址或IP地址标识的；端到端通信是指运行在不同主机内的两个进程之间的通信，一个进程由一个端口来标识，所以称端到端通信</p></blockquote><p>使用传输层的服务，高层用户可以直接进行端到端的数据传输，从而忽略通信子网的存在。通过传输层的屏蔽，高层用户看不到子网的交替和变化。</p><p><strong>复用</strong>：多个应用层进程可以同时使用下面传输层的服务。</p><p><strong>分用</strong>：传输层把收到的信息分别交付给上面应用层中相应的进程。</p><h3 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h3><p><code>TCP</code>、<code>UDP</code></p><h2 id="会话层（Session-Layer）"><a href="#会话层（Session-Layer）" class="headerlink" title="会话层（Session Layer）"></a>会话层（Session Layer）</h2><p>允许不同主机上的各个进程之间进行会话。</p><p>利用传输层的端到端的服务，向表示层提供它的增值服务。</p><p>这种服务主要为表示层实体或用户进程<strong>建立连接并在连接上有序地传输数据</strong>，这就是会话，也称建立同步（SYN）</p><p>会话层负责管理主机间的会话进程，包括建立、管理及终止进程间的会话。会话层可以使用<strong>校验点</strong>使通信会话在<strong>失效时从校验点继续恢复通信</strong>，实现数据同步。</p><h2 id="表示层（Presentation-Layer）"><a href="#表示层（Presentation-Layer）" class="headerlink" title="表示层（Presentation Layer）"></a>表示层（Presentation Layer）</h2><p>主要处理两个通信系统中交换信息的表示方式。</p><p><strong>不同机器采用的编码方式和表示方式不同，使用的数据结构也不同</strong>。</p><p>为了使不同表示方法的数据和信息之间能够相互交换，<strong>表示层采用抽象的标准方法定义数据结构</strong>，并采用标准的编码方式。</p><p><strong>数据压缩、加密和解密</strong>也是表示层可提供的数据表示变化功能。</p><h2 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h2><p>是OSI模型的最高层，是用户与网络的界面。应用层为特定类型的网络应用提供访问OSI环境的手段。因为用户实际应用多种多样。这要求 <strong>应用层采用不同的应用协议来解决不同类型的应用要求</strong>，因此应用层是最复杂的一层，使用的协议也最多。</p><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>文件传输协议<code>FTP</code>，电子邮件<code>SMTP</code>，万维网<code>HTTP</code></p><h1 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h1><p>ARPA在研究ARAPnet时，提出了<code>TCP/IP</code>模型，模型从低到高依次为：<strong>网络接口层</strong>（对应OSI的物理层和数据链路层）、<strong>网际层、传输层、应用层</strong>（对应OSI的会话层、表示层、应用层）。</p><h2 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h2><p>功能类似与OSI的物理层和数据链路层。</p><p>作用是从主机或结点<strong>接受IP分组</strong>，并把它们发送到指定的物理网络上。</p><h2 id="网际层"><a href="#网际层" class="headerlink" title="网际层"></a>网际层</h2><p><strong>网际层（主机-主机）</strong>是<code>TCP/IP</code>体系结构的关键部分。它和OSI网络层在功能上非常相似。网际层将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序地到达，各个分组的有序交付由高层复杂。</p><p>网际层定义了标准的分组格式和协议，即IP。当前采用的是IPv4，下一版本是IPv6</p><h2 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h2><p><strong>传输层（应用-应用或进程-进程）</strong>功能同样和OSI中的传输层类似，即使得发送端和目的端主机上的<strong>对等实体进行会话</strong>。主要使用的协议：</p><ul><li>传输控制协议（TCP）：面向连接的，数据传输的单位是报文段，能够提供可靠的交付。</li><li>用户数据报协议（UDP）：无连接的，数据传输的单位是用户数据报，不能保证可靠的交付，只能提供“尽最大努力交付”。</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><strong>应用层（用户-用户）包含所有的高层协议</strong>，如虚拟终端协议（Telnet）、文件传输协议（FTP）、域名解析服务（DNS）、电子邮件协议（SMTP）和超文本传输协议（HTTP）。</p><p>IP协议是因特网中的协议核心；TCP/IP可以为各式各样的应用提供服务（everything over IP），同时TCP/IP也允许IP协议在各种网络构成的互联网上运行（IP over everything）。</p><h1 id="TCP-IP和OSI的比较"><a href="#TCP-IP和OSI的比较" class="headerlink" title="TCP/IP和OSI的比较"></a>TCP/IP和OSI的比较</h1><h2 id="相似之处"><a href="#相似之处" class="headerlink" title="相似之处"></a>相似之处</h2><ul><li>两者都采取分层的体系结构，将庞大且复杂的问题划分为若干较容易处理的、范围较小的问题，分层的功能大体类似；</li><li>二者都是基于独立的协议栈的概念；</li><li>二者都可以解决异构网络的互联，实现世界上不同厂家生产的计算机之间的通信。</li></ul><h2 id="区别之处"><a href="#区别之处" class="headerlink" title="区别之处"></a>区别之处</h2><ul><li>OSI精确定义了三个主要概念：<strong>服务、协议、接口</strong>，与面向对象程序设计思想吻合；而TCP/IP模型在这个三个概念上没有明确区分。</li><li>OSI模型产生在协议发明之前，没有偏向于任何特点的协议；TCP/IP模型出现在协议之后，<strong>模型是对协议的描述</strong>。</li><li>TCP/IP模型设计之初就考虑到了多种<strong>异构网的互联问题</strong>，并将网际协议（IP）作为一个单独的重要层次。而OSI最初只考虑到用一种标准的公用数据网将各种不同的系统互联。</li><li>OSI模型在<strong>网络层</strong>支持无连接和面向连接的通信，但在<strong>传输层仅有面向连接的通信</strong>；而TCP/IP模型认为可靠性是端到端的问题，因此它在<strong>网际层</strong>仅有一种无连接的通信模式，但在<strong>传输层支持无连接和面向连接</strong>的模式。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/OSI&TCP.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络体系结构</title>
      <link href="2020/10/06/Computer-Network-Architecture/"/>
      <url>2020/10/06/Computer-Network-Architecture/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h1><p>把 <strong>计算机网络的各层及其协议的集合</strong>称为网络的 <strong>体系结构（Architecture）</strong></p><p>它是计算机网络中的层次、各层的协议、及层间接口的集合。</p><h2 id="分层的基本原则"><a href="#分层的基本原则" class="headerlink" title="分层的基本原则"></a>分层的基本原则</h2><p>计算机网络体系结构具有可分层的特性，分层的基本原则为：</p><ul><li>每层都实现一种相对独立的功能，降低大系统的复杂度；</li><li>各层直接的界面自然清晰，易于理解，相互交流尽可能少；</li><li>各层功能的精确定义独立于具体实现的方法，可以采用最合适的技术来实现；</li><li>保持下层对上层的独立性，上层单向使用下层提供的服务。</li><li>整个分层结构应该能促进标准化工作。</li></ul><h2 id="分层名称"><a href="#分层名称" class="headerlink" title="分层名称"></a>分层名称</h2><p>在计算机网络的分层结构中，第n层中的活动元素通常称为<strong>n层实体</strong>。实体指任何可发送或接受信息的硬件或软件进程。</p><p>不同机器上的同一层称为<strong>对等层</strong></p><p>同一层的实体称为 <strong>对等实体</strong></p><p>n层实体实现的服务为n+1层使用，在这种情况下，n层被称为 <strong>服务提供者</strong>，n+1层则服务于用户。</p><h2 id="传输数据单位"><a href="#传输数据单位" class="headerlink" title="传输数据单位"></a>传输数据单位</h2><p>每一层自己传送的数据单位，其<strong>名称、大小、含义</strong>也各有不同。</p><p>在计算机网络体系结构的各个层次中，每个报文都分为两个部分：</p><p><code>数据部分SDU</code>：为完成用户所要求的功能而应传送的数据。</p><p><code>控制信息部分PCI</code>：控制协议操作的信息。</p><p>它们共同组成为<code>协议数据单元PDU</code>：对等层次之间传送的数据成为该层的PDU</p><p>在实际的网络中，每层的<code>协议数据单元PDU</code>都有一个通俗的名称，如：</p><ul><li>物理层PDU——比特</li><li>链路层PDU——帧</li><li>网络层PDU——分组</li><li>传输层PDU——报文</li></ul><h2 id="层次结构的含义"><a href="#层次结构的含义" class="headerlink" title="层次结构的含义"></a>层次结构的含义</h2><ol><li>第n层实体不仅要使用第n-1层的服务来实现自身定义的功能，还要向n+1层提供本层的服务，该服务是第n层及其下面各层提供的服务总和。</li><li>最低层只提供服务，是整个层次结构的基础；中间各层既是下一层的服务使用者，又是上一层的服务提供者；最高层面向用户提供服务。</li><li>上一层只能通过相邻层间的接口使用下一层的服务，而不能调用其他层的服务；下一层所提供服务的实现细节对上一层透明。</li><li>两台主机通信时，对等层在逻辑上有一条直接信道，表现为不经过下层就把信息传递到对方。</li></ol><h1 id="计算机网络协议、接口、服务的概念"><a href="#计算机网络协议、接口、服务的概念" class="headerlink" title="计算机网络协议、接口、服务的概念"></a>计算机网络协议、接口、服务的概念</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>协议就是规则的集合。</p><p>为进行网络中的数据交换而建立的规则、标准或约定称为<strong>网络协议</strong>（Network Protocol）</p><p>不对等实体之间时没有协议的。</p><p>协议由<code>语法</code>、<code>语义</code>和<code>同步</code>三部分组成</p><p><strong>语法</strong>：规定了数据的格式；</p><p><strong>语义</strong>：规定了要完成的功能，即需要发出何种控制信息、完成何种动作及做出何种应答；</p><p><strong>同步</strong>：规定了执行各种操作的条件、时序关系等，即事件实现顺序的详细说明。</p><p>一个完整的协议应该通常具有： 线路管理、差错控制、数据转换功能。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是同一结点内，相邻两层间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，<strong>不能跨层定义接口</strong>。</p><p>在典型的接口上，同一结点相邻两层的实体通过<code>服务访问点(Service Access Point，SAP)</code>进行交互。<strong>服务是通过SAP提供给上层使用的</strong>，第n层SAP就是第n+1层可以访问第n层服务的地方。</p><p>每个SAP都有一个能够标识它的地址。</p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>服务是指下层为紧邻的上层的提供的功能调用，它是垂直的。</p><p>对等实体在协议的控制下，使得本层能为上一层提供服务，但<strong>要实现本层协议还需要使用下一层所提供的服务</strong>。</p><p>上一层使用下层所提供的服务时，必须与下层交换一些命令，这些命令在OSI中称为 <strong>服务原语</strong>。</p><p>OSI将<strong>服务原语</strong>分为以下4类：</p><ol><li>请求（Request）：由服务用户发往服务提供者，请求完成某项工作；</li><li>指示（Indication）：由服务提供者发往服务用户，指示用户做某些事情；</li><li>响应（Response）：由服务用户发往服务提供者，作为对指示的响应；</li><li>证实（Confirmation）：由服务提供者发往服务用户，作为对请求的证实。</li></ol><p>这四类原语用于不同的功能，如建立连接、传输数据和断开连接等。有应答服务包括全部4类原语，而无应答服务则只有请求和指示两类原语。</p><p>计算机网络提供的服务可按照以下三种方式分类：</p><h3 id="面向连接服务与无连接服务"><a href="#面向连接服务与无连接服务" class="headerlink" title="面向连接服务与无连接服务"></a>面向连接服务与无连接服务</h3><p>在面向连接服务中，双方<strong>必须先建立连接</strong>，分配相应的资源（如缓冲区），以保证通信能正常进行，传输结束后释放所占用的资源。因此这种服务可以分为：<strong>连接建立</strong>、<strong>数据传输</strong>、<strong>连接释放</strong>三个阶段。例如<code>TCP</code>就是一种面向连接服务的协议。</p><p>在无连接服务中，通信双方不需要先建立连接，需要发送数据时<strong>可以直接发送</strong>，把每个带有目的地址的包（报文分组）传送到线路上，由系统选定路线进行传输。这是一种<strong>不可靠的服务</strong>。这种服务常被描述为 <strong>尽最大努力交付（Best-Effort-Delivery）</strong>，它并不保证通信的可靠性，例如<code>IP</code>、<code>UDP</code>就是一种无连接服务的协议。</p><h3 id="可靠服务和不可靠服务"><a href="#可靠服务和不可靠服务" class="headerlink" title="可靠服务和不可靠服务"></a>可靠服务和不可靠服务</h3><p>可靠服务指的是网络<strong>具有纠错、检错、应答机制</strong>，能保证数据正确、可靠地传送到目的地。</p><p>不可靠服务是指网络知识<strong>尽量正确，可靠地传送</strong>，而不能保证数据正确、可靠地传送到目的地，是一种<strong>尽力而为的服务</strong>。</p><p>对于提供不可靠服务的网络，其网络的<strong>正确性、可靠性要由应用或用户来保障</strong>。例如，收到信息之后要判断信息的正确性，如果不正确，用户要把出错信息报告给信息的发送者，以便发送者采取纠正措施。通过这些措施，可以把不可靠的服务变成可靠服务。</p><blockquote><p>在一层内完成的全部功能并非都称之为服务，只有那些能够被高一层实体“看得见”的功能才能成为服务</p></blockquote><h3 id="有应答服务和无应答服务"><a href="#有应答服务和无应答服务" class="headerlink" title="有应答服务和无应答服务"></a>有应答服务和无应答服务</h3><p>有应答服务是指接收方在<strong>收到数据后向发送方发出相应的应答</strong>，该<strong>应答由传输系统内部自动实现</strong>，而不由用户实现。所发送的应答可以是<strong>肯定应答</strong>，也可以是<strong>否定应答</strong>，通常在接受到的数据有错误时发送否定应答。例如，文件传输服务是一种有应答服务。</p><p>无应答服务是指接收方收到数据后，不自动给出应答。若需给出应答，则需要高层实现。例如<code>www</code>服务，客户端收到服务端发送的页面文件后不给出应答。</p>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客部署踩坑记录</title>
      <link href="2020/09/22/hexo-ssh-deploy/"/>
      <url>2020/09/22/hexo-ssh-deploy/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>每次在使用<code>hexo d</code></p><p>进行部署的时候，总是显示权限不够报错</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/hexo-deploy-access-error.png"></p><p>网上一查好像是说sshkey的时间过期了（MacOS)环境</p><p>使用如下命令即可解决：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh-3.2<span class="comment"># ssh-add /Users/lixing/.ssh/id_rsa</span></span><br><span class="line">Enter passphrase <span class="keyword">for</span> /Users/lixing/.ssh/id_rsa: </span><br><span class="line">Identity added: /Users/lixing/.ssh/id_rsa (lixing@zhulixingdeMacBook-Pro.local)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 踩坑记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习笔记——面向对象[原型链继承]</title>
      <link href="2020/08/25/JavaScript-Prototypelink/"/>
      <url>2020/08/25/JavaScript-Prototypelink/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>许多OO语言都支持两种继承方式：<strong>接口继承</strong>和<strong>实现继承</strong>。</p><p>接口继承只继承方法签名，而实现继承则继承实际的方法。</p><p>ECMAScript只支持实现继承，主要靠原型链。</p></blockquote><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>简单回顾构造函数、原型、实例的关系：</p><ul><li>每个构造函数都有一个原型对象<code>prototype</code>；</li><li>原型对象包含一个指向构造函数的指针<code>constructor</code>；</li><li>实例包含一个指向原型对象的内部指针<code>__proto__</code>；</li></ul><blockquote><p>现在，我们使原型对象等于另一个类型的实例。此时，原型对象将包含一个<strong>指向另一个原型的指针</strong>，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是原型链的基本概念。</p></blockquote><h2 id="实现原型链的基本模式"><a href="#实现原型链的基本模式" class="headerlink" title="实现原型链的基本模式"></a>实现原型链的基本模式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSubValue());<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());<span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码中<code>SubType</code>继承了<code>SuperType</code>，继承是通过创建<code>SuperType</code>的实例，并将该实例赋给<code>SubType.prototype</code>实现的。实现的本质是<strong>重写原型对象</strong>，代之以一个新类型的实例。</p><p>确立了继承关系后，我们给<code>SubType.prototype</code>添加了一个方法，这样就继承了<code>SuperType</code>的属性和方法的基础上又添加了一个新方法。</p><p>这个例子中的实例和构造函数和原型的关系如图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/prototype-link.001.jpeg"></p><h3 id="默认的原型"><a href="#默认的原型" class="headerlink" title="默认的原型"></a>默认的原型</h3><p>所有的引用类型都默认继承了<code>Object</code>，而这个继承也是通过原型链实现的。所有函数的默认原型都是<code>Object</code>的实例，因此默认原型都会包含一个内部指针<code>__proto__</code>指向<code>Object.prototype</code>。这也正是所有自定义类型都会继承<code>toString()</code>，<code>valueOf()</code>等默认方法的根本原因。</p><p>一句话：<code>SubType</code>继承了<code>SuperType</code>，而<code>SubType</code>继承了<code>Object</code>。当调用<code>instance.toString()</code>时，实际调用的是保存在<code>Object.prototype</code>中的方法。</p><h3 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h3><ul><li><p>使用<code>instanceof</code>操作符</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SuperType);<span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SubType);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>isPrototypeOf()</code></p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line">alert(SuperType.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line">alert(SubType.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="谨慎地定义方法"><a href="#谨慎地定义方法" class="headerlink" title="谨慎地定义方法"></a>谨慎地定义方法</h3><p>子类有时候需要覆盖父类的某个方法，或者需要添加父类中不存在的某个方法。但不管怎么样，给原型链添加方法的代码<strong>一定要放在替换原型的语句之后</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加了新方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写超类的方法</span></span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSubValue());<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());<span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>不能使用对象字面量创建原型方法</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用字面量添加新方法,会导致上一行代码无效</span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">    getSubValue: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">    &#125;,</span><br><span class="line">    someOtherMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());<span class="comment">//error!</span></span><br></pre></td></tr></table></figure><h2 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h2><h3 id="1-引用类型被所有实例共享"><a href="#1-引用类型被所有实例共享" class="headerlink" title="1. 引用类型被所有实例共享"></a>1. 引用类型被所有实例共享</h3><p>最主要的问题是：包含引用类型值的原型。</p><p><strong>包含引用类型值的属性会被所有实例共享</strong>；而这也正式为什么要在构造函数中，而不是在原型对象中定义属性的原因。</p><p>在使用原型来实现继承时，原型实际上会编程另一个类型的实例。于是，原先的实例属性也就顺理成章地编程了现在的原型属性了。</p><p>下列代码可以说明这个问题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">// [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">// [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span></span><br></pre></td></tr></table></figure><h3 id="2-创建子类不能向超类的构造函数中传递参数"><a href="#2-创建子类不能向超类的构造函数中传递参数" class="headerlink" title="2. 创建子类不能向超类的构造函数中传递参数"></a>2. 创建子类不能向超类的构造函数中传递参数</h3><p>没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。实际很少会单独使用原型链。</p><h1 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h1><p>通过使用<code>apply()</code>和<code>call()</code>方法可以在新创建的对象上执行构造函数。</p><p>在子类型的构造函数内部调用超类型构造函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//    继承了SuperType</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//[ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">//[ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span></span><br></pre></td></tr></table></figure><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数中传递参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//    继承了SuperType</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>, <span class="string">&quot;Nicolas&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.name);<span class="comment">//Nicolas</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age);<span class="comment">//18</span></span><br></pre></td></tr></table></figure><h2 id="借用构造函数的问题"><a href="#借用构造函数的问题" class="headerlink" title="借用构造函数的问题"></a>借用构造函数的问题</h2><p>方法都在构造函数中定义，因此函数复用就无从谈起了。而且在超类的原型中定义方法，子类型也不可见，结果所有类型都能使用构造函数模式。借用构造函数也很少单独使用。</p><h1 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h1><p>将原型链和借用构造函数的技术组合在一起，发挥二者之长的一种实现继承模式。</p><p>其背后的思路是：使用原型链实现对<strong>原型属性和方法的继承</strong>，而通过借用构造函数来实现对<strong>实例属性的继承</strong>。</p><p>这样，即通过在原型上定义方法实现了函数复用，又能保证每个实例都有它的属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>,<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line"><span class="comment">//    继承属性</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;Nicolas&quot;</span>,<span class="number">19</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//[ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span></span><br><span class="line">instance1.sayName();<span class="comment">//Nicolas</span></span><br><span class="line">instance1.sayAge();<span class="comment">//19</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;Greg&quot;</span>,<span class="number">17</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//[ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span></span><br><span class="line">instance2.sayName();<span class="comment">//Greg</span></span><br><span class="line">instance2.sayAge();<span class="comment">//17</span></span><br></pre></td></tr></table></figure><p>组合继承避免了原型链和借用构造函数的缺陷，融合了他们的优点，成为了<code>JavaScript</code>中最常用的继承模式，而且<code>instanceof</code>和<code>isPrototypeOf()</code>也能够用于识别基于组合继承创建的对象。</p><h1 id="其他可供选择的继承模式"><a href="#其他可供选择的继承模式" class="headerlink" title="其他可供选择的继承模式"></a>其他可供选择的继承模式</h1><p>（不展开）</p><ul><li>原型式继承<ul><li>可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还得进一步改造。</li></ul></li><li>寄生式继承<ul><li>与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类构造函数而导致的低效率问题，可以将这个模式和组合继承一起使用。</li></ul></li><li>寄生组合式继承<ul><li>集寄生式继承和组合继承的优点于一身，是实现基于类型继承的最有效方法。</li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《JavaScript高级程序设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习笔记——函数表达式[闭包]</title>
      <link href="2020/08/16/JavaScript-closure/"/>
      <url>2020/08/16/JavaScript-closure/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>闭包是指有权访问另一个函数作用域中的变量的函数。</p></blockquote><p>创建闭包的常见方式，是在一个函数内部创建另一个函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">        <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，3、4行代码时内部函数（一个匿名函数）中的代码，这两行代码访问了外部函数中的变量<code>propertyName</code>。即使这个内部函数被返回了，而且是在其他地方被调用了，它仍然可以访问变量<code>propertyName</code>。之所以还能访问那个变量，是因为内部函数的作用域链中包含<code>createComparisonFunction()</code>的作用域。</p><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>当某个函数被调用时，会创建一个执行环境（execution context)及相应的作用域链。然后，使用<code>arguments</code>和其他命名参数的值来初始化函数的活动对象（activation object)。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位…直到作为作用域链终点的全局执行环境。</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h2><p>在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如<code>f2</code>记住了它诞生的环境<code>f1</code>，所以从<code>f2</code>可以得到<code>f1</code>的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><p>闭包的最大用处有两个，一个是可以<strong>读取函数内部的变量</strong>，另一个就是让这些变量<strong>始终保持在内存中</strong>，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrementor</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> start++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inc = createIncrementor(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">inc() <span class="comment">// 5</span></span><br><span class="line">inc() <span class="comment">// 6</span></span><br><span class="line">inc() <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>start</code>是函数<code>createIncrementor</code>的内部变量。通过闭包，<code>start</code>的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包<code>inc</code>使得函数<code>createIncrementor</code>的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。</p><p>为什么会这样呢？原因就在于<code>inc</code>始终在内存中，而<code>inc</code>的存在依赖于<code>createIncrementor</code>，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。</p><h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>闭包的另一个用处，是封装对象的私有属性和私有方法。</p><p>任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量，私有变量包括函数的参数、局部变量、在函数内部定义的其他函数。</p><p>如果在函数内部创建一个闭包，那么可以通过闭包自己的作用域链访问这些变量。利用这一点可以创建用于访问私有变量的公有方法。</p><h1 id="闭包的性能问题"><a href="#闭包的性能问题" class="headerlink" title="闭包的性能问题"></a>闭包的性能问题</h1><p>外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://wangdoc.com/javascript/types/function.html#%E9%97%AD%E5%8C%85">https://wangdoc.com/javascript/types/function.html#闭包</a></li><li>《JavaScript高级程序设计》</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS盒子模型II</title>
      <link href="2020/08/13/CSS-Box-Model-II/"/>
      <url>2020/08/13/CSS-Box-Model-II/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="外边距、内边距、边框"><a href="#外边距、内边距、边框" class="headerlink" title="外边距、内边距、边框"></a>外边距、内边距、边框</h1><h2 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h2><p>外边距是盒子周围一圈看不到的空间，它会把其他元素从盒子旁边<strong>推开</strong>。</p><p>其值可正可负，设置负值会导致与其他内容重叠。</p><p>无论使用标准模型还是替代模型，外边距总是在计算可见部分后额外添加。</p><h3 id="外边距折叠"><a href="#外边距折叠" class="headerlink" title="外边距折叠"></a>外边距折叠</h3><p>有两个外边距相接的元素，这些外边距将合并为一个外边距，即<strong>最大的单个外边距的大小</strong>。</p><p>例如有两个<code>&lt;p&gt;</code>元素，他们上下相接</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span>I am paragraph one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span>I am paragraph two.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置其CSS属性为：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>随意修改<code>.two</code>中的<code>margin-top</code>属性为$≤50px$的值，会发现他们之间的间距不变。</p><h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><p>边框是在边距和填充框之间绘制的。</p><p>如果使用的是标准盒模型，边框的大小将添加到框的宽度和高度。</p><p>如果使用的是替代盒模型，边框的大小会使内容框更小，因为它会占用一些课用的宽度和高度。</p><p>可分别设置各边的宽度、颜色和样式：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top"><code>border-top</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right"><code>border-right</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left"><code>border-left</code></a></li></ul><p>设置所有边的宽度、颜色和样式：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style"><code>border-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-color"><code>border-color</code></a></li></ul><p>以及粒度最细的属性：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-width"><code>border-top-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-style"><code>border-top-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-color"><code>border-top-color</code></a></li><li>…</li></ul><h2 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h2><p>内边距位于边框和内容区域之间。</p><p>与外边距不同，不能有负数量的内边距，所以值必须是0或正的值。</p><p>应用于元素的任何背景都将显示在内边距后面，内边距通常用于将内容推离边框。</p><h1 id="盒子模型与内联盒子"><a href="#盒子模型与内联盒子" class="headerlink" title="盒子模型与内联盒子"></a>盒子模型与内联盒子</h1><p>以上所有的方法都完全适用于块级盒子。有些属性也可以应用于内联盒子，例如由<code>&lt;span&gt;</code>元素创建的那些内联盒子。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    I am a paragraph and this is a <span class="tag">&lt;<span class="name">span</span>&gt;</span>span<span class="tag">&lt;/<span class="name">span</span>&gt;</span> inside that paragraph. A span is an inline element and so does not respect width and height.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span>     </span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid blue;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>在一个段落中使用了<code>&lt;span&gt;</code>，并对其应用了宽度、高度、边距、边框和内边距。可以看到，宽度和高度被忽略了。外边距、内边距和边框是生效的，但它们不会改变其他内容与内联盒子的关系，因此内边距和边框会与段落中的其他单词重叠。</p><h2 id="使用display-inline-block"><a href="#使用display-inline-block" class="headerlink" title="使用display:inline-block"></a>使用<code>display:inline-block</code></h2><p>在这种情况下非常有用：不希望一个项切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠。</p><p>一个元素使用<code>display: inline-block</code>，实现我们需要的块级的部分效果：</p><ul><li>设置<code>width</code> 和<code>height</code> 属性会生效。</li><li><code>padding</code>, <code>margin</code>, 以及<code>border</code> 会推开其他元素。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid blue;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>可以通过增加内边距来增加链接的命中区域。使用<code>display: inline-block</code>来设置内边距，让用户更容易点击链接。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;links-list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Link one<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Link two<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Link three<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span>    </span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.links-list</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">179</span>,<span class="number">57</span>,<span class="number">81</span>);</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span> <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.links-list</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">66</span>, <span class="number">28</span>, <span class="number">40</span>);</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-值与单位</title>
      <link href="2020/08/13/CSS-Number-Length-Percentage/"/>
      <url>2020/08/13/CSS-Number-Length-Percentage/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="数字、长度、百分比"><a href="#数字、长度、百分比" class="headerlink" title="数字、长度、百分比"></a>数字、长度、百分比</h1><h2 id="数值类"><a href="#数值类" class="headerlink" title="数值类"></a>数值类</h2><p>以下全部归类为<strong>数值</strong>类：</p><table><thead><tr><th>数值类型</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;integer&gt;</code></td><td>一个整数，比如1024，-55</td></tr><tr><td><code>&lt;number&gt;</code></td><td>表示一个小数——可能有小数点后面的部分，也可能没有，例如0.255、128、-1.2</td></tr><tr><td><code>&lt;dimension&gt;</code></td><td>是一个带附加单位的小数，例如45deg、5s、10px。<code>&lt;dimension&gt;</code>是一个伞形类别，包括<code>&lt;length&gt;</code>、<code>&lt;angle&gt;</code>、<code>&lt;time&gt;</code>和<code>&lt;resolution&gt;</code>类型。</td></tr><tr><td><code>&lt;percentage&gt;</code></td><td>表示一些其他值的一部分，例如50%。百分比值总是相对于另一个量，例如，一个元素的长度相对于其父元素的长度。</td></tr></tbody></table><h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><p>最常见的数字类型是<code>&lt;length&gt;</code>，例如10px(像素)或30em。CSS中有两种类型的长度——相对长度和绝对长度。</p><h3 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h3><p>它们与其他任何东西都没有关系，通常被认为总是相同的大小。</p><table><thead><tr><th align="left">单位</th><th align="left">名称</th><th align="left">等价换算</th></tr></thead><tbody><tr><td align="left"><code>cm</code></td><td align="left">厘米</td><td align="left">1cm = 96px/2.54</td></tr><tr><td align="left"><code>mm</code></td><td align="left">毫米</td><td align="left">1mm = 1/10th of 1cm</td></tr><tr><td align="left"><code>Q</code></td><td align="left">四分之一毫米</td><td align="left">1Q = 1/40th of 1cm</td></tr><tr><td align="left"><code>in</code></td><td align="left">英寸</td><td align="left">1in = 2.54cm = 96px</td></tr><tr><td align="left"><code>pc</code></td><td align="left">十二点活字</td><td align="left">1pc = 1/16th of 1in</td></tr><tr><td align="left"><code>pt</code></td><td align="left">点</td><td align="left">1pt = 1/72th of 1in</td></tr><tr><td align="left"><code>px</code></td><td align="left">像素</td><td align="left">1px = 1/96th of 1in</td></tr></tbody></table><p>大多数在用于打印时比用于屏幕输出时更有用。</p><h3 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h3><p>对长度单位相对于其他一些东西，比如父元素的字体大小，或者视图端口的大小。</p><p>使用相对单位的好处是，经过一些仔细的规划，可以使文本或其他元素的大小与页面上的其他内容相对应。下表列出了web开发中一些最有用的单位。</p><table><thead><tr><th>单位</th><th>相对于</th></tr></thead><tbody><tr><td><code>em</code></td><td>在<code>font-size</code>中使用是相对于父元素的字体大小，在其他属性中使用时相对于自身的字体大小，如<code>width</code></td></tr><tr><td><code>ex</code></td><td>字符“x”的高度</td></tr><tr><td><code>ch</code></td><td>数字“0”的宽度</td></tr><tr><td><code>rem</code></td><td>根元素的字体大小</td></tr><tr><td><code>lh</code></td><td>元素的<code>line-height</code></td></tr><tr><td><code>vw</code></td><td>视窗宽度的1%</td></tr><tr><td><code>vh</code></td><td>视窗高度的1%</td></tr><tr><td><code>vmin</code></td><td>视窗较小尺寸的1%</td></tr><tr><td><code>vmax</code></td><td>视图大尺寸的1%</td></tr></tbody></table><h2 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h2><p>在许多情况下，百分比与长度的处理方法是一样的。百分比的问题在于，它们总是相对于其他值设置的。例如，如果将元素的字体大小设置为百分比，那么它将是元素父元素字体大小的百分比。如果使用百分比作为宽度值，那么它将是父值宽度的百分比。</p><h1 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h1><h2 id="颜色关键字"><a href="#颜色关键字" class="headerlink" title="颜色关键字"></a>颜色关键字</h2><p>可见链接：<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value">https://developer.mozilla.org/en-US/docs/Web/CSS/color_value</a></p><h2 id="十六进制RGB值"><a href="#十六进制RGB值" class="headerlink" title="十六进制RGB值"></a>十六进制RGB值</h2><p>每个十六进制值由一个散列/磅符号(#)和六个十六进制数字组成，每个十六进制数字都可以取0到f(代表15)之间的16个值中的一个——所以是0123456789abcdef。每对值表示一个通道—红色、绿色和蓝色—并允许我们为每个通道指定256个可用值中的任意一个(16 x 16 = 256)。</p><h2 id="RGB和RGBA"><a href="#RGB和RGBA" class="headerlink" title="RGB和RGBA"></a>RGB和RGBA</h2><p>RGB值是一个函数—RGB()—它有三个参数，表示颜色的红色、绿色和蓝色通道值，与十六进制值的方法非常相似。RGB的不同之处在于，每个通道不是由两个十六进制数字表示的，而是由一个介于0到255之间的十进制数字表示的</p><p>您还可以使用RGBA颜色——它们的工作方式与RGB颜色完全相同，因此您可以使用任何RGB值，但是有第四个值表示颜色的alpha通道，它控制不透明度。如果将这个值设置为<code>0</code>，它将使颜色完全透明，而设置为<code>1</code>将使颜色完全不透明。介于两者之间的值提供了不同级别的透明度。</p><h2 id="HSL和HSLA"><a href="#HSL和HSLA" class="headerlink" title="HSL和HSLA"></a>HSL和HSLA</h2><p>与RGB相比，HSL颜色模型的支持稍差一些(在旧版本的IE中不支持)，它是在设计师们感兴趣之后实现的。<code>hsl()</code> 函数接受色调、饱和度和亮度值作为参数，而不是红色、绿色和蓝色值，这些值的不同方式组合，可以区分1670万种颜色：</p><ul><li><strong>色调</strong>： 颜色的底色。这个值在0和360之间，表示色轮周围的角度。</li><li><strong>饱和度</strong>： 颜色有多饱和？ 它的值为0 - 100%，其中0为无颜色(它将显示为灰色阴影)，100%为全色饱和度</li><li><strong>亮度</strong>：颜色有多亮？ 它从0 - 100%中获取一个值，其中0表示没有光(它将完全显示为黑色)，100%表示完全亮(它将完全显示为白色)</li></ul>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习笔记——面向对象[创建对象]</title>
      <link href="2020/07/22/JavaScipt-OOP/"/>
      <url>2020/07/22/JavaScipt-OOP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="使用工厂模式创建对象"><a href="#使用工厂模式创建对象" class="headerlink" title="使用工厂模式创建对象"></a>使用工厂模式创建对象</h1><blockquote><p>工厂模式时软件工程领域的一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。</p><p>开发人员用函数来封装以特定接口创建对象的细节。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="工厂模式所带来的问题"><a href="#工厂模式所带来的问题" class="headerlink" title="工厂模式所带来的问题"></a>工厂模式所带来的问题</h2><p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决 <strong>对象识别</strong> 的问题（即怎么样知道一个对象的类型）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person1); <span class="comment">// object, 而我们想让他返回Person</span></span><br></pre></td></tr></table></figure><hr><h1 id="使用构造函数模式创建对象"><a href="#使用构造函数模式创建对象" class="headerlink" title="使用构造函数模式创建对象"></a>使用构造函数模式创建对象</h1><blockquote><p>ECMAScript中的构造函数可以用来创建特定类型的对象。像<code>Object</code>和<code>Array</code>这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.job = job;</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicolas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>Person()</code>函数取代了<code>createPerson()</code>函数，并且有以下不同之处：</p><ul><li>没有显示地创建对象；</li><li>直接将属性和方法赋给了<code>this</code>对象</li><li>没有<code>return</code>语句</li></ul><h2 id="使用new运算符创建实例"><a href="#使用new运算符创建实例" class="headerlink" title="使用new运算符创建实例"></a>使用<code>new</code>运算符创建实例</h2><p>要创建<code>Person</code>对象，必须使用<code>new</code>操作符，以这种方式调用构造函数，会经历以下4步：</p><ol><li>创建一个新对象；</li><li>将构造函数的作用域赋给新对象（即<code>this</code>指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性）；</li><li>返回新对象</li></ol><p>上个例子创建的两个对象<code>person1</code>和<code>person2</code>分别保存着<code>Person</code>对象的一个不同的实例。这两个对象都有一个<code>constructor</code>属性（构造函数），指向<code>Person</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor == person2.constructor); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.constructor == Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="自定义构造函数可以将它标识为一种特定的类型"><a href="#自定义构造函数可以将它标识为一种特定的类型" class="headerlink" title="自定义构造函数可以将它标识为一种特定的类型"></a>自定义构造函数可以将它标识为一种特定的类型</h2><p>这正是构造函数模式胜过工厂模式的地方</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="构造函数当作函数"><a href="#构造函数当作函数" class="headerlink" title="构造函数当作函数"></a>构造函数当作函数</h2><p>构造函数与其他函数的唯一区别，就在于他们调用方式的不同。任何函数，只要通过<code>new</code>来调用，那它就可以作为构造函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作为构造函数使用</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;Nicolas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;software engineer&quot;</span>);</span><br><span class="line">person.sayName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//作为普通函数使用</span></span><br><span class="line">Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br><span class="line"><span class="built_in">window</span>.sayName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">&quot;Kristen&quot;</span>, <span class="number">25</span>, <span class="string">&quot;Nurse&quot;</span>);</span><br><span class="line">o.sayName();</span><br></pre></td></tr></table></figure><h2 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h2><p>每个方法在每个实例上重新创建一遍。<code>person1</code>，<code>person2</code>都有一个名为<code>sayName()</code>的方法，但两个方法不是同一个<code>Function</code>实例。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.job = job;</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicolas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>即，创建两个完成同样任务的<code>Function</code>实例没有必要，可以通过函数定义转移到构造函数外面来解决这个问题</p><h2 id="方法在构造函数外定义"><a href="#方法在构造函数外定义" class="headerlink" title="方法在构造函数外定义"></a>方法在构造函数外定义</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.job = job;</span><br><span class="line">    <span class="built_in">this</span>.sayName = sayName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicolas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这个时候又有新问题出现了：</p><ul><li>在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。</li><li>如果对象需要定义很多方法，就需要定义很多个全局函数，于是这个自定义类型没有丝毫封装性可言了。</li></ul><hr><h1 id="使用原型模式创建对象"><a href="#使用原型模式创建对象" class="headerlink" title="使用原型模式创建对象"></a>使用原型模式创建对象</h1><p>创建的每个函数都有一个<code>prototype</code>属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由<strong>特定类型的所有实例</strong>共享的属性和方法。使用原型对象的好处，是可以让所有对象实例共享它所包含的属性和方法。不必在构造函数中定义实例的信息，而是可以将这些信息直接添加到原型对象中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicolas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与构造函数模式不同的是，新对象的这些属性和方法时由所有实例共享的。换句话说，<code>person1</code>和<code>person2</code>访问的都是同一组属性和同一个<code>sayname()</code>函数。</p><h2 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h2><p>无论何时，创建了一个函数，就会创建一个<code>prototype</code>属性，这个属性指向函数的原型对象。</p><p>而原型对象会自动获得一个<code>constructor</code>（构造函数）属性，这个属性指向<code>prototype</code>属性所在函数的指针。即<code>Person.prototype.constructor</code>指向<code>Person</code></p><p>下图展示了<code>Person</code>构造函数、<code>Person</code>的原型属性，以及<code>Person</code>的两个实例之间的关系。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/javascript-prototype.001.jpeg"></p><p><code>Person</code>的每个实例，都包含一个内部属性，该属性仅仅指向了<code>Person.prototype</code>；换句话说，它们与构造函数没有直接关系。</p><p>可以通过<code>isPrototypeOf()</code>方法来确定对象之间是否存在这种关系：如果<code>[[Prototype]]</code>指向调用<code>isPrototypeOf()</code>方法的对象(<code>Person.prototype</code>)，那么这个方法就会返回<code>true</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicolas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索从本实例开始，如果找到了具有给定名字的值，则返回该属性值；如果没有找到，继续搜索原型对象，在原型对象中查找具有给定名字的属性。</p><h2 id="重写与屏蔽"><a href="#重写与屏蔽" class="headerlink" title="重写与屏蔽"></a>重写与屏蔽</h2><p>当为对象实例添加一个属性时，就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会在实例中设置这个属性，而不会恢复其指向原型的连接。可以使用<code>delete</code>来完全删除实例属性，从而能够让我们重新访问原型中的属性。</p><h2 id="使用hasOwnProperty-方法检测是否存在于实例中"><a href="#使用hasOwnProperty-方法检测是否存在于实例中" class="headerlink" title="使用hasOwnProperty()方法检测是否存在于实例中"></a>使用<code>hasOwnProperty()</code>方法检测是否存在于实例中</h2><p>如果给定的属性存在于对象实例中，才会返回<code>true</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicolas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="in操作符"><a href="#in操作符" class="headerlink" title="in操作符"></a><code>in</code>操作符</h2><p><code>in</code>操作符有两种使用方式，单独使用和在<code>for</code>循环中使用。单独使用时，<code>in</code>操作符会在通过对象能够访问给定属性时返回<code>true</code>，无聊该属性是在原型中还是实例中。</p><h2 id="hasPrototypeProperty-方法"><a href="#hasPrototypeProperty-方法" class="headerlink" title="hasPrototypeProperty()方法"></a><code>hasPrototypeProperty()</code>方法</h2><p>检查给定属性是否存在于原型中，重写后不在原型中，返回<code>false</code>，否则返回<code>true</code>。</p><h2 id="使用字面量形式简化原型语法"><a href="#使用字面量形式简化原型语法" class="headerlink" title="使用字面量形式简化原型语法"></a>使用字面量形式简化原型语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person.constructor <span class="keyword">instanceof</span> Person); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person.constructor <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>此时，<code>Person</code>的实例的<code>constructor</code>属性不等于<code>Person</code>，可以手动设置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">    <span class="title">name</span>: &quot;<span class="title">Nicholas</span>&quot;,</span><br><span class="line">    <span class="title">age</span>: 29,</span><br><span class="line">    <span class="title">job</span>: &quot;<span class="title">Software</span> <span class="title">Engineer</span>&quot;,</span><br><span class="line">    <span class="title">sayName</span>: <span class="title">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h2><p>对原型对象所作的任何修改都能够直接从实例上反映出来——即使是先创建了实例后修改的原型也照样如此。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayName(); <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p>但如果重写整个原型对象，那么情况就不一样了。</p><p>调用构造函数时，会为实例添加一个指向最初原型的<code>[[Prototype]]</code>指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。</p><p>以下代码会报错</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">    <span class="title">name</span>: &quot;<span class="title">Nicholas</span>&quot;,</span><br><span class="line">    <span class="title">age</span>: 29,</span><br><span class="line">    <span class="title">job</span>: &quot;<span class="title">Software</span> <span class="title">Engineer</span>&quot;,</span><br><span class="line">    <span class="title">sayName</span>: <span class="title">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayName(); <span class="comment">// TypeError: person.sayName is not a function</span></span><br></pre></td></tr></table></figure><p><strong>实例中的指针仅指向原型，而不指向构造函数</strong></p><h2 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h2><p>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型<code>(Object,Array,String)等等</code>都在构造函数的原型上定义了方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort); <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.substring); <span class="comment">//function</span></span><br></pre></td></tr></table></figure><p><strong>不推荐在产品化的程序中修改原生对象的原型</strong></p><h2 id="原生对象的问题"><a href="#原生对象的问题" class="headerlink" title="原生对象的问题"></a>原生对象的问题</h2><ul><li>省略了构造函数传递初始化参数的这一环节，导致所有实例默认情况下都将取得相同的属性值。</li><li>对于包含引用类型值的属性来说，问题比较突出</li></ul><p>比如如下例子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">    <span class="title">name</span>: &quot;<span class="title">Nicholas</span>&quot;,</span><br><span class="line">    <span class="title">age</span>: 29,</span><br><span class="line">    <span class="title">job</span>: &quot;<span class="title">Software</span> <span class="title">Engineer</span>&quot;,</span><br><span class="line">    <span class="title">friends</span>: [&quot;<span class="title">Shelby</span>&quot;, &quot;<span class="title">Court</span>&quot;],</span><br><span class="line">    <span class="title">sayName</span>: <span class="title">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">&quot;Van&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends); <span class="comment">// [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends == person2.friends); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>可见，一般情况下，一个人的朋友未必是另一个人的朋友，实例一般都是要有属于自己的全部属性的。</p><hr><h1 id="组合使用构造函数和原型模式"><a href="#组合使用构造函数和原型模式" class="headerlink" title="组合使用构造函数和原型模式"></a>组合使用构造函数和原型模式</h1><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用。另外还支持向构造函数传递参数；集两种模式之长。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.job = job;</span><br><span class="line">    <span class="built_in">this</span>.friends = [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">    <span class="title">sayName</span>: <span class="title">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicolas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">&quot;Van&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends); <span class="comment">//[ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">//[ &#x27;Shelby&#x27;, &#x27;Court&#x27; ]</span></span><br></pre></td></tr></table></figure><hr><h1 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h1><p>可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.job = job;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span>.sayName != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只在<code>sayName()</code>方法不存在的情况下，才会将它添加到原型中。</p><p>注意不能用字面量形式重写原型<code>Person.prototype = &#123;&#125;;</code>，否则会切断现有实例与新原型的关系。</p><hr><h1 id="寄生构造函数模式（不建议）"><a href="#寄生构造函数模式（不建议）" class="headerlink" title="寄生构造函数模式（不建议）"></a>寄生构造函数模式（不建议）</h1><p>在前述几种模式都不适用的情况下，可以使用寄生构造函数模式。这种模式基本思想是创建一个函数，该函数的作业仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个模式除了使用<code>new</code>操作符，其他和工厂模式时一样的。</p><p>构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个<code>return</code>语句，可以重写调用构造函数时返回的值。</p><p>该模式的作用是在特殊情况下为对象创建构造函数。</p><p>假设我们想创建一个具有额外方法的特殊数组，但不能直接修改<code>Array</code>的构造函数，可以使用这个模式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.join(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors.toPipedString()); <span class="comment">// red|blue|green</span></span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>返回的对象与构造函数或与构造函数的原型属性之间没有关系，不能使用<code>instanceof</code>来确定对象类型。</p><hr><h1 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h1><h2 id="稳妥对象"><a href="#稳妥对象" class="headerlink" title="稳妥对象"></a>稳妥对象</h2><p>指没有公共属性，而且其他方法也不引用<code>this</code>对象。稳妥对象最适合在一些安全的环境中（禁止使用<code>this</code>和<code>new</code>），或者放置数据被其他应用程序（如<code>Mashup</code>程序）改动时使用。</p><p>类似于寄生构造函数模式，但：</p><ol><li>新创建对象的实例方法不引用<code>this</code>；</li><li>不使用<code>new</code>操作符调用构造函数</li></ol><h2 id="重写Person构造函数"><a href="#重写Person构造函数" class="headerlink" title="重写Person构造函数"></a>重写<code>Person</code>构造函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private members</span></span><br><span class="line">    <span class="keyword">var</span> nameUC = name.toUpperCase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public members</span></span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    o.sayNameUC = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(nameUC);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = Person(<span class="string">&quot;Nicolas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); <span class="comment">// Nicolas</span></span><br><span class="line">friend.sayName();</span><br><span class="line">friend.sayNameUC();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(friend.name); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.nameUC); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>除了使用<code>sayName()</code>方法外，没有其他办法访问<code>name</code>的值。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。</p><p>凡是想设为 <code>private</code> 的成员都不要挂到 <code>Person</code> 返回的对象 <code>o</code> 的属性上面，挂上了就是 <code>public </code>的了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《JavaScript高级程序设计》</li></ul>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习笔记——正则表达式</title>
      <link href="2020/07/21/JavaScript-RegExp/"/>
      <url>2020/07/21/JavaScript-RegExp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="正则表达式的功能"><a href="#正则表达式的功能" class="headerlink" title="正则表达式的功能"></a>正则表达式的功能</h1><blockquote><p>用于定义一些字符串的规则，计算机可以根据正则表达式来检查一个字符串是否符合规则，获取字符串中符合规则的内容提取出来。</p></blockquote><hr><h1 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h1><h2 id="使用字面量形式定义正则表达式"><a href="#使用字面量形式定义正则表达式" class="headerlink" title="使用字面量形式定义正则表达式"></a>使用字面量形式定义正则表达式</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语法: var expression = /pattern/flags</span></span><br></pre></td></tr></table></figure><p>其中，模式部分(<code>pattern</code>)可以是任意简单或复杂的正则表达式，标志(<code>flag</code>)表明正则表达式的行为。</p><p><code>flag</code>的值可以为：</p><ul><li><code>g</code>，全局模式(global)，即模式将被应用于所有字符串，而并非在匹配到第一个字符串时就停止匹配</li><li><code>i</code>，不区分大小写模式(case-insensitive)，即在匹配时忽略大小写</li><li><code>m</code>，多行模式(multiline)，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项</li></ul><p>如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配字符串中所有&quot;at&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/at/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匹配第一个&quot;bat&quot;或&quot;cat&quot;,不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/[bc]at/i</span>;</span><br></pre></td></tr></table></figure><h3 id="字面量形式下的元字符转义"><a href="#字面量形式下的元字符转义" class="headerlink" title="字面量形式下的元字符转义"></a>字面量形式下的元字符转义</h3><p>元字符包括<code>()</code>,<code>[]</code>,<code>&#123;&#125;</code>,<code>\</code>,<code>^</code>,<code>$</code>,<code>|</code>,<code>?</code>,<code>*</code>,<code>+</code>,<code>.</code></p><p>如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匹配所有以&quot;at&quot;结尾的 3 个字符的组合,不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern3 = <span class="regexp">/.at/gi</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匹配所有&quot;.at&quot;,不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern4 = <span class="regexp">/\.at/gi</span>;</span><br></pre></td></tr></table></figure><h2 id="使用RegExp构造函数创建正则表达式"><a href="#使用RegExp构造函数创建正则表达式" class="headerlink" title="使用RegExp构造函数创建正则表达式"></a>使用<code>RegExp</code>构造函数创建正则表达式</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匹配第一个&quot;bat&quot;或&quot;cat&quot;,不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern5 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与pattern5相同,只不过使用构造函数创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern6 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;[bc]at&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="使用元字符需要双重转义"><a href="#使用元字符需要双重转义" class="headerlink" title="使用元字符需要双重转义"></a>使用元字符需要双重转义</h3><p>要注意的是，传递给<code>RegExp</code>构造函数的两个参数都是字符串。由于<code>RegExp</code>构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。</p><p>下表给出了一些模式，左边是字面量模式，右边是使用<code>RegExp</code>构造函数定义相同模式时使用的字符串。</p><table><thead><tr><th align="center">字面量模式</th><th align="center">等价的字符串</th></tr></thead><tbody><tr><td align="center"><code>/\[bc\]at/</code></td><td align="center"><code>&quot;\\[bc\\]at&quot;</code></td></tr><tr><td align="center"><code>/\.at/</code></td><td align="center"><code>&quot;\\.at&quot;</code></td></tr><tr><td align="center"><code>/name\/age/</code></td><td align="center"><code>[name\\/age]</code></td></tr><tr><td align="center"><code>/\d.\d&#123;1,2&#125;/</code></td><td align="center"><code>&quot;\\d.\\d&#123;1,2&#125;&quot;</code></td></tr><tr><td align="center"><code>/\w\\hello\\123/</code></td><td align="center"><code>&quot;\\w\\\\hello\\\\123&quot;</code></td></tr></tbody></table><hr><h1 id="正则表达式RegExp的实例属性"><a href="#正则表达式RegExp的实例属性" class="headerlink" title="正则表达式RegExp的实例属性"></a>正则表达式<code>RegExp</code>的实例属性</h1><p><code>RegExp</code>的每个实例都具有以下属性，通过这些属性可用获得有关模式的各种信息</p><ul><li><code>global</code> 布尔值，是否设置了<code>g</code>标志</li><li><code>ignoreCase</code> 布尔值，表示是否设置了<code>i</code>标志</li><li><code>lastIndex</code> 整数，表示开始搜索下一个匹配项的字符位置，从0算起</li><li><code>multiline</code> 布尔值，表示是否设置了m标志</li><li><code>source</code>正则表达式的字符串表示，按照字面量形式（而非传入构造函数中的字符串模式）返回</li></ul><p>通过这些属性可以知道一个正则表达式的各方面信息，如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/\[bc\]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.global); <span class="comment">//  false</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.ignoreCase); <span class="comment">//  true</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.multiline); <span class="comment">//  false</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.lastIndex); <span class="comment">//  0</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.source); <span class="comment">//  \[bc\]at</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;\\[bc\\]at&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.global); <span class="comment">//   false</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.ignoreCase); <span class="comment">//  true</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.multiline); <span class="comment">//  false</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.lastIndex); <span class="comment">//  0</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.source); <span class="comment">//  \[bc\]at</span></span><br></pre></td></tr></table></figure><p>我们注意到第一种使用的字面量，第二种使用的构造函数，但它们的<code>source</code>属性是相同的，<code>source</code>属性保存的是字面量形式所用的字符串。</p><hr><h1 id="正则表达式RegExp的实例方法"><a href="#正则表达式RegExp的实例方法" class="headerlink" title="正则表达式RegExp的实例方法"></a>正则表达式<code>RegExp</code>的实例方法</h1><h2 id="test方法"><a href="#test方法" class="headerlink" title="test方法"></a><code>test</code>方法</h2><ul><li><p>方法可以检查一个字符串是否符合正则表达式的规则， 如果符合则返回true，否则返回false。</p></li><li><p>方法接受一个字符串参数</p></li><li><p>在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">&quot;000-00-0000&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;The Pattern was matched&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exec-方法"><a href="#exec-方法" class="headerlink" title="exec()方法"></a><code>exec()</code>方法</h2><ul><li><code>RegExp</code>对象的主要方法是<code>exec()</code>，该方法是专门为捕获组而设计的。</li><li>该方法接受一个参数，即要应用模式的字符串</li><li>返回包含第一个匹配项信息的数组（<code>Array</code>实例），若没有匹配项则返回<code>null</code>，在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果没有捕获组，则数组只包含一项）</li><li>返回值还包含两个额外属性<code>index</code>（表示匹配项在字符串中的位置），<code>input</code>（表示应用正则表达式的字符串）</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">&quot;mom and dad and baby&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);</span><br><span class="line"><span class="built_in">console</span>.log(matches.input);</span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">mom and dad and baby</span><br><span class="line">mom and dad and baby</span><br><span class="line"> and dad and baby</span><br><span class="line"> and baby</span><br></pre></td></tr></table></figure><p>对于<code>exec()</code>方法而言，即使在模式中设置了全局标志<code>g</code>，它每次也只会返回一个匹配项，每次调用会在字符串中继续查找新匹配项，而没有设置全局标志时，每次都始终返回第一个匹配项</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/.at/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = pattern1.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">//  0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">//  cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.lastIndex); <span class="comment">//  0</span></span><br><span class="line"></span><br><span class="line">matches = pattern1.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">//  0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">//  cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.lastIndex); <span class="comment">//  0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = pattern1.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">//  0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">//  cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.lastIndex); <span class="comment">//  0</span></span><br><span class="line"></span><br><span class="line">matches = pattern1.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">//  0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">//  cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.lastIndex); <span class="comment">//  0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/.at/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = pattern2.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">//  0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">//  cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.lastIndex); <span class="comment">//  3</span></span><br><span class="line"></span><br><span class="line">matches = pattern2.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">//  5</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">//  bat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.lastIndex); <span class="comment">//  8</span></span><br></pre></td></tr></table></figure><hr><h1 id="字符串中和正则表达式相关的方法"><a href="#字符串中和正则表达式相关的方法" class="headerlink" title="字符串中和正则表达式相关的方法"></a>字符串中和正则表达式相关的方法</h1><h2 id="split-方法"><a href="#split-方法" class="headerlink" title="split()方法"></a><code>split()</code>方法</h2><p>将一个字符串根据传入的正则表达式作为参数进行拆分，即使不指定全局匹配，也会全部拆分</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;1a2b3c4d5e6f7&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据任意字母来将字符串拆分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> result = str.split(<span class="regexp">/[A-z]/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;,&#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;,&#x27;7&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="search-方法"><a href="#search-方法" class="headerlink" title="search()方法"></a><code>search()</code>方法</h2><ul><li>搜索字符串中是否含有指定内容，如果搜索到了返回第一次出现的索引，如果没有返回-1</li><li>接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串</li><li><code>search()</code>只会查找第一个，即使设置全局匹配也没用</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;hello abc hello aec afc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 搜索字符串中是否含有abc 或 aec 或 afc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">result = str.search(<span class="regexp">/a[bef]c/</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="match方法"><a href="#match方法" class="headerlink" title="match方法"></a><code>match</code>方法</h2><ul><li>根据正则表达式，从字符串中将符合条件的内容提取出来，默认情况下，找到第一个符合要求的内容时就停止搜索</li><li>如果设置为全局匹配，就会匹配到所有内容</li><li>可以为一个正则表达式设置多个匹配模式，且顺序无所谓</li><li><code>match()</code>会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;1a2a3a4a5e6f7A8B9C&quot;</span>;</span><br><span class="line"></span><br><span class="line">result = str.match(<span class="regexp">/[a-z]/ig</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//[&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;,&#x27;a&#x27;, &#x27;e&#x27;, &#x27;f&#x27;,&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="replace方法"><a href="#replace方法" class="headerlink" title="replace方法"></a><code>replace</code>方法</h2><ul><li>可以将字符串中的指定内容替换为新的内容</li><li>参数：<ol><li>被替换的内容，可以接受一个正则表达式作为参数</li><li>新的内容</li></ol></li><li>默认只会替换一个</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;1a2a3a4a5e6f7A8B9C&quot;</span>;</span><br><span class="line"></span><br><span class="line">result = str.replace(<span class="regexp">/[a-z]/gi</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//123456789</span></span><br></pre></td></tr></table></figure><hr><h1 id="正则表达式的限制符"><a href="#正则表达式的限制符" class="headerlink" title="正则表达式的限制符"></a>正则表达式的限制符</h1><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>通过量词可以设置一个内容出现的次数，量词只对它前边的一个内容起作用</p><ul><li><code>&#123;n&#125;</code>正好出现n次</li><li><code>&#123;m,n&#125;</code>出现m-n次</li><li><code>&#123;m,&#125;</code>m次以上</li><li><code>+</code>至少一个，相当于<code>&#123;1,&#125;</code></li><li><code>*</code>0个或多个，相当于<code>&#123;0,&#125;</code></li><li><code>?</code>0个或1个，相当于<code>&#123;0,1&#125;</code></li></ul><h2 id="开头结尾符"><a href="#开头结尾符" class="headerlink" title="开头结尾符"></a>开头结尾符</h2><ul><li><code>^</code>表示开头</li><li><code>$</code>表示结尾</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reg = <span class="regexp">/^a/</span>; <span class="comment">//匹配开头的a</span></span><br><span class="line">reg = <span class="regexp">/a$/</span>; <span class="comment">//匹配结尾的a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果在正则表达式中同时使用^ $则要求字符串必须完全符合正则表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">reg = <span class="regexp">/^a$/</span>;</span><br></pre></td></tr></table></figure><h3 id="检查手机号码"><a href="#检查手机号码" class="headerlink" title="检查手机号码"></a>检查手机号码</h3><p>假定手机号码的规则为：</p><ul><li><em>以1开头</em></li><li><em>第二位3-9任意数字</em></li><li><em>三位以后任意数字9个</em></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> phoneStr = <span class="string">&quot;13067890123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> phoneReg = <span class="regexp">/^1[3-9][0-9]&#123;9&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(phoneReg.test(phoneStr));</span><br></pre></td></tr></table></figure><hr><h1 id="正则表达式其他字符"><a href="#正则表达式其他字符" class="headerlink" title="正则表达式其他字符"></a>正则表达式其他字符</h1><h2 id="或-非"><a href="#或-非" class="headerlink" title="或|,非[^]"></a>或<code>|</code>,非<code>[^]</code></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/创建一个正则表达式，检查一个字符串中是否有a或b</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用 | 表示或者的意思</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">reg = <span class="regexp">/a|b|c/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [^ ] 除了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">reg = <span class="regexp">/[^ab]/</span>;</span><br><span class="line">reg = <span class="regexp">/[^0-9]/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;12a3456&quot;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="其他转义符"><a href="#其他转义符" class="headerlink" title="其他转义符"></a>其他转义符</h2><ul><li><code>\w</code>任意字母，数字，下划线<code>[A-z0-9_]</code></li><li><code>\W</code>除了字母，数字，下划线<code>[^A-z0-9_]</code></li><li><code>\d</code>任意数字<code>[0-9]</code></li><li><code>\D</code>除了数字<code>[^0-9]</code></li><li><code>\s</code>空格</li><li><code>\S</code>除了空格</li><li><code>\b</code>单词边界</li><li><code>\B</code>除了单词边界</li></ul><h3 id="检查一个字符串中是否含有单词child"><a href="#检查一个字符串中是否含有单词child" class="headerlink" title="检查一个字符串中是否含有单词child"></a>检查一个字符串中是否含有单词<code>child</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reg = <span class="regexp">/\bchild\b/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;hello child&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;hello children&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="去除开头和结尾的空格"><a href="#去除开头和结尾的空格" class="headerlink" title="去除开头和结尾的空格"></a>去除开头和结尾的空格</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;              he      llo                &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去除开头的空格</span></span><br><span class="line"><span class="comment">//str = str.replace(/^\s*/, &quot;&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//去除结尾的空格</span></span><br><span class="line"><span class="comment">//str = str.replace(/\s*$/, &quot;&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /^\s*|\s*$/g 匹配开头和结尾的空格</span></span><br><span class="line">str = str.replace(<span class="regexp">/^\s*|\s*$/g</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//he      llo</span></span><br></pre></td></tr></table></figure><h3 id="检查电子邮件的格式"><a href="#检查电子邮件的格式" class="headerlink" title="检查电子邮件的格式"></a>检查电子邮件的格式</h3><p>假定电子邮件的规则：</p><ul><li><em>任意字母数字下划线</em> <code>.</code><em>任意字母数字下划线</em><code>@</code><em>任意字母数字</em><code>.</code><em>任意字母（2-5位）</em>(1-2次)</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \w&#123;3,&#125;  (\.\w+)*  @  [A-z0-9]+  (\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;</span></span><br><span class="line"><span class="keyword">var</span> emailReg = <span class="regexp">/^\w&#123;3,&#125;(\.\w+)*@[A-z0-9]+(\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> email = <span class="string">&quot;jzhmcoo1@163.com&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(emailReg.test(email)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《JavaScript高级程序设计（第三版）》</li><li><a href="https://www.bilibili.com/video/BV1YW411T7GX">尚硅谷的JavaScript课程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记</title>
      <link href="2020/07/18/LearnGit/"/>
      <url>2020/07/18/LearnGit/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文根据廖雪峰老师的<code>Git教程</code>进行总结，只是本人为了假设印象手敲了一遍的简略版，原文链接<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰的官方网站</a></p><h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><h2 id="创建空文件夹"><a href="#创建空文件夹" class="headerlink" title="创建空文件夹"></a>创建空文件夹</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir LearnGit</span><br><span class="line"><span class="built_in">cd</span> LearnGit</span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line">/User/lixing/LearnGit</span><br></pre></td></tr></table></figure><h2 id="使用git-init命令初始化git仓库"><a href="#使用git-init命令初始化git仓库" class="headerlink" title="使用git init命令初始化git仓库"></a>使用<code>git init</code>命令初始化<code>git</code>仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/lixing/LearnGit/.git/</span><br></pre></td></tr></table></figure><h2 id="使用la命令查看目录"><a href="#使用la命令查看目录" class="headerlink" title="使用la命令查看目录"></a>使用<code>la</code>命令查看目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">la</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  9 lixing  staff   288B  7 15 14:43 .git</span><br></pre></td></tr></table></figure><h2 id="在根目录下创建新文件readme-md"><a href="#在根目录下创建新文件readme-md" class="headerlink" title="在根目录下创建新文件readme.md"></a>在根目录下创建新文件<code>readme.md</code></h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><h2 id="使用git-add-lt-文件名-gt-将文件添加到暂存区"><a href="#使用git-add-lt-文件名-gt-将文件添加到暂存区" class="headerlink" title="使用git add &lt;文件名&gt;将文件添加到暂存区"></a>使用<code>git add &lt;文件名&gt;</code>将文件添加到暂存区</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add readme.md</span><br></pre></td></tr></table></figure><h2 id="使用git-commit将文件提交到本地仓库"><a href="#使用git-commit将文件提交到本地仓库" class="headerlink" title="使用git commit将文件提交到本地仓库"></a>使用<code>git commit</code>将文件提交到本地仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;wrote a readme file.&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[master (root-commit) c81e9cb] wrote a readme file.</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.md</span><br></pre></td></tr></table></figure><h1 id="历史记录管理"><a href="#历史记录管理" class="headerlink" title="历史记录管理"></a>历史记录管理</h1><h2 id="使用git-status查看仓库当前状态"><a href="#使用git-status查看仓库当前状态" class="headerlink" title="使用git status查看仓库当前状态"></a>使用<code>git status</code>查看仓库当前状态</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>我们修改<code>readme.md</code></p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>使用<code>git status</code>命令查看结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">    modified:   readme.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看到它提示<code>readme.md</code>还未被提交修改</p><h2 id="使用git-diff-lt-文件名-gt-查看具体修改内容"><a href="#使用git-diff-lt-文件名-gt-查看具体修改内容" class="headerlink" title="使用git diff &lt;文件名&gt;查看具体修改内容"></a>使用<code>git diff &lt;文件名&gt;</code>查看具体修改内容</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff readme.md</span><br><span class="line"></span><br><span class="line">diff --git a/readme.md b/readme.md</span><br><span class="line">index 46d49bf..013b5bc 100644</span><br><span class="line">--- a/readme.md</span><br><span class="line">+++ b/readme.md</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">-Git is free software.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line">+Git is free software.</span><br><span class="line">\ No new</span><br></pre></td></tr></table></figure><h2 id="使用add-commit添加后再次使用git-status查看状态"><a href="#使用add-commit添加后再次使用git-status查看状态" class="headerlink" title="使用add, commit添加后再次使用git status查看状态"></a>使用<code>add, commit</code>添加后再次使用<code>git status</code>查看状态</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add readme.md</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">    modified:   readme.md</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">&quot;add distributed&quot;</span></span><br><span class="line">[master 38d23dd] add distributed.</span><br><span class="line"> 1 file changed, 2 insertions(+), 2 deletions(-)</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><h2 id="使用git-log命令查看历史记录"><a href="#使用git-log命令查看历史记录" class="headerlink" title="使用git log命令查看历史记录"></a>使用<code>git log</code>命令查看历史记录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit abd5bd8a226f98ac9f26d81b2bd6d5fb4ca1e2d6 (HEAD -&gt; master)</span><br><span class="line">Author: jzhmcoo1 &lt;jzhmzlxcoo1@gmail.com&gt;</span><br><span class="line">Date:   Wed Jul 15 15:12:56 2020 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit 38d23dd5a097de1b742ff7894655b6cc2f11a5a8</span><br><span class="line">Author: jzhmcoo1 &lt;jzhmzlxcoo1@gmail.com&gt;</span><br><span class="line">Date:   Wed Jul 15 15:09:42 2020 +0800</span><br><span class="line"></span><br><span class="line">    add distributed.</span><br><span class="line"></span><br><span class="line">commit c81e9cb1ef762f10f29f05ce65dae99f95d4b9af</span><br><span class="line">Author: jzhmcoo1 &lt;jzhmzlxcoo1@gmail.com&gt;</span><br><span class="line">Date:   Wed Jul 15 14:59:19 2020 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file.</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>其中<code>HEAD</code>执行的表示当前的版本，而<code>HEAD^</code>表示上个版本，<code>HEAD^^</code>表示上上个版本，前一百个版本写作<code>HEAD~100</code></p><h2 id="使用git-reset-hard-HEAD-回到上个版本"><a href="#使用git-reset-hard-HEAD-回到上个版本" class="headerlink" title="使用git reset --hard HEAD^回到上个版本"></a>使用<code>git reset --hard HEAD^</code>回到上个版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">HEAD is now at 38d23dd add distributed.</span><br></pre></td></tr></table></figure><h2 id="使用cat-readme-md查看回退后内容"><a href="#使用cat-readme-md查看回退后内容" class="headerlink" title="使用cat readme.md查看回退后内容"></a>使用<code>cat readme.md</code>查看回退后内容</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat readme.md</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>可以看到已经被还原了</p><h2 id="使用git-log查看回退后的记录"><a href="#使用git-log查看回退后的记录" class="headerlink" title="使用git log查看回退后的记录"></a>使用<code>git log</code>查看回退后的记录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">commit 38d23dd5a097de1b742ff7894655b6cc2f11a5a8 (HEAD -&gt; master)</span><br><span class="line">Author: jzhmcoo1 &lt;jzhmzlxcoo1@gmail.com&gt;</span><br><span class="line">Date:   Wed Jul 15 15:09:42 2020 +0800</span><br><span class="line"></span><br><span class="line">    add distributed.</span><br><span class="line"></span><br><span class="line">commit c81e9cb1ef762f10f29f05ce65dae99f95d4b9af</span><br><span class="line">Author: jzhmcoo1 &lt;jzhmzlxcoo1@gmail.com&gt;</span><br><span class="line">Date:   Wed Jul 15 14:59:19 2020 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file.</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>会发现最新的版本<code>append GPL</code>不见了。</p><p>在没有关闭命令行的情况下，可以根据记录再次返回最新版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard abd5bd8</span><br><span class="line">HEAD is now at abd5bd8 append GPL</span><br><span class="line"></span><br><span class="line">cat readme.md</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>果然又回到了最新版本</p><h2 id="使用-git-reflog查看每一次命令"><a href="#使用-git-reflog查看每一次命令" class="headerlink" title="使用 git reflog查看每一次命令"></a>使用 <code>git reflog</code>查看每一次命令</h2><p>如果不小心把命令行关了，那么只有通过这个方法进行回退最新版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog</span><br><span class="line">abd5bd8 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to abd5bd8</span><br><span class="line">38d23dd HEAD@&#123;1&#125;: reset: moving to 38d23dd</span><br><span class="line">38d23dd HEAD@&#123;2&#125;: reset: moving to HEAD^</span><br><span class="line">abd5bd8 (HEAD -&gt; master) HEAD@&#123;3&#125;: commit: append GPL</span><br><span class="line">38d23dd HEAD@&#123;4&#125;: commit: add distributed.</span><br><span class="line">c81e9cb HEAD@&#123;5&#125;: commit (initial): wrote a readme file.</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>我们可以找到最新版的<code>commit id</code>是<code>abd5bd8</code>，现在又可以使用<code>reset</code>命令回到最新版了</p><h1 id="工作区、暂存区、版本库"><a href="#工作区、暂存区、版本库" class="headerlink" title="工作区、暂存区、版本库"></a>工作区、暂存区、版本库</h1><h2 id="工作区（Working-Directory"><a href="#工作区（Working-Directory" class="headerlink" title="工作区（Working Directory)"></a>工作区（Working Directory)</h2><p>这里就是<code>Learn Git</code>这个目录</p><h2 id="版本库（Repository"><a href="#版本库（Repository" class="headerlink" title="版本库（Repository)"></a>版本库（Repository)</h2><p>工作区的隐藏目录<code>.git</code>是<code>Git</code>的版本库</p><p>版本库中的<code>Stage</code>即暂存区，使用<code>git add</code>命令的文件会先被加到此暂存区</p><p><code>git</code>还为我们自动创建了第一个分支<code>master</code>，以及一个指向<code>master</code>的指针<code>HEAD</code></p><p>目前来说<code>git commit</code>提交到的就是<code>master</code>分支上</p><h1 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h1><h2 id="使用git-restore-stage-readme-md回到add前的状态"><a href="#使用git-restore-stage-readme-md回到add前的状态" class="headerlink" title="使用git restore --stage readme.md回到add前的状态"></a>使用<code>git restore --stage readme.md</code>回到<code>add</code>前的状态</h2><p>假如现在的 <code>readme.md</code>被修改为</p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure><p>然后不小心已经使用<code>git add</code>提交到暂存区中了，</p><p>这个时候使用<code>git restore --stage readme.md</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git restore --stage readme.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 git status 查看</span></span><br><span class="line">git stauts</span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">    modified:   readme.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看到已经恢复到<code>add</code>前的状态了</p><h2 id="使用git-restore-s-HEAD-1回到上个-commit版本"><a href="#使用git-restore-s-HEAD-1回到上个-commit版本" class="headerlink" title="使用git restore -s HEAD~1回到上个 commit版本"></a>使用<code>git restore -s HEAD~1</code>回到上个 commit版本</h2><p>如果我们不小心<code>add</code>还不小心<code>commit</code>了，就可以使用<code>git restore -s HEAD~1</code>回到上一个<code>commit</code>版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git restore -s HEAD~1 readme.md</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">    modified:   readme.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看到我们回到了<code>add</code>前的状态</p><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><h2 id="情况一，确定要删"><a href="#情况一，确定要删" class="headerlink" title="情况一，确定要删"></a>情况一，确定要删</h2><ol><li><p>先删除文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm readme.md</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">    deleted:    readme.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>从 Git 中也删除</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm readme.md</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">&quot;remove readme.md&quot;</span></span><br><span class="line">[master bb6883d] remove readme.md</span><br><span class="line"> 1 file changed, 5 deletions(-)</span><br><span class="line"> delete mode 100644 readme.md</span><br></pre></td></tr></table></figure></li></ol><h2 id="情况二，删错了"><a href="#情况二，删错了" class="headerlink" title="情况二，删错了"></a>情况二，删错了</h2><ol><li>使用<code>git restore -s HEAD~1 readme.md</code>回到上个版本</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git restore -s HEAD~1 readme.md</span><br><span class="line"></span><br><span class="line">cat readme.md</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>git reset --hard &lt;commit id&gt;</code>回退到任意之前版本</li></ol><h1 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h1><h2 id="（如果没有设置-ssh）"><a href="#（如果没有设置-ssh）" class="headerlink" title="（如果没有设置 ssh）"></a>（如果没有设置 ssh）</h2><p>如果没有设置过 SSH KEY，主目录应该没有<code>.ssh</code>目录，如果没有可以使用以下命令创建</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>具体操作步骤省略</p><h2 id="在Github上新建一个仓库"><a href="#在Github上新建一个仓库" class="headerlink" title="在Github上新建一个仓库"></a>在<code>Github</code>上新建一个仓库</h2><p>起名可以为<code>LearnGit</code>其他保持默认</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/learn-git-remote.png" title="" alt="" data-align="center"><h2 id="使用给的提示命令，在本地命令行下输入以上代码"><a href="#使用给的提示命令，在本地命令行下输入以上代码" class="headerlink" title="使用给的提示命令，在本地命令行下输入以上代码"></a>使用给的提示命令，在本地命令行下输入以上代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/jzhmcoo1/LearnGit.git</span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Enumerating objects: 14, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (14/14), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (9/9), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (14/14), 1.19 KiB | 1.19 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 14 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">To https://github.com/jzhmcoo1/LearnGit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch <span class="string">&#x27;master&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;master&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br></pre></td></tr></table></figure><p>其中，第一次进行推送使用<code>git push -u</code>参数，会把本地的<code>master</code>分支内容推送到远程的<code>master</code>分支中，还会将他们关联起来，以后使用<code>push</code>命令时，可以简化为<code>git push origin master</code></p><h1 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h1><p>我们可以先把这个目录直接删掉，然后从刚才的项目库进行克隆</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -rf LearnGit</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:jzhmcoo1/LearnGit.git</span><br></pre></td></tr></table></figure><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建并切换到dev分支"><a href="#创建并切换到dev分支" class="headerlink" title="创建并切换到dev分支"></a>创建并切换到<code>dev</code>分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上<code>-b</code>表示创建并且切换，相当于</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><h2 id="使用git-branch查看当前分支"><a href="#使用git-branch查看当前分支" class="headerlink" title="使用git branch查看当前分支"></a>使用<code>git branch</code>查看当前分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p>带星号表示当前分支</p><h2 id="在新分支上进行提交"><a href="#在新分支上进行提交" class="headerlink" title="在新分支上进行提交"></a>在新分支上进行提交</h2><p>新建一个<code>readme.txt</code>文件，并保存</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick.</span><br></pre></td></tr></table></figure><p>然后<code>add</code>+<code>commit</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add readme.txt</span><br><span class="line">git commit -m <span class="string">&quot;branch test&quot;</span></span><br><span class="line"></span><br><span class="line">[dev 1cedf1e] branch <span class="built_in">test</span></span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><h2 id="将分支切回master"><a href="#将分支切回master" class="headerlink" title="将分支切回master"></a>将分支切回<code>master</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is up to date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br></pre></td></tr></table></figure><p>输入<code>ll</code>发现没有<code>readme.txt</code>文件</p><h2 id="使用git-merge-dev将dev合并到master分支上"><a href="#使用git-merge-dev将dev合并到master分支上" class="headerlink" title="使用git merge dev将dev合并到master分支上"></a>使用<code>git merge dev</code>将<code>dev</code>合并到<code>master</code>分支上</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge dev</span><br><span class="line"></span><br><span class="line">Updating bb6883d..1cedf1e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><p><code>Fast-forward</code>表示这次合并是“快进模式”，就是直接让<code>master</code>指向了<code>dev</code>当前的提交，所以合并速度很快，但并不是每次合并都能快进。</p><h2 id="合并完成，可以删除dev分支"><a href="#合并完成，可以删除dev分支" class="headerlink" title="合并完成，可以删除dev分支"></a>合并完成，可以删除<code>dev</code>分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d dev</span><br><span class="line"></span><br><span class="line">Deleted branch dev (was 1cedf1e).</span><br></pre></td></tr></table></figure><h2 id="使用git-branch查看结果"><a href="#使用git-branch查看结果" class="headerlink" title="使用git branch查看结果"></a>使用<code>git branch</code>查看结果</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h2 id="使用git-switch切换分支"><a href="#使用git-switch切换分支" class="headerlink" title="使用git switch切换分支"></a>使用<code>git switch</code>切换分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch -c dev <span class="comment"># 新建并切换到 dev 分支</span></span><br><span class="line"></span><br><span class="line">git switch master <span class="comment"># 切换到 master 分支</span></span><br></pre></td></tr></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>当Git 无法自动合并分支时，需要首先解决手动冲突。解决冲突后再提交合并。</p><h3 id="创建新分支feature1"><a href="#创建新分支feature1" class="headerlink" title="创建新分支feature1"></a>创建新分支<code>feature1</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch -c feature1</span><br><span class="line">Switched to a new branch <span class="string">&#x27;feature1&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="新分支修改-readme-txt"><a href="#新分支修改-readme-txt" class="headerlink" title="新分支修改 readme.txt"></a>新分支修改 <code>readme.txt</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick AND simple.</span><br></pre></td></tr></table></figure><h3 id="新分支上提交"><a href="#新分支上提交" class="headerlink" title="新分支上提交"></a>新分支上提交</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add readme.txt</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">&quot;AND simple&quot;</span></span><br><span class="line">[feature1 1843c86] AND simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><h3 id="切换到master分支"><a href="#切换到master分支" class="headerlink" title="切换到master分支"></a>切换到<code>master</code>分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 1 commit.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br></pre></td></tr></table></figure><h3 id="修改master分支中的readme-txt文件"><a href="#修改master分支中的readme-txt文件" class="headerlink" title="修改master分支中的readme.txt文件"></a>修改<code>master</code>分支中的<code>readme.txt</code>文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick &amp; simple.</span><br></pre></td></tr></table></figure><h3 id="在master分支中提交"><a href="#在master分支中提交" class="headerlink" title="在master分支中提交"></a>在<code>master</code>分支中提交</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add readme.txt</span><br><span class="line">git commit -m <span class="string">&quot;&amp; simple&quot;</span></span><br><span class="line">[master a737806] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><h3 id="尝试merge-feature1"><a href="#尝试merge-feature1" class="headerlink" title="尝试merge feature1"></a>尝试<code>merge feature1</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><h3 id="使用git-status查看冲突文件"><a href="#使用git-status查看冲突文件" class="headerlink" title="使用git status查看冲突文件"></a>使用<code>git status</code>查看冲突文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class="line">    both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="使用cat查看冲突内容"><a href="#使用cat查看冲突内容" class="headerlink" title="使用cat查看冲突内容"></a>使用<code>cat</code>查看冲突内容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat readme.txt</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">Creating a new branch is quick &amp; simple.</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">Creating a new branch is quick AND simple.</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span></span><br></pre></td></tr></table></figure><h3 id="手动修改冲突并提交"><a href="#手动修改冲突并提交" class="headerlink" title="手动修改冲突并提交"></a>手动修改冲突并提交</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add readme.txt</span><br><span class="line">git commit -m <span class="string">&quot;conflict fixed&quot;</span></span><br><span class="line">[master 20f6131] conflict fixed</span><br></pre></td></tr></table></figure><h3 id="使用git-log查看分支的合并情况"><a href="#使用git-log查看分支的合并情况" class="headerlink" title="使用git log查看分支的合并情况"></a>使用<code>git log</code>查看分支的合并情况</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   20f6131 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * 1843c86 (feature1) AND simple</span><br><span class="line">* | a737806 &amp; simple</span><br><span class="line">|/</span><br><span class="line">* 1cedf1e branch <span class="built_in">test</span></span><br><span class="line">* bb6883d (origin/master, origin/HEAD) remove readme.md</span><br><span class="line">* ab80813 StupidBoss</span><br><span class="line">* abd5bd8 append GPL</span><br><span class="line">* 38d23dd add distributed.</span><br><span class="line">* c81e9cb wrote a readme file.</span><br></pre></td></tr></table></figure><h3 id="最后可以删除feature1分支"><a href="#最后可以删除feature1分支" class="headerlink" title="最后可以删除feature1分支"></a>最后可以删除<code>feature1</code>分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d feature1</span><br></pre></td></tr></table></figure><h1 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h1><blockquote><p>通常，合并分支时，如果可能，Git 会使用<code>Fast Forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p></blockquote><h2 id="使用-no-ff的方式合并"><a href="#使用-no-ff的方式合并" class="headerlink" title="使用--no-ff的方式合并"></a>使用<code>--no-ff</code>的方式合并</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev</span><br><span class="line">Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>按照几个基本原则：</p><ol><li><p><code>master</code>分支应该是稳定上线的</p></li><li><p>在<code>dev</code>分支上进行开发工作，再把<code>dev</code>分支合并到<code>merge</code>上</p></li><li><p>每个人都在<code>dev</code>分支上进行开发，每个人都有自己的分支，时不时往<code>dev</code>分支进行合并</p></li></ol><h1 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a><code>Bug</code>分支</h1><p>准备修复<code>bug</code>前，先要把自己的工作状态保存起来</p><h2 id="使用git-stash保存当前工作现场"><a href="#使用git-stash保存当前工作现场" class="headerlink" title="使用git stash保存当前工作现场"></a>使用<code>git stash</code>保存当前工作现场</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash</span><br><span class="line">Saved working directory and index state WIP on master: 20f6131 conflict fixed</span><br></pre></td></tr></table></figure><h2 id="确定要修复bug的分支"><a href="#确定要修复bug的分支" class="headerlink" title="确定要修复bug的分支"></a>确定要修复<code>bug</code>的分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch master</span><br><span class="line">git switch -c issue-101 <span class="comment"># 从 master 分支创建了一个临时分支</span></span><br></pre></td></tr></table></figure><h2 id="修复bug后进行提交合并"><a href="#修复bug后进行提交合并" class="headerlink" title="修复bug后进行提交合并"></a>修复<code>bug</code>后进行提交合并</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add readme.txt</span><br><span class="line">git commit -m <span class="string">&quot;fix bug 101&quot;</span></span><br></pre></td></tr></table></figure><h2 id="修复完成，切换到master分支合并，然后删除issue"><a href="#修复完成，切换到master分支合并，然后删除issue" class="headerlink" title="修复完成，切换到master分支合并，然后删除issue"></a>修复完成，切换到<code>master</code>分支合并，然后删除<code>issue</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch master</span><br><span class="line">git merge --no-ff -m <span class="string">&quot;merged bug fix 101&quot;</span> issue-101</span><br></pre></td></tr></table></figure><h2 id="恢复工作现场"><a href="#恢复工作现场" class="headerlink" title="恢复工作现场"></a>恢复工作现场</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch dev</span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p>使用<code>git stash list</code>查看</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><ol><li><p>使用<code>git stash apply</code>恢复，需要手动使用<code>git stash drop</code>删除</p></li><li><p>使用<code>git stash pop</code>恢复，同时自动删除了<code>stash</code>内容</p></li></ol><h2 id="将master修复的bug合并到dev上"><a href="#将master修复的bug合并到dev上" class="headerlink" title="将master修复的bug合并到dev上"></a>将<code>master</code>修复的<code>bug</code>合并到<code>dev</code>上</h2><p>使用<code>git cherry-pick</code>将一个特定的提交复制到当前分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">git cherry-pick 4c805e2</span><br><span class="line">[master 1d4b803] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><h1 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a><code>Feature</code>分支</h1><p>每添加一个新的功能，最好新建一个<code>feature</code>分支，在上面的开发完成后，合并，最后删除该<code>feature</code>分支</p><h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch -c feature-vulcan</span><br></pre></td></tr></table></figure><h2 id="feature分支与dev分支合并"><a href="#feature分支与dev分支合并" class="headerlink" title="feature分支与dev分支合并"></a><code>feature</code>分支与<code>dev</code>分支合并</h2><p>一切没问题后，切换到<code>dev</code>分支并合并</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch dev</span><br><span class="line">git merge feature-vulcan</span><br></pre></td></tr></table></figure><h3 id="若想要删除未合并的分支"><a href="#若想要删除未合并的分支" class="headerlink" title="若想要删除未合并的分支"></a>若想要删除未合并的分支</h3><p>使用<code>git branch -D feature-vulcan</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -D feature-vulcan</span><br></pre></td></tr></table></figure><h1 id="多人协作开发"><a href="#多人协作开发" class="headerlink" title="多人协作开发"></a>多人协作开发</h1><p>多人协作的工作模式通常是：</p><ol><li><p>尝试使用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p></li><li><p>如果推送失败，使用<code>git pull</code>试图合并；</p></li><li><p>如果合并有冲突，则解决冲突，并在本地提交；</p></li><li><p>没有冲突或者解决掉冲突以后，再用<code>git push origin &lt;branch-name&gt;</code>推送成功；</p></li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，说明本地分支和远程分支的链接关系没有创建，使用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code></p><h1 id="Rebase操作"><a href="#Rebase操作" class="headerlink" title="Rebase操作"></a><code>Rebase</code>操作</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase</span><br></pre></td></tr></table></figure><ul><li><p>操作特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分支提交已经被修改过了</p></li><li><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p></li></ul><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><blockquote><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p></blockquote><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><ol><li><p>切换到需要打标签的分支上</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch master</span><br></pre></td></tr></table></figure></li><li><p>使用<code>git tag &lt;name&gt;</code>打一个新标签</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></table></figure></li><li><p>使用<code>git tag</code>查看所有标签</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></li><li><p>使用<code>git tag &lt;tagname&gt; &lt;commit id&gt;</code>可以对指定的<code>commit</code>打上<code>tag</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag v0.9 f52c633</span><br></pre></td></tr></table></figure></li><li><p>标签是按照字母排序列出的。<code>git show &lt;tagname&gt;</code>可以查看标签信息</p><p>可以创建带有说明的标签，使用<code>-a</code>指定标签名，<code>-m</code>指定说明文字</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -a v0.1 -m <span class="string">&quot;version 0.1 released&quot;</span> 1094adb</span><br></pre></td></tr></table></figure></li></ol><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><ol><li><p>删除标签</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -d v0.1</span><br></pre></td></tr></table></figure></li><li><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p></li><li><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin &lt;tagname&gt;</span><br></pre></td></tr></table></figure></li><li><p>一次性推送所有本地标签</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure></li><li><p>从远程删除标签</p><p>先从本地删除：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;</span><br></pre></td></tr></table></figure><p>然后从远程删除</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin :refs/tags/&lt;tagname&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Git的网站"><a href="#Git的网站" class="headerlink" title="Git的网站"></a><code>Git</code>的网站</h1><ul><li><p><a href="https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf">Git Cheat Sheet</a></p></li><li><p><a href="http://git-scm.com/">Git 官方网站</a></p></li></ul><h1 id="2020-9-20更新"><a href="#2020-9-20更新" class="headerlink" title="2020.9.20更新"></a>2020.9.20更新</h1><h2 id="git删除远程文件（保留本地）"><a href="#git删除远程文件（保留本地）" class="headerlink" title="git删除远程文件（保留本地）"></a>git删除远程文件（保留本地）</h2><h3 id="预览（不删除）"><a href="#预览（不删除）" class="headerlink" title="预览（不删除）"></a>预览（不删除）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm -r -n --cached 文件/文件夹名称 </span><br></pre></td></tr></table></figure><h3 id="确定无误后删除文件"><a href="#确定无误后删除文件" class="headerlink" title="确定无误后删除文件"></a>确定无误后删除文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm -r --cached 文件/文件夹名称</span><br></pre></td></tr></table></figure><h3 id="提交并推送至远程服务器"><a href="#提交并推送至远程服务器" class="headerlink" title="提交并推送至远程服务器"></a>提交并推送至远程服务器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;提交说明&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-1144</title>
      <link href="2020/07/12/Leetcode-1144/"/>
      <url>2020/07/12/Leetcode-1144/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>nums</code>，每次 操作 会从中选择一个元素并 将该元素的值减少 1。</p><p>如果符合下列情况之一，则数组 A 就是 锯齿数组：</p><p>每个偶数索引对应的元素都大于相邻的元素，即 <code>A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; ...</code><br>或者，每个奇数索引对应的元素都大于相邻的元素，即 <code>A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; ...</code><br>返回将数组 nums 转换为锯齿数组所需的最小操作次数。</p><p><strong>示例 1：</strong></p><p>输入：nums = [1,2,3]<br>输出：2<br>解释：我们可以把 2 递减到 0，或把 3 递减到 1。</p><p><strong>示例 2：</strong></p><p>输入：nums = [9,6,1,6,2]<br>输出：4 </p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>分情况讨论，根据题目，锯齿状数组有一个很明显的特征，就是要么奇下标的元素全是小的，要么偶下标的元素全是小的，我们只需要把两种调整所需要的操作数算出来，取小的即可</p><p>比如对于每个奇数位<code>i%2==0</code>，我们想要把数组调整成每个奇数位都更小，则我们需要比较<code>a[i]</code>与 <code>a[i-1]</code>、<code>a[i+1]</code>的差。如果<code>a[i]&gt;=a[i-1]</code>则说明需要进行调整，调整的大小很容易能想到，为<code>a[i]-a[i-1]+1</code>，因为我们需要调整成严格的<code>a[i]&lt;a[i-1]</code></p><p>对于偶数位也同样如此</p><p>下面直接给出代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movesToMakeZigzag</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans1, ans2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 奇数位置</span></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                d1 = nums[i] - nums[i - <span class="number">1</span>] + <span class="number">1</span> <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] &gt;= nums[i - <span class="number">1</span>] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                d2 = nums[i] - nums[i + <span class="number">1</span>] + <span class="number">1</span> <span class="keyword">if</span> i &lt; n - <span class="number">1</span> <span class="keyword">and</span> nums[i] &gt;= nums[i + <span class="number">1</span>] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                ans1 += <span class="built_in">max</span>(d1, d2)</span><br><span class="line">            <span class="comment"># 偶数位置</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d1 = nums[i] - nums[i - <span class="number">1</span>] + <span class="number">1</span> <span class="keyword">if</span> nums[i] &gt;= nums[i - <span class="number">1</span>] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                d2 = nums[i] - nums[i + <span class="number">1</span>] + <span class="number">1</span> <span class="keyword">if</span> i &lt; n - <span class="number">1</span> <span class="keyword">and</span> nums[i] &gt;= nums[i + <span class="number">1</span>] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                ans2 += <span class="built_in">max</span>(d1, d2)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(ans1, ans2)</span><br></pre></td></tr></table></figure><blockquote><p>题目来源：<a href="https://leetcode-cn.com/problems/decrease-elements-to-make-array-zigzag">https://leetcode-cn.com/problems/decrease-elements-to-make-array-zigzag</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-1343</title>
      <link href="2020/07/11/Leetcode-1343/"/>
      <url>2020/07/11/Leetcode-1343/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>arr</code> 和两个整数 <code>k</code> 和 <code>threshold</code> 。</p><p>请你返回长度为 <code>k</code> 且平均值大于等于 <code>threshold</code> 的子数组数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,2,2,2,5,5,5,8], k &#x3D; 3, threshold &#x3D; 4</span><br><span class="line">输出：3</span><br><span class="line">解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6。</span><br><span class="line">其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,1,1,1,1], k &#x3D; 1, threshold &#x3D; 0</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [11,13,17,23,29,31,7,5,2,3], k &#x3D; 3, threshold &#x3D; 5</span><br><span class="line">输出：6</span><br><span class="line">解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [7,7,7,7,7,7,7], k &#x3D; 7, threshold &#x3D; 7</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [4,4,4,4], k &#x3D; 4, threshold &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>双指针/滑动窗口（使用双指针可以避免计算偏移量）</p><p>要注意计算和的时候应该利用已知的信息，不然重复计算和会导致超时；</p><p>所以我们可以进行 <strong>两次遍历</strong></p><p>第一次：计算和数组（即长度为 k 的子数组的和）</p><p>第二次：计算和数组的平均值（<code>sun_array[i]/k</code>和阈值进行比较即可）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numOfSubArrays</span>(<span class="params">self, arr: List[<span class="built_in">int</span>], k: <span class="built_in">int</span>, threshold: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        i, j = <span class="number">0</span>, k</span><br><span class="line">        sum_array = [<span class="built_in">sum</span>(arr[i:j])]</span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(arr):</span><br><span class="line">            sum_array.append(sum_array[i] - arr[i] + arr[j]) <span class="comment"># 利用已知信息计算和数组</span></span><br><span class="line">            i, j = i + <span class="number">1</span>, j + <span class="number">1</span></span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        <span class="comment"># print(sum_array)</span></span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> sum_array:</span><br><span class="line">            <span class="keyword">if</span> element / k &gt;= threshold:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> counter</span><br></pre></td></tr></table></figure><blockquote><p>题目来源：<a href="https://leetcode-cn.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/">https://leetcode-cn.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4o8-数据结构-线性表</title>
      <link href="2020/07/07/4o8-DataStructure-Linear-List/"/>
      <url>2020/07/07/4o8-DataStructure-Linear-List/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="本章知识框架"><a href="#本章知识框架" class="headerlink" title="本章知识框架"></a>本章知识框架</h1><img title="" src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/linear-list.png" alt="" data-align="center"><h1 id="线性表的定义和基本操作"><a href="#线性表的定义和基本操作" class="headerlink" title="线性表的定义和基本操作"></a>线性表的定义和基本操作</h1><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><blockquote><p>线性表是具有相同数据类型的$n(n≥0)$个元素的有限序列，其中$n$为表长，当$n=0$时，线性表为空</p></blockquote><h2 id="线性表（逻辑）特性"><a href="#线性表（逻辑）特性" class="headerlink" title="线性表（逻辑）特性"></a>线性表（逻辑）特性</h2><ul><li><p>数据元素个数有限；</p></li><li><p>数据元素逻辑上有先后次序；</p></li><li><p>除了第一个元素外，所有元素均有唯一直接前驱；</p></li><li><p>除了最后一个元素外，所有元素均有唯一直接后继；</p></li><li><p>每个元素数据类型都相同，意味着它们占据相同大小的存储空间。</p></li></ul><h2 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h2><blockquote><p>一个数据结构的基本操作是指：其最核心、最基本的操作，其他较复杂的操作均可通过调用这些基本操作来实现。</p></blockquote><p>线性表的基本操作如下：</p><table><thead><tr><th>操作名称</th><th>操作含义</th></tr></thead><tbody><tr><td><code>InitList(&amp;L)</code></td><td>初始化一个线性表</td></tr><tr><td><code>Length(L)</code></td><td>返回线性表长度</td></tr><tr><td><code>LocateElem(L,e)</code></td><td>按值（关键字）查找元素</td></tr><tr><td><code>GetElem(L,i)</code></td><td>按位查找元素</td></tr><tr><td><code>ListInsert(&amp;L,i,e)</code></td><td>在指定位置插入元素 e</td></tr><tr><td><code>ListDelete(&amp;L,i,&amp;e)</code></td><td>删除指定位置的元素，e 用来返回结果</td></tr><tr><td><code>PrintList(L)</code></td><td>遍历输出线性表</td></tr><tr><td><code>Empty(L)</code></td><td>判断线性表是否为空</td></tr><tr><td><code>DestroyList(&amp;L)</code></td><td>销毁线性表，清空元素</td></tr></tbody></table><h1 id="顺序表的定义与实现"><a href="#顺序表的定义与实现" class="headerlink" title="顺序表的定义与实现"></a>顺序表的定义与实现</h1><h2 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h2><blockquote><p>线性表的顺序存储称为顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，逻辑上相邻的元素在物理位置上同样相邻。</p></blockquote><h2 id="顺序表的特点"><a href="#顺序表的特点" class="headerlink" title="顺序表的特点"></a>顺序表的特点</h2><ul><li>存储结构上，每个元素所占的大小空间均为 <code>sizeof(ElemType)</code>的大小</li><li>所占的地址空间是连续的，与逻辑结构与顺序相同。</li></ul><h2 id="顺序表的-C-实现"><a href="#顺序表的-C-实现" class="headerlink" title="顺序表的 C++实现"></a>顺序表的 C++实现</h2><p>具体实现请移步<a class="btn-beautify button--animated blue larger" href="https://github.com/jzhmcoo1/4o8/tree/master/数据结构/code/SqList"   title="4o8"><i class="far fa-hand-point-right fa-fw"></i><span>4o8</span></a></p><h1 id="单链表的定义与实现"><a href="#单链表的定义与实现" class="headerlink" title="单链表的定义与实现"></a>单链表的定义与实现</h1><h2 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h2><blockquote><p>线性表的链式存储结构又称单链表，通过一组任意的存储单元来存放线性表中的数据元素。单链表的结点结构分为：数据域和指针域。</p></blockquote><h2 id="单链表的特点"><a href="#单链表的特点" class="headerlink" title="单链表的特点"></a>单链表的特点</h2><ul><li><p>元素离散地分布在存储空间中，属于非随机存储的存储结构（查找一个结点时需要从头至尾进行遍历）</p></li><li><p>一般通过头指针来表示一个单链表，为了操作的方便，有时也加入头节点。</p></li></ul><h3 id="关于头节点的优点"><a href="#关于头节点的优点" class="headerlink" title="关于头节点的优点"></a>关于头节点的优点</h3><ol><li><p>当单链表为空时，不需要特殊处理，头指针永远指向头结点。</p></li><li><p>单链表的第一个（有效结点）的位置被存放在头结点的指针域内，即处理第一个有效结点时不需要特殊处理。</p></li></ol><h2 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h2><p>具体实现请移步<a class="btn-beautify button--animated blue larger" href="https://github.com/jzhmcoo1/4o8/tree/master/数据结构/code/LinkedList"   title="4o8"><i class="far fa-hand-point-right fa-fw"></i><span>4o8</span></a></p><h1 id="其他线性链表"><a href="#其他线性链表" class="headerlink" title="其他线性链表"></a>其他线性链表</h1><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>单链表的结点结构中，只有指向直接后继结点的指针，使得单链表只能从头至尾依次顺序地遍历，访问某个结点的前驱结点（插入，删除操作时），只能从头遍历，时间复杂度为$O(n)$</p><p>为了克服以上单链表的缺点，引入了双链表。</p><p>双链表结点的指针域引入了前驱指针，即存在两个指针<code>prior</code>和<code>next</code>，分别指向直接前驱结点和直接后继结点。</p><h3 id="双链表的结点类型描述"><a href="#双链表的结点类型描述" class="headerlink" title="双链表的结点类型描述"></a>双链表的结点类型描述</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> * <span class="title">prior</span>, * <span class="title">next</span>;</span></span><br><span class="line">&#125;DNode, *DLinkedlist;</span><br></pre></td></tr></table></figure><h3 id="双链表的插入、删除操作"><a href="#双链表的插入、删除操作" class="headerlink" title="双链表的插入、删除操作"></a>双链表的插入、删除操作</h3><ol><li>插入</li></ol><img title="" src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/insertDLink.gif" alt="" data-align="center" width="756"><p>如图所示，<code>S</code>指针指向待插入的结点，<code>P</code>指针指向插入位置的前驱结点，</p><p>指针的变化过程如上图所示</p><p>插入过程的代码如下所示</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将结点 *s 插入 *p 之后</span></span><br><span class="line">s-&gt;next = p-&gt;next;   <span class="comment">//1</span></span><br><span class="line">p-&gt;next-&gt;prior = s;  <span class="comment">//2</span></span><br><span class="line">s-&gt;prior = p;        <span class="comment">//3</span></span><br><span class="line">p-&gt;next = s;         <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>其中第四步必须在 一、二、两步之后</p><ol start="2"><li>删除</li></ol><img title="" src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/deleteDLink.gif" alt="" data-align="center" width="768"><p>指针的变化过程过程如上图所示</p><p>删除过程的代码如下所示</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h1 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h1><table><thead><tr><th align="left">方面</th><th align="left">顺序表</th><th align="left">单链表</th></tr></thead><tbody><tr><td align="left">存取方式</td><td align="left">顺序存取、随机存取</td><td align="left">只能顺序存取</td></tr><tr><td align="left">逻辑结构<br/>与物理结构</td><td align="left">逻辑上相邻，物理位置也相邻</td><td align="left">逻辑上相邻的元素，物理上不一定相邻</td></tr><tr><td align="left">查找、插入、删除操作</td><td align="left">无序时$O(n)$<br/>有序时$O(log_2n)$（折半查找）</td><td align="left">$O(n)$</td></tr><tr><td align="left">空间分配</td><td align="left">静态分配：若分配空间太小导致溢出，若分配过大导致多余空间限制<br/>动态分配：虽然可以扩充空间，但需要移动大量元素，效率降低，若内存中没有足够空间则会分配失败。</td><td align="left">只需要在申请的时候分配空间，只要有内存空间就可以分配，操作灵活</td></tr></tbody></table><h1 id="如何选择这两种存储结构"><a href="#如何选择这两种存储结构" class="headerlink" title="如何选择这两种存储结构"></a>如何选择这两种存储结构</h1><ol><li><p>基于存储的考虑</p><p>难以估计线性表的长度或存储规模时，不宜采用顺序表；但链表的存储密度低，指针占据了很大空间</p></li><li><p>基于运算的考虑</p><ul><li><p>顺序表可以随机访问，而链表仅能顺序访问，若经常需要随机读线性表中的元素，则顺序表更优。</p></li><li><p>顺序表中插入、删除元素时，平均情况下需要移动一半的元素，而链表主要进行的是比较操作，从此角度考虑则链表更优</p></li></ul></li><li><p>基于环境的考虑</p><p>顺序表实现容易，在任何高级语言中都有数组类型；</p><p>链表是基于指针的，相对来说前者实现更简单。</p></li></ol><p><strong>通常来说</strong>，较稳定的线性表选择顺序表，需要频繁插入、删除操作的线性表选择链表。</p>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4o8-数据结构-绪论</title>
      <link href="2020/07/07/4o8-DataStructure-xulun/"/>
      <url>2020/07/07/4o8-DataStructure-xulun/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="绪论知识框架"><a href="#绪论知识框架" class="headerlink" title="绪论知识框架"></a>绪论知识框架</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/ds_xulun.png" alt="绪论知识框架图"></p><h1 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h1><h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><ol><li><p>数据</p><blockquote><p>数据是对客观事物的符号表示，在计算机科学中是指所有能够输入到计算机中，并被计算机程序所处理的符号的总称。</p></blockquote></li><li><p>数据元素</p><blockquote><p>是数据的基本单位，计算机程序中通常考虑成一个整体进行处理。</p><p>通常若干个数据项组成一个数据元素。</p><p>数据项是数据的不可分割的最小单位。</p></blockquote></li><li><p>数据对象</p><blockquote><p>是性质相同的数据元素的集合，是数据的一个子集。</p></blockquote></li><li><p>数据结构</p><blockquote><p>是相互之间存在一种或多种特定关系的数据元素的集合</p></blockquote></li></ol><p>在任何问题中，数据元素都不是孤立存在的，他们之间存在的某种相互之间的关系称为结构</p><h2 id="数据（逻辑）结构"><a href="#数据（逻辑）结构" class="headerlink" title="数据（逻辑）结构"></a>数据（逻辑）结构</h2><ol><li><p>线性结构</p><p> 数据元素存在着 <strong>一对一关系</strong></p><p> 如：线性表、栈和队列、串、数组、广义表</p></li><li><p>非线性结构</p><ul><li><p>集合</p><p>  数据元素除了“同属于一个集合”的关系外，没有其他关系</p></li><li><p>树形结构</p><p>  数据元素存在着 <strong>一对多关系</strong></p></li><li><p>图状结构</p><p>  数据元素存在着 <strong>多对多关系</strong></p></li></ul></li></ol><p>数据结构的形式定义为：$DataStructure = (D,S)$</p><p>其中：D 为<strong>数据元素的有限集合</strong>，S 是 D 上<strong>关系的有限集合</strong>。</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><blockquote><p>数据结构在计算机中的表示，称为物理结构，又称存储结构。它包括<strong>数据元素的表示</strong>和<strong>关系的表示</strong>。</p></blockquote><ol><li><p>顺序存储结构</p><p> 特点：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。</p></li><li><p>链式存储结构</p><p> 特点：借助指示元素存储地址的指针（pointer）来表示数据元素直接的逻辑关系。</p></li></ol><p>王道考研书将存储结构分为 4 类，多加了索引存储结构和散列存储结构，而教科书上只列出了两类，我个人认为原因可能是：这两类是由顺序存储和链式存储这两个基本的存储结构所拓展出来的，而基本的存储结构只有顺序和链式两类。</p><blockquote><p>任何一个算法的<strong>设计</strong>，取决于选定的<strong>数据（逻辑）结构</strong>；</p><p>任何一个算法的<strong>实现</strong>，依赖于采用的<strong>存储结构</strong>。</p></blockquote><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><blockquote><p>抽象数据类型（Abstract Data Type，简称 ADT）是指<strong>一个数学模型</strong>以及定义在该模型上的<strong>一组操作</strong>。</p><p>ADT 的定义仅取决于它的逻辑特性，与在计算机内部如何表示和实现无关。</p></blockquote><p>和数据结构的形式定义相对应，抽象数据类型可以用以下三元组表示<br>$$<br>(D,S,P)<br>$$<br>其中，D 是数据对象，S 是 D 上的关系集，P 是对 D 的基本操作集。</p><p>表示为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADT 抽象数据类型名称&#123;</span><br><span class="line">数据对象 D:&lt;数据对象的定义&gt;</span><br><span class="line">数据关系 S:&lt;数据关系的定义&gt;</span><br><span class="line">基本操作 P:&lt;基本操作的定义&gt;</span><br><span class="line">&#125;ADT 抽象数据类型名称</span><br></pre></td></tr></table></figure><h1 id="算法和算法效率分析"><a href="#算法和算法效率分析" class="headerlink" title="算法和算法效率分析"></a>算法和算法效率分析</h1><h2 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h2><blockquote><p>算法（algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作。</p></blockquote><h2 id="算法的五大特性"><a href="#算法的五大特性" class="headerlink" title="算法的五大特性"></a>算法的五大特性</h2><ol><li><p>有穷性</p><p> 一个算法必须在执行完有穷步后结束，每一步完成的时间也是有穷的。</p></li><li><p>确定性</p><p> 每一条指令必须无二义性，且相同的输入只能得到相同的输出。</p></li><li><p>可行性</p><p> 算法中描述的操作都是可以通过实现基本运算来执行有限次实现的。</p></li><li><p>输入</p><p> 一个算法有 0 个或多个输入，取自于某个特定的对象的集合。</p></li><li><p>输出</p><p> 一个算法有 1 个或多个输出，同输入有着一定关系的量。</p></li></ol><h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><ol><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效率和低存储量的需求</li></ol><h2 id="算法效率的度量"><a href="#算法效率的度量" class="headerlink" title="算法效率的度量"></a>算法效率的度量</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>算法的执行时间取决于很多因素，如：算法选取的策略，问题的规模，何种编程语言，机器的执行指令的速度等。</p><p>这表明：使用绝对的运行时间来评价算法的执行效率是不合适的。</p><p>通常的做法是：对于同一问题的不同算法，选取算法中 <strong>基本操作被重复执行的次数</strong> 来作为算法的时间量度。</p><p>记算法中基本操作被重复执行的次数为问题规模$n$的某个函数$f(n)$，则算法的时间量度为：<br>$$<br>T(n) = O(f(n))<br>$$<br>称为<strong>算法的时间复杂度</strong></p><h4 id="平均时间复杂度和最坏时间复杂度"><a href="#平均时间复杂度和最坏时间复杂度" class="headerlink" title="平均时间复杂度和最坏时间复杂度"></a>平均时间复杂度和最坏时间复杂度</h4><p>有些算法，比如冒泡排序，基本操作重复执行的次数还随着问题的输入数据集的不同而不同。</p><p>对于这类算法的分析，一种方法时计算平均时间复杂度，即考虑它所有可能的输入数据集的期望值；</p><p>另一种方法是计算最坏情况下的时间复杂度，即最坏情况下，估算算法执行时间的上界。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>类似于时间复杂度，空间复杂度（Space Complexity）记作：<br>$$<br>S(n) = O(f(n))<br>$$<br>其中，$n$为问题的规模。</p><p>包括了存储程序本身（指令、常量、变量、输入数据）的<strong>存储空间</strong>，和一些算法中用作实现计算的<strong>辅助变量空间</strong>。</p><blockquote><p> 若输入数据所占的空间只取决于问题本身，和算法无关，则只需要分析除输入数据和程序之外的额外空间，否则应同时考虑输入本身所需空间（和输入数据的表示形式有关）。</p></blockquote><h4 id="原地工作"><a href="#原地工作" class="headerlink" title="原地工作"></a>原地工作</h4><p>若额外空间相对于输入数据量来说是常数，则称次算法为 <strong>原地工作</strong>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《王道数据结构考研复习指导》</li><li>《数据结构 （C 语言版）》严蔚敏</li></ul>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4o8-概述</title>
      <link href="2020/07/07/4o8/"/>
      <url>2020/07/07/4o8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="4o8-是什么？"><a href="#4o8-是什么？" class="headerlink" title="4o8 是什么？"></a>4o8 是什么？</h1><p>既然已经下定决心考研，不如早点开始做准备了，目前已是大二暑假，不能浪费这黄金时间，打算开始着手准备考研科目。4o8 是我为准备 408 考试而准备的项目，我将会在考研前将一些我认为的考试的重点和复习中解决的问题进行归纳整理，总结的不完整或者有问题的地方可以指出，总之，一起学习一起进步，共勉，peace。</p><h1 id="4o8-项目地址"><a href="#4o8-项目地址" class="headerlink" title="4o8 项目地址"></a>4o8 项目地址</h1><a class="btn-beautify button--animated blue larger" href="https://github.com/jzhmcoo1/4o8"   title="4o8"><i class="far fa-hand-point-right fa-fw"></i><span>4o8</span></a><div class="note info flat"><p>我会将对应科目的考点进行罗列，并进行讲解与分析，所谓最好的输入就是输出，希望我在掌握了以后，能够用我自己的语言表达出来。本来是想都放在 github 上的，但是 github 的 md 语法不支持数学公式，所以决定把理论部分都放到个人博客上来，github 作代码仓。</p><p>注：以下部分来自于 2020 年的考纲，打*的章节不在考纲范围，但往往有助于理解</p></div><hr><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="一、绪论"><a href="#一、绪论" class="headerlink" title="*一、绪论"></a><a href="/2020/07/07/4o8-DataStructure-xulun">*一、绪论</a></h2><h3 id="（一）数据结构的基本概念"><a href="#（一）数据结构的基本概念" class="headerlink" title="（一）数据结构的基本概念"></a>（一）<a href="/2020/07/07/4o8-DataStructure-xulun/#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">数据结构的基本概念</a></h3><ul><li>数据、数据元素、数据对象、数据类型、数据结构</li><li>数据结构三要素<ol><li>逻辑结构</li><li>存储结构</li><li>数据的运算</li></ol></li></ul><h3 id="（二）算法和算法效率的评价"><a href="#（二）算法和算法效率的评价" class="headerlink" title="（二）算法和算法效率的评价"></a>（二）<a href="/2020/07/07/4o8-DataStructure-xulun/#%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90">算法和算法效率的评价</a></h3><ul><li>算法定义</li><li>算法的五大特征<ul><li>有穷性</li><li>确定性</li><li>可行性</li><li>输入</li><li>输出</li></ul></li><li>效率的度量<ul><li>时间复杂度</li><li>空间复杂度</li></ul></li></ul><h2 id="二、线性表"><a href="#二、线性表" class="headerlink" title="二、线性表"></a>二、线性表</h2><h3 id="（一）线性表的定义和基本操作"><a href="#（一）线性表的定义和基本操作" class="headerlink" title="（一）线性表的定义和基本操作"></a>（一）线性表的定义和基本操作</h3><h3 id="（二）线性表的实现"><a href="#（二）线性表的实现" class="headerlink" title="（二）线性表的实现"></a>（二）线性表的实现</h3><ol><li>顺序存储</li><li>链式存储</li><li>线性表的应用</li></ol><h2 id="三、栈、队列和数组"><a href="#三、栈、队列和数组" class="headerlink" title="三、栈、队列和数组"></a>三、栈、队列和数组</h2><h3 id="（一）栈和队列的基本概念"><a href="#（一）栈和队列的基本概念" class="headerlink" title="（一）栈和队列的基本概念"></a>（一）栈和队列的基本概念</h3><h3 id="（二）栈和队列的顺序存储结构"><a href="#（二）栈和队列的顺序存储结构" class="headerlink" title="（二）栈和队列的顺序存储结构"></a>（二）栈和队列的顺序存储结构</h3><h3 id="（三）栈和队列的链式存储结构"><a href="#（三）栈和队列的链式存储结构" class="headerlink" title="（三）栈和队列的链式存储结构"></a>（三）栈和队列的链式存储结构</h3><h3 id="（四）栈和队列的应用"><a href="#（四）栈和队列的应用" class="headerlink" title="（四）栈和队列的应用"></a>（四）栈和队列的应用</h3><h3 id="（五）特殊矩阵的压缩存储"><a href="#（五）特殊矩阵的压缩存储" class="headerlink" title="（五）特殊矩阵的压缩存储"></a>（五）特殊矩阵的压缩存储</h3><h2 id="四、树与二叉树"><a href="#四、树与二叉树" class="headerlink" title="四、树与二叉树"></a>四、树与二叉树</h2><h3 id="（一）树的基本概念"><a href="#（一）树的基本概念" class="headerlink" title="（一）树的基本概念"></a>（一）树的基本概念</h3><h3 id="（二）二叉树"><a href="#（二）二叉树" class="headerlink" title="（二）二叉树"></a>（二）二叉树</h3><ol><li>二叉树的定义及其主要特征</li><li>二叉树的顺序存储结构和链式存储结构</li><li>二叉树的遍历</li><li>线索二叉树的基本概念和构造</li></ol><h3 id="（三）树、森林"><a href="#（三）树、森林" class="headerlink" title="（三）树、森林"></a>（三）树、森林</h3><ol><li>树的存储结构</li><li>森林与二叉树的转换</li><li>树和森林的遍历</li></ol><h3 id="（四）树与二叉树的应用"><a href="#（四）树与二叉树的应用" class="headerlink" title="（四）树与二叉树的应用"></a>（四）树与二叉树的应用</h3><ol><li>二叉排序树</li><li>平衡二叉树</li><li>哈夫曼（Huffman）树和哈夫曼编码</li></ol><h2 id="五、图"><a href="#五、图" class="headerlink" title="五、图"></a>五、图</h2><h3 id="（一）图的基本概念"><a href="#（一）图的基本概念" class="headerlink" title="（一）图的基本概念"></a>（一）图的基本概念</h3><h3 id="（二）图的存储及基本操作"><a href="#（二）图的存储及基本操作" class="headerlink" title="（二）图的存储及基本操作"></a>（二）图的存储及基本操作</h3><ol><li>邻接矩阵法</li><li>邻接表法</li><li>邻接多重表、十字链表</li></ol><h3 id="（三）图的遍历"><a href="#（三）图的遍历" class="headerlink" title="（三）图的遍历"></a>（三）图的遍历</h3><ol><li>深度优先搜索</li><li>广度优先搜索</li></ol><h3 id="（四）图的基本应用"><a href="#（四）图的基本应用" class="headerlink" title="（四）图的基本应用"></a>（四）图的基本应用</h3><ol><li>最小生成树</li><li>最短路径</li><li>拓扑排序</li><li>关键路径</li></ol><h2 id="六、查找"><a href="#六、查找" class="headerlink" title="六、查找"></a>六、查找</h2><h3 id="（一）查找的基本概念"><a href="#（一）查找的基本概念" class="headerlink" title="（一）查找的基本概念"></a>（一）查找的基本概念</h3><h3 id="（二）顺序查找法"><a href="#（二）顺序查找法" class="headerlink" title="（二）顺序查找法"></a>（二）顺序查找法</h3><h3 id="（三）分块查找法"><a href="#（三）分块查找法" class="headerlink" title="（三）分块查找法"></a>（三）分块查找法</h3><h3 id="（四）拆半查找法"><a href="#（四）拆半查找法" class="headerlink" title="（四）拆半查找法"></a>（四）拆半查找法</h3><h3 id="（五）B-树及其基本操作、B-树的基本概念"><a href="#（五）B-树及其基本操作、B-树的基本概念" class="headerlink" title="（五）B 树及其基本操作、B+树的基本概念"></a>（五）B 树及其基本操作、B+树的基本概念</h3><h3 id="（六）散列（Hash）表"><a href="#（六）散列（Hash）表" class="headerlink" title="（六）散列（Hash）表"></a>（六）散列（Hash）表</h3><h3 id="（七）字符串模式匹配"><a href="#（七）字符串模式匹配" class="headerlink" title="（七）字符串模式匹配"></a>（七）字符串模式匹配</h3><h3 id="（八）查找算法的分析及其应用"><a href="#（八）查找算法的分析及其应用" class="headerlink" title="（八）查找算法的分析及其应用"></a>（八）查找算法的分析及其应用</h3><h2 id="七、排序"><a href="#七、排序" class="headerlink" title="七、排序"></a>七、排序</h2><h3 id="（一）排序的基本概念"><a href="#（一）排序的基本概念" class="headerlink" title="（一）排序的基本概念"></a>（一）排序的基本概念</h3><h3 id="（二）插入排序"><a href="#（二）插入排序" class="headerlink" title="（二）插入排序"></a>（二）插入排序</h3><ol><li>直接插入排序</li><li>拆半插入排序</li></ol><h3 id="（三）起泡排序（BubbleSort）"><a href="#（三）起泡排序（BubbleSort）" class="headerlink" title="（三）起泡排序（BubbleSort）"></a>（三）起泡排序（BubbleSort）</h3><h3 id="（四）简单选择排序"><a href="#（四）简单选择排序" class="headerlink" title="（四）简单选择排序"></a>（四）简单选择排序</h3><h3 id="（五）希尔排序（ShellSort）"><a href="#（五）希尔排序（ShellSort）" class="headerlink" title="（五）希尔排序（ShellSort）"></a>（五）希尔排序（ShellSort）</h3><h3 id="（六）快速排序"><a href="#（六）快速排序" class="headerlink" title="（六）快速排序"></a>（六）快速排序</h3><h3 id="（七）堆排序"><a href="#（七）堆排序" class="headerlink" title="（七）堆排序"></a>（七）堆排序</h3><h3 id="（八）二路归并排序（MergeSort）"><a href="#（八）二路归并排序（MergeSort）" class="headerlink" title="（八）二路归并排序（MergeSort）"></a>（八）二路归并排序（MergeSort）</h3><h3 id="（九）基数排序"><a href="#（九）基数排序" class="headerlink" title="（九）基数排序"></a>（九）基数排序</h3><h3 id="（十）外部排序"><a href="#（十）外部排序" class="headerlink" title="（十）外部排序"></a>（十）外部排序</h3><h3 id="（十一）各种排序算法的比较"><a href="#（十一）各种排序算法的比较" class="headerlink" title="（十一）各种排序算法的比较"></a>（十一）各种排序算法的比较</h3><h3 id="（十二）排序算法的应用"><a href="#（十二）排序算法的应用" class="headerlink" title="（十二）排序算法的应用"></a>（十二）排序算法的应用</h3><hr><h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="一、计算机系统概述"><a href="#一、计算机系统概述" class="headerlink" title="一、计算机系统概述"></a>一、计算机系统概述</h2><h3 id="（一）计算机发展历程"><a href="#（一）计算机发展历程" class="headerlink" title="（一）计算机发展历程"></a>（一）计算机发展历程</h3><h3 id="（二）计算机系统层次结构"><a href="#（二）计算机系统层次结构" class="headerlink" title="（二）计算机系统层次结构"></a>（二）计算机系统层次结构</h3><ol><li>计算机系统的基本组成</li><li>计算机硬件的基本组成</li><li>计算机软件和硬件的关系</li><li>计算机系统的工作过程</li></ol><h3 id="（三）计算机性能指标"><a href="#（三）计算机性能指标" class="headerlink" title="（三）计算机性能指标"></a>（三）计算机性能指标</h3><p>吞吐量、响应时间，CPU 时钟周期、主频、CPI、CPU 执行时间，MIPS、MFLOPS、GFLOPS、TFLOPS、PFLOPS。</p><h2 id="二、数据的表示和运算"><a href="#二、数据的表示和运算" class="headerlink" title="二、数据的表示和运算"></a>二、数据的表示和运算</h2><h3 id="（一）数制与编码"><a href="#（一）数制与编码" class="headerlink" title="（一）数制与编码"></a>（一）数制与编码</h3><ol><li>进位计数制及其相互转换</li><li>真值和机器数</li><li>BCD 码</li><li>字符与字符串</li><li>校验码</li></ol><h3 id="（二）定点数的表示和运算"><a href="#（二）定点数的表示和运算" class="headerlink" title="（二）定点数的表示和运算"></a>（二）定点数的表示和运算</h3><ol><li><p>定点数的表示</p><p> 无符号数的表示，带符号整数的表示</p></li><li><p>定点数的运算</p><p> 定点数的移位运算，原码定点数的加/减运算，补码定点数的加/减运算，定点数的乘/除运算，溢出的概念和判别方法。</p></li></ol><h3 id="（三）浮点数的表示和运算"><a href="#（三）浮点数的表示和运算" class="headerlink" title="（三）浮点数的表示和运算"></a>（三）浮点数的表示和运算</h3><ol><li><p>浮点数的表示</p><p> IEEE 754标准</p></li><li><p>浮点数的加/减运算</p></li></ol><h3 id="（四）算术逻辑单元-ALU"><a href="#（四）算术逻辑单元-ALU" class="headerlink" title="（四）算术逻辑单元 ALU"></a>（四）算术逻辑单元 ALU</h3><ol><li>串行加法器和并行加法器</li><li>算术逻辑单元 ALU 的功能和结构</li></ol><h2 id="三、存储器层次结构"><a href="#三、存储器层次结构" class="headerlink" title="三、存储器层次结构"></a>三、存储器层次结构</h2><h3 id="（一）存储器的分类"><a href="#（一）存储器的分类" class="headerlink" title="（一）存储器的分类"></a>（一）存储器的分类</h3><h3 id="（二）存储器的层次化结构"><a href="#（二）存储器的层次化结构" class="headerlink" title="（二）存储器的层次化结构"></a>（二）存储器的层次化结构</h3><h3 id="（三）半导体随机存储器"><a href="#（三）半导体随机存储器" class="headerlink" title="（三）半导体随机存储器"></a>（三）半导体随机存储器</h3><ol><li>SRAM 存储器</li><li>DRAM 存储器</li><li>只读存储器</li><li>Flash 存储器</li></ol><h3 id="（四）主存储器与-CPU-的连接"><a href="#（四）主存储器与-CPU-的连接" class="headerlink" title="（四）主存储器与 CPU 的连接"></a>（四）主存储器与 CPU 的连接</h3><h3 id="（五）双口-RAM-和多模块存储器"><a href="#（五）双口-RAM-和多模块存储器" class="headerlink" title="（五）双口 RAM 和多模块存储器"></a>（五）双口 RAM 和多模块存储器</h3><h3 id="（六）高速缓冲存储器（cache）"><a href="#（六）高速缓冲存储器（cache）" class="headerlink" title="（六）高速缓冲存储器（cache）"></a>（六）高速缓冲存储器（cache）</h3><ol><li>cache 的基本工作原理</li><li>cache 和主存之间的映射方式</li><li>cache 中主存块的替换算法</li><li>cache 写策略</li></ol><h3 id="（七）虚拟存储器"><a href="#（七）虚拟存储器" class="headerlink" title="（七）虚拟存储器"></a>（七）虚拟存储器</h3><ol><li>虚拟存储器的基本概念</li><li>页式虚拟存储器</li><li>段式讯存储器</li><li>段页式虚拟存储器</li><li>TLB（快表）</li></ol><h2 id="四、指令系统"><a href="#四、指令系统" class="headerlink" title="四、指令系统"></a>四、指令系统</h2><h3 id="（一）指令格式"><a href="#（一）指令格式" class="headerlink" title="（一）指令格式"></a>（一）指令格式</h3><ol><li>指令的基本格式</li><li>定长操作码指令格式</li><li>扩展操作码指令格式</li></ol><h3 id="（二）指令的寻址方式"><a href="#（二）指令的寻址方式" class="headerlink" title="（二）指令的寻址方式"></a>（二）指令的寻址方式</h3><ol><li>有效地址的概念</li><li>数据寻址和指令寻址</li><li>常见寻址方式</li></ol><h3 id="（三）CISC-和-RISC-的基本概念"><a href="#（三）CISC-和-RISC-的基本概念" class="headerlink" title="（三）CISC 和 RISC 的基本概念"></a>（三）CISC 和 RISC 的基本概念</h3><h2 id="五、中央处理器（CPU）"><a href="#五、中央处理器（CPU）" class="headerlink" title="五、中央处理器（CPU）"></a>五、中央处理器（CPU）</h2><h3 id="（一）CPU-的功能和基本结构"><a href="#（一）CPU-的功能和基本结构" class="headerlink" title="（一）CPU 的功能和基本结构"></a>（一）CPU 的功能和基本结构</h3><h3 id="（二）指令执行过程"><a href="#（二）指令执行过程" class="headerlink" title="（二）指令执行过程"></a>（二）指令执行过程</h3><h3 id="（三）数据通路的功能和基本结构"><a href="#（三）数据通路的功能和基本结构" class="headerlink" title="（三）数据通路的功能和基本结构"></a>（三）数据通路的功能和基本结构</h3><h3 id="（四）控制器的功能和工作原理"><a href="#（四）控制器的功能和工作原理" class="headerlink" title="（四）控制器的功能和工作原理"></a>（四）控制器的功能和工作原理</h3><ol><li><p>硬布线控制器</p></li><li><p>微程序控制器</p><p> 微程序、微指令和微命令，微指令格式，微命令的编码方式，微地址的形成方式。</p></li></ol><h3 id="（五）指令流水线"><a href="#（五）指令流水线" class="headerlink" title="（五）指令流水线"></a>（五）指令流水线</h3><ol><li>指令流水线的基本概念</li><li>指令流水线的基本实现</li><li>超标量和动态流水线的基本概念</li></ol><h2 id="六、总线"><a href="#六、总线" class="headerlink" title="六、总线"></a>六、总线</h2><h3 id="（一）总线概述"><a href="#（一）总线概述" class="headerlink" title="（一）总线概述"></a>（一）总线概述</h3><ol><li>总线的基本概念</li><li>总线的分类</li><li>总线的组成及其性能指标</li></ol><h3 id="（二）总线仲裁"><a href="#（二）总线仲裁" class="headerlink" title="（二）总线仲裁"></a>（二）总线仲裁</h3><ol><li>集中仲裁方式</li><li>分布仲裁方式</li></ol><h3 id="（三）总线操作和定时"><a href="#（三）总线操作和定时" class="headerlink" title="（三）总线操作和定时"></a>（三）总线操作和定时</h3><ol><li>同步定时方式</li><li>异步定时方式</li></ol><h3 id="（四）总线标准"><a href="#（四）总线标准" class="headerlink" title="（四）总线标准"></a>（四）总线标准</h3><h2 id="七、输入输出（I-O）系统"><a href="#七、输入输出（I-O）系统" class="headerlink" title="七、输入输出（I/O）系统"></a>七、输入输出（I/O）系统</h2><h3 id="（一）I-O-系统基本概念"><a href="#（一）I-O-系统基本概念" class="headerlink" title="（一）I/O 系统基本概念"></a>（一）I/O 系统基本概念</h3><h3 id="（二）外部设备"><a href="#（二）外部设备" class="headerlink" title="（二）外部设备"></a>（二）外部设备</h3><ol><li>输入设备：键盘、鼠标</li><li>输出设备：显示器、打印机</li><li>外存储器：硬盘存储器、磁盘列阵、光盘存储器</li></ol><h3 id="（三）I-O-接口（I-O-控制器）"><a href="#（三）I-O-接口（I-O-控制器）" class="headerlink" title="（三）I/O 接口（I/O 控制器）"></a>（三）I/O 接口（I/O 控制器）</h3><ol><li>I/O 接口的功能和基本结构</li><li>I/O 端口及其编址</li></ol><h3 id="（四）I-O-方式"><a href="#（四）I-O-方式" class="headerlink" title="（四）I/O 方式"></a>（四）I/O 方式</h3><ol><li><p>程序查询方式</p></li><li><p>程序中断方式</p><p> 中断的基本概念，中断响应过程，中断处理过程，多重中断和中断屏蔽的概念。</p></li><li><p>DMA 方式</p><p> DMA 控制器的组成，DMA 传送过程</p></li></ol><hr><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="一、操作系统概述"><a href="#一、操作系统概述" class="headerlink" title="一、操作系统概述"></a>一、操作系统概述</h2><h3 id="（一）操作系统的概念、特征、功能和提供的服务"><a href="#（一）操作系统的概念、特征、功能和提供的服务" class="headerlink" title="（一）操作系统的概念、特征、功能和提供的服务"></a>（一）操作系统的概念、特征、功能和提供的服务</h3><h3 id="（二）操作系统的发展与分类"><a href="#（二）操作系统的发展与分类" class="headerlink" title="（二）操作系统的发展与分类"></a>（二）操作系统的发展与分类</h3><h3 id="（三）操作系统的运行环境"><a href="#（三）操作系统的运行环境" class="headerlink" title="（三）操作系统的运行环境"></a>（三）操作系统的运行环境</h3><ol><li>内核态和用户态</li><li>中断、异常</li><li>系统调用</li></ol><h3 id="（四）操作系统体系结构"><a href="#（四）操作系统体系结构" class="headerlink" title="（四）操作系统体系结构"></a>（四）操作系统体系结构</h3><h2 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h2><h3 id="（一）进程与线程"><a href="#（一）进程与线程" class="headerlink" title="（一）进程与线程"></a>（一）进程与线程</h3><ol><li><p>进程概念</p></li><li><p>进程的状态与转换</p></li><li><p>进程控制</p></li><li><p>进程组织</p></li><li><p>进程通信</p><p> 共享存储系统，消息传递系统，管道通信</p></li><li><p>线程概念与多线程模型</p></li></ol><h3 id="（二）处理机调度"><a href="#（二）处理机调度" class="headerlink" title="（二）处理机调度"></a>（二）处理机调度</h3><ol><li><p>调度的基本概念</p></li><li><p>调度时机、切换与过程</p></li><li><p>调度的基本准则</p></li><li><p>调度方式</p></li><li><p>典型调度算法</p><p> 先来先服务、短作业优先、时间片轮转、优先级调度、高响应比调度、多级反馈队列</p></li></ol><h3 id="（三）同步与互斥"><a href="#（三）同步与互斥" class="headerlink" title="（三）同步与互斥"></a>（三）同步与互斥</h3><ol><li><p>进程同步的基本概念</p></li><li><p>实现临界区互斥的基本方法</p><p> 软件实现、硬件实现</p></li><li><p>信号量</p></li><li><p>管程</p></li><li><p>经典同步问题</p><p> 生产者-消费者问题、读者-写者问题、哲学家进餐问题</p></li></ol><h3 id="（四）死锁"><a href="#（四）死锁" class="headerlink" title="（四）死锁"></a>（四）死锁</h3><ol><li><p>死锁概念</p></li><li><p>死锁处理策略</p></li><li><p>死锁预防</p></li><li><p>死锁避免</p><p> 系统安全状态，银行家算法</p></li><li><p>死锁检测和解除</p></li></ol><h2 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h2><h3 id="（一）内存管理基础"><a href="#（一）内存管理基础" class="headerlink" title="（一）内存管理基础"></a>（一）内存管理基础</h3><ol><li><p>内存管理概念</p><p> 程序装入与链接，逻辑地址与物理地址空间，内存保护</p></li><li><p>交换与覆盖</p></li><li><p>连续分配管理方式</p></li><li><p>非连续分配管理方式</p><p> 分页管理方式，分段管理方式，段页式管理方式</p></li></ol><h3 id="（二）虚拟内存管理"><a href="#（二）虚拟内存管理" class="headerlink" title="（二）虚拟内存管理"></a>（二）虚拟内存管理</h3><ol><li><p>虚拟内存基本概念</p></li><li><p>请求分页管理</p></li><li><p>页面置换算法</p><p> 最佳置换算法（OPT)、先进先出置换算法（FIFO）、最近最少使用置换算法（LRU）、时钟置换算法（Clock）</p></li><li><p>页面分配策略</p></li><li><p>工作集</p></li><li><p>抖动</p></li></ol><h2 id="四、文件管理"><a href="#四、文件管理" class="headerlink" title="四、文件管理"></a>四、文件管理</h2><h3 id="（一）文件系统基础"><a href="#（一）文件系统基础" class="headerlink" title="（一）文件系统基础"></a>（一）文件系统基础</h3><ol><li><p>文件概念</p></li><li><p>文件的逻辑结构</p><p> 顺序文件、索引文件、索引顺序文件</p></li><li><p>目录结构</p><p> 文件控制块和索引节点，单级目录结构和两级目录结构，树形目录结构，图形目录结构。</p></li><li><p>文件共享</p></li><li><p>文件保护</p><p> 访问类型，访问控制</p></li></ol><h3 id="（二）文件系统实现"><a href="#（二）文件系统实现" class="headerlink" title="（二）文件系统实现"></a>（二）文件系统实现</h3><ol><li>文件系统层次结构</li><li>目录实现</li><li>文件实现</li></ol><h3 id="（三）磁盘组织与管理"><a href="#（三）磁盘组织与管理" class="headerlink" title="（三）磁盘组织与管理"></a>（三）磁盘组织与管理</h3><ol><li>磁盘的结构</li><li>磁盘调度算法</li><li>磁盘的管理</li></ol><h2 id="五、输入输出（I-O）管理"><a href="#五、输入输出（I-O）管理" class="headerlink" title="五、输入输出（I/O）管理"></a>五、输入输出（I/O）管理</h2><h3 id="（一）I-O-管理概述"><a href="#（一）I-O-管理概述" class="headerlink" title="（一）I/O 管理概述"></a>（一）I/O 管理概述</h3><ol><li>I/O 控制方式</li><li>I/O 软件层次结构</li></ol><h3 id="（二）I-O-核心子系统"><a href="#（二）I-O-核心子系统" class="headerlink" title="（二）I/O 核心子系统"></a>（二）I/O 核心子系统</h3><ol><li>I/O 调度概念</li><li>高速缓存与缓冲区</li><li>设备分配与回收</li><li>假脱机技术（SPOOLing）</li></ol><hr><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="一、计算机网络体系结构"><a href="#一、计算机网络体系结构" class="headerlink" title="一、计算机网络体系结构"></a>一、计算机网络体系结构</h2><h3 id="（一）计算机网络概述"><a href="#（一）计算机网络概述" class="headerlink" title="（一）计算机网络概述"></a>（一）计算机网络概述</h3><ol><li>计算机网络的概念、组成与功能</li><li>计算机网络的分类</li><li>计算机网络的标准化工作及相关组织</li></ol><h3 id="（二）计算机网络体系结构与参考模型"><a href="#（二）计算机网络体系结构与参考模型" class="headerlink" title="（二）计算机网络体系结构与参考模型"></a>（二）计算机网络体系结构与参考模型</h3><ol><li>计算机网络分层结构</li><li>计算机网络协议、接口、服务等概念</li><li>ISO/OSI参考模型和 TCP/IP 模型</li></ol><h2 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h2><h3 id="（一）通信基础"><a href="#（一）通信基础" class="headerlink" title="（一）通信基础"></a>（一）通信基础</h3><ol><li>信道、信号、带宽、码元、波特、速率与信宿等基本元素</li><li>奈奎斯特定理与香浓定理</li><li>编码与调制</li><li>电路交换、报文交换与分组交换</li><li>数据报与虚电路</li></ol><h3 id="（二）传输介质"><a href="#（二）传输介质" class="headerlink" title="（二）传输介质"></a>（二）传输介质</h3><ol><li>双绞线、同轴电缆、光纤与无线传输介质</li><li>物理层接口的特性</li></ol><h3 id="（三）物理层设备"><a href="#（三）物理层设备" class="headerlink" title="（三）物理层设备"></a>（三）物理层设备</h3><ol><li>中继器</li><li>集线器</li></ol><h2 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h2><h3 id="（一-）数据链路层的功能"><a href="#（一-）数据链路层的功能" class="headerlink" title="（一 ）数据链路层的功能"></a>（一 ）数据链路层的功能</h3><h3 id="（二）组帧"><a href="#（二）组帧" class="headerlink" title="（二）组帧"></a>（二）组帧</h3><h3 id="（三）差错控制"><a href="#（三）差错控制" class="headerlink" title="（三）差错控制"></a>（三）差错控制</h3><ol><li>验错编码</li><li>纠错编码</li></ol><h3 id="（四）流量控制与可靠传输机制"><a href="#（四）流量控制与可靠传输机制" class="headerlink" title="（四）流量控制与可靠传输机制"></a>（四）流量控制与可靠传输机制</h3><ol><li>流量控制、可靠传输与滑动窗口机制</li><li>停止-等待协议</li><li>后退 N 帧协议（GBN）</li><li>选择重传协议（SR)</li></ol><h3 id="（五）介质访问控制"><a href="#（五）介质访问控制" class="headerlink" title="（五）介质访问控制"></a>（五）介质访问控制</h3><ol><li><p>信道划分</p><p> 频分多路复用、时分多路分用、波分多路复用、码分多路复用的概念和基本原理。</p></li><li><p>随机访问</p><p> ALOHA 协议，CSMA 协议，CSMA/CD 协议，CSMA/CA协议</p></li><li><p>轮询访问</p><p> 令牌传递协议</p></li></ol><h3 id="（六）局域网"><a href="#（六）局域网" class="headerlink" title="（六）局域网"></a>（六）局域网</h3><ol><li>局域网的基本概念与体系结构</li><li>以太网与 IEEE 802.3</li><li>IEEE 802.11</li><li>令牌环网的基本原理</li></ol><h3 id="（七）广域网"><a href="#（七）广域网" class="headerlink" title="（七）广域网"></a>（七）广域网</h3><ol><li>广域网的基本概念</li><li>PPP 协议</li><li>HDLC 协议</li></ol><h3 id="（八）数据链路层设备"><a href="#（八）数据链路层设备" class="headerlink" title="（八）数据链路层设备"></a>（八）数据链路层设备</h3><ol><li>网桥的概念及其基本原理</li><li>局域网交换机及其工作原理</li></ol><h2 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h2><h3 id="（一）网络层的功能"><a href="#（一）网络层的功能" class="headerlink" title="（一）网络层的功能"></a>（一）网络层的功能</h3><ol><li>异构网络互连</li><li>路由与转发</li><li>拥塞控制</li></ol><h3 id="（二）路由算法"><a href="#（二）路由算法" class="headerlink" title="（二）路由算法"></a>（二）路由算法</h3><ol><li>静态路由与动态路由</li><li>距离——向量路由算法</li><li>链路状态路由算法</li><li>层次路由</li></ol><h3 id="（三）IPv4"><a href="#（三）IPv4" class="headerlink" title="（三）IPv4"></a>（三）IPv4</h3><ol><li>IPv4 分组</li><li>IPv4 地址与 NAT</li><li>子网划分、路由聚集、子网掩码与 CIDR</li><li>ARP 协议、DHCP 协议、ICMP 协议</li></ol><h3 id="（四）IPv6"><a href="#（四）IPv6" class="headerlink" title="（四）IPv6"></a>（四）IPv6</h3><ol><li>IPv6 的主要特点</li><li>IPv6 地址</li></ol><h3 id="（五）路由协议"><a href="#（五）路由协议" class="headerlink" title="（五）路由协议"></a>（五）路由协议</h3><ol><li>自治系统</li><li>域内路由与域间路由</li><li>RIP 路由协议</li><li>OSPF 路由协议</li><li>BGP 路由协议</li></ol><h3 id="（六）IP-组播"><a href="#（六）IP-组播" class="headerlink" title="（六）IP 组播"></a>（六）IP 组播</h3><ol><li>组播的概念</li><li>IP 组播地址</li></ol><h3 id="（七）移动-IP"><a href="#（七）移动-IP" class="headerlink" title="（七）移动 IP"></a>（七）移动 IP</h3><ol><li>移动 IP 的概念</li><li>移动 IP 通信过程</li></ol><h3 id="（八）网络层设备"><a href="#（八）网络层设备" class="headerlink" title="（八）网络层设备"></a>（八）网络层设备</h3><ol><li>路由器的组成与功能</li><li>路由表与路由转发</li></ol><h2 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h2><h3 id="（一）传输层提供的服务"><a href="#（一）传输层提供的服务" class="headerlink" title="（一）传输层提供的服务"></a>（一）传输层提供的服务</h3><ol><li>传输层的功能</li><li>传输层寻址与端口</li><li>无连接服务与面向连接服务</li></ol><h3 id="（二）UDP-协议"><a href="#（二）UDP-协议" class="headerlink" title="（二）UDP 协议"></a>（二）UDP 协议</h3><ol><li>UDP 数据报</li><li>UDP 校验</li></ol><h3 id="（三）TCP-协议"><a href="#（三）TCP-协议" class="headerlink" title="（三）TCP 协议"></a>（三）TCP 协议</h3><ol><li>TCP 段</li><li>TCP 连接管理</li><li>TCP 可靠传输</li><li>TCP 流量控制与拥塞控制</li></ol><h2 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h2><h3 id="（一）网络应用模型"><a href="#（一）网络应用模型" class="headerlink" title="（一）网络应用模型"></a>（一）网络应用模型</h3><ol><li>客户/服务器模型</li><li>P2P 模型</li></ol><h3 id="（二）DNS-系统"><a href="#（二）DNS-系统" class="headerlink" title="（二）DNS 系统"></a>（二）DNS 系统</h3><ol><li>层次域名空间</li><li>域名服务器</li><li>域名解析过程</li></ol><h3 id="（三）FTP"><a href="#（三）FTP" class="headerlink" title="（三）FTP"></a>（三）FTP</h3><ol><li>FTP 协议的工作原理</li><li>控制连接与数据连接</li></ol><h3 id="（四）电子邮件"><a href="#（四）电子邮件" class="headerlink" title="（四）电子邮件"></a>（四）电子邮件</h3><ol><li>电子邮件系统的组织结构</li><li>电子邮件格式与 MIME</li><li>SMTP 协议与 POP3 协议</li></ol><h3 id="（五）WWW"><a href="#（五）WWW" class="headerlink" title="（五）WWW"></a>（五）WWW</h3><ol><li>WWW 的概念与组成结构</li><li>HTTP 协议</li></ol><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p>《2020年全国硕士研究生招生考试计算机科学与技术学科联考计算机学科专业基础综合考试大纲》</p></li><li><p>《数据结构 （C语言版）》 严蔚敏</p></li><li><p>《计算机组成原理（第 2 版）》唐朔飞</p></li><li><p>《计算机操作系统（第四版）》汤小丹</p></li><li><p>《计算机网络（第 7 版）》谢仁希</p></li><li><p>《数据结构考研复习指导》王道</p></li><li><p>《计算机组成原理考研复习指导》王道</p></li><li><p>《操作系统考研复习指导》王道</p></li><li><p>《计算机网络考研复习指导》王道</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Learning IV (Linux Files and Directories Permissions)</title>
      <link href="2020/07/06/Linux-files-directories-permissions/"/>
      <url>2020/07/06/Linux-files-directories-permissions/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="用户与用户组"><a href="#用户与用户组" class="headerlink" title="用户与用户组"></a>用户与用户组</h1><blockquote><p> 在 Linux 中，任何一个文件都具有用户（User），所属群组（Group），以及其他人（Others）三种身份的个别权限。</p></blockquote><ol><li><p>文件拥有者</p><p> 由于 Linux 是一个多人多任务的系统，因此需要考虑每个人的隐私权和每个人喜好的工作环境，因此文件拥有者的角色就相当重要</p></li><li><p>用户组的概念</p><p> 用户组最有用的功能之一是在团队进行协作的时候。可以对一个文件进行简单的权限设置，就能限制非自己团队成员的其他人不能够阅读内容，但可以让自己用户组的成员修改我所建立的文件。</p><p> 同时，如果有我自己的私人隐秘文件，可以设置让自己用户组的成员也看不到我的文件。</p></li><li><p>其他人的概念</p><p> 与文件的拥有者和用户组没有关系的人，即没有被包含在用户组内的人。</p><p> 但 Linux 还有一个 root 用户，对任何文件都有权限</p></li></ol><h1 id="Linux-文件权限"><a href="#Linux-文件权限" class="headerlink" title="Linux 文件权限"></a>Linux 文件权限</h1><p>使用<code>ls -al</code>命令，可以列出当前目录的所有文件（包括隐藏文件）</p><p>例如在我的 CentOS 服务器上的 <code>/root</code>目录使用该命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -al</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">total 136</span><br><span class="line">dr-xr-x---. 13 root  root   4096 Jun 24 22:41 .</span><br><span class="line">dr-xr-xr-x. 21 root  root   4096 Jul  6 12:02 ..</span><br><span class="line">-rw-------   1 root  root  23323 Jul  6 12:01 .bash_history</span><br><span class="line">-rw-r--r--.  1 root  root     18 Dec 29  2013 .bash_logout</span><br><span class="line">-rw-r--r--   1 root  root    250 Jun 18 17:11 .bash_profile</span><br><span class="line">-rw-r--r--.  1 root  root    176 Dec 29  2013 .bashrc</span><br><span class="line">drwxr-xr-x   3 root  root   4096 Mar  7  2019 .cache</span><br><span class="line">drwxr-xr-x   4 root  root   4096 Jun 18 17:11 .config</span><br><span class="line">-rw-r--r--.  1 root  root    100 Dec 29  2013 .cshrc</span><br><span class="line">-rw-r--r--   1 root  root   4833 May 16  2014 index.html</span><br><span class="line">drwxr-xr-x   3 root  root   4096 Jun 24 22:41 .java</span><br><span class="line">-rw-------   1 root  root     42 Nov  5  2019 .lesshst</span><br><span class="line">drwxr-xr-x   3 root  root   4096 Jun 24 17:47 .m2</span><br><span class="line">-rw-------   1 root  root   1544 Jun 24 22:38 .mysql_history</span><br><span class="line">drwxr-xr-x   6 root  root   4096 Jun 24 21:48 .npm</span><br><span class="line">drwxr-xr-x   2 root  root   4096 Jun 22 20:09 .oracle_jre_usage</span><br><span class="line">drwxr-xr-x   2 root  root   4096 Jun 18 14:51 .pip</span><br><span class="line">drwxr-----   3 root  root   4096 Jun 19 16:35 .pki</span><br><span class="line">-rw-r--r--   1 root  root     73 Jun 18 14:51 .pydistutils.cfg</span><br><span class="line">drwxr-xr-x  18 mysql mysql  4096 Jun 18 17:03 Python-3.8.3</span><br><span class="line">-rw-------   1 root  root     12 Jun 18 17:06 .python_history</span><br><span class="line">-rw-------   1 root  root     20 Jun 22 20:27 .rediscli_history</span><br><span class="line">drwx------   2 root  root   4096 Jun 18 15:13 .ssh</span><br><span class="line">-rw-r--r--.  1 root  root    129 Dec 29  2013 .tcshrc</span><br><span class="line">-rw-------   1 root  root   4774 Jun 22 20:41 .viminfo</span><br><span class="line">drwxr-xr-x   3 root  root   4096 Jun 24 22:23 workspace</span><br></pre></td></tr></table></figure><p>将上面所展示的信息可以使用如下表格展示</p><table><thead><tr><th align="center">内容</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>drwxr-xr-x</code></td><td align="center">文件类型权限</td></tr><tr><td align="center">3</td><td align="center">链接数</td></tr><tr><td align="center"><code>root</code></td><td align="center">文件拥有者</td></tr><tr><td align="center"><code>root</code></td><td align="center">文件用户组</td></tr><tr><td align="center">4096</td><td align="center">文件大小（默认以 Bytes 为单位）</td></tr><tr><td align="center">Jun 24 22:23</td><td align="center">文件最后修改时间</td></tr><tr><td align="center">workspace</td><td align="center">文件名</td></tr></tbody></table><h2 id="文件类型权限"><a href="#文件类型权限" class="headerlink" title="文件类型权限"></a>文件类型权限</h2><p>第一个字符表示文件到底是一个 <strong>目录、文件、链接文件等</strong></p><ul><li>是<code>d</code>表示目录</li><li>是<code>-</code>表示文件</li><li>是<code>l</code>表示链接文件（link file）</li><li>是<code>b</code>表示设备文件里的可供存储的外围设备</li><li>是<code>c</code>表示设备文件里的串行端口设备，如键盘、鼠标</li></ul><p>从第二个字符到第四个字符表示<strong>文件拥有者</strong>的权限，第五个字符到第七个字符表示<strong>文件所属用户组</strong>的权限，第八个到第十个字符表示<strong>其他人</strong>的权限，其中</p><ul><li><code>r</code>表示可读</li><li><code>w</code>表示可写</li><li><code>x</code>表示可执行</li><li><code>-</code>表示无权限</li><li>其中<code>rwx</code>的位置不会发生变化，如果没有当前权限就直接使用<code>-</code>表示无权限</li></ul><p>例如：<code>drwxr-xr-x</code>，表示这是一个<strong>目录</strong>，<strong>文件拥有者</strong>可以进行<code>读、写、执行</code>而<strong>所在用户组的其他用户和其他人</strong>只能<code>读、执行</code></p><h2 id="链接数"><a href="#链接数" class="headerlink" title="链接数"></a>链接数</h2><p>表示有多少文件名链接到此节点（inode)</p><blockquote><p>每一个文件都会与它的权限与属性记录到文件系统的<code>inode</code>中，不过，我们使用的目录树却是使用文件名来进行记录，因此每一个文件名就会链接到一个<code>inode</code>，这个属性记录的是有多少不同的文件名链接到相同的一个<code>inode</code>号码。</p></blockquote><h2 id="最后修改时间"><a href="#最后修改时间" class="headerlink" title="最后修改时间"></a>最后修改时间</h2><p>显示为<code>月 日</code>的形式，如果最后修改的时间距离现在太久，则时间部分只会显示年份而已，如使用<code>ls -l</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rw-r--r--  1 root  root  4833 May 16  2014 index.html</span><br><span class="line">drwxr-xr-x  3 root  root  4096 Jun 24 22:23 workspace</span><br></pre></td></tr></table></figure><h1 id="修改文件属性和权限"><a href="#修改文件属性和权限" class="headerlink" title="修改文件属性和权限"></a>修改文件属性和权限</h1><p>在<code>root</code>用户下使用：</p><ul><li><code>chgrp</code>修改文件所属用户组</li><li><code>chown</code>修改文件的拥有者</li><li><code>chmod</code>修改文件权限</li></ul><h2 id="使用chgrp"><a href="#使用chgrp" class="headerlink" title="使用chgrp"></a>使用<code>chgrp</code></h2><p><code>chgrp</code>为<code>change group</code>的缩写，使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chgrp [-R] dirname/filename</span><br></pre></td></tr></table></figure><p>可选参数<code>-R</code>，表示递归（recursive）修改连同子目录下的所有文件、所有目录，都更新为这个用户组</p><p>注：用户组名必须在文件<code>/etc/group</code>文件中存在才行</p><h2 id="使用chown"><a href="#使用chown" class="headerlink" title="使用chown"></a>使用<code>chown</code></h2><p><code>chown</code>为<code>change owner</code>的缩写，使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown [-R] 账号名称 文件或目录</span><br><span class="line">chown [-R] 账号名称:用户组名称 文件或目录  <span class="comment"># 顺便一起修改了用户组名称</span></span><br></pre></td></tr></table></figure><p><code>-R</code>表示递归</p><p>注：用户必须在<code>/etc/passwd</code>文件中存在才行</p><h2 id="何时使用？"><a href="#何时使用？" class="headerlink" title="何时使用？"></a>何时使用？</h2><p>最常见的例子是在复制文件给别人使用的时候，由于复制命令<code>cp 源文件 目标文件</code>会直接复制执行者的属性和权限，所以这个时候就有必要进行文件拥有者和用户组的修改了。</p><h2 id="使用chmod"><a href="#使用chmod" class="headerlink" title="使用chmod"></a>使用<code>chmod</code></h2><p>此命令设置权限的方法有 2 种，分别是 <strong>符号式</strong> 和 <strong>数字式</strong></p><h3 id="数字式"><a href="#数字式" class="headerlink" title="数字式"></a>数字式</h3><p>我们可以使用数字来代表各个（读、写、执行）的权限，其中</p><ul><li><code>r</code>对应<code>4</code></li><li><code>w</code>对应<code>2</code></li><li><code>x</code>对应<code>1</code></li></ul><p>有一些像二进制数</p><p>对于一个文件类型权限如<code>-rwxrwx---</code>来说，第一位表示是一个文件，将后 9 位每三个分一组，分别表示文件拥有者，文件所属用户组，和其他人的权限，就得到了<code>rwx</code>,<code>rwx</code>和<code>---</code>，应用对应关系，可以得出第一位<code>r+w+x = 4+2+1 = 7</code>，同理第二位，第三位表示<code>0</code>，</p><p>所有最后修改的权限应该写为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod [-R] 770 文件或目录</span><br></pre></td></tr></table></figure><h3 id="符号式"><a href="#符号式" class="headerlink" title="符号式"></a>符号式</h3><p>三种身份分别使用<code>u</code>,<code>g</code>,<code>o</code>,<code>a</code>（<code>u</code>表示 user，<code>g</code>表示 group，<code>o</code>表示others <code>a</code>表示 all）</p><p>使用符号<code>+</code>表示添加权限，<code>-</code>表示去除权限，<code>=</code>表示直接设置权限</p><p>所以命令为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">       u      +        r        </span><br><span class="line">chmod  g      -        w        文件或目录</span><br><span class="line">       o      =        x</span><br><span class="line">       a</span><br></pre></td></tr></table></figure><p>例如，想要修改一个文件权限为<code>-rwxr-xr-x</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod u=rwx,go=rx 文件名 <span class="comment"># 其中u=rwx,go=rx中间无任何空格</span></span><br></pre></td></tr></table></figure><p>注：使用<code>+</code>,<code>-</code>时，如果没有指定到当前权限，则会保持不变，比如文件权限为<code>rwx</code>，使用<code>chmod -x</code>这样的命令时，最后权限为<code>rw-</code></p><h1 id="目录和文件的权限意义"><a href="#目录和文件的权限意义" class="headerlink" title="目录和文件的权限意义"></a>目录和文件的权限意义</h1><h2 id="对于文件而言"><a href="#对于文件而言" class="headerlink" title="对于文件而言"></a>对于文件而言</h2><table><thead><tr><th align="center">权限</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">read</td><td align="center">可读取此文件的实际内容</td></tr><tr><td align="center">write</td><td align="center">可以编辑、新增、或修改文件的内容（<strong>但不包含删除该文件</strong>）</td></tr><tr><td align="center">execute</td><td align="center">可以被系统执行的权限</td></tr></tbody></table><p>注：在<code>Windows</code>下，一个可执行文件往往和文件后缀名有关，如<code>.exe</code>,<code>.bat</code>,<code>.com</code>等，但在<code>Linux</code>中，文件是否能被执行，是借由是否具有<code>x</code>这个权限来决定的，跟文件名是没有绝对关系的。</p><h2 id="对于目录而言"><a href="#对于目录而言" class="headerlink" title="对于目录而言"></a>对于目录而言</h2><table><thead><tr><th align="left">权限</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">read contents in directory</td><td align="left">表示具有读取目录结构列表的权限，<br />即你可以使用<code>ls</code>命令查看当前目录的内容列表（文件名列表）</td></tr><tr><td align="left">modify contents of directory</td><td align="left">表示具有改动当前目录结构列表的权限，即<br />- <strong>建立新的</strong>文件与目录<br />- <strong>删除已经存在</strong>的文件与目录（不论该文件的权限是什么）<br />- 将已存在的文件或目录进行<strong>改名</strong><br />- <strong>移动</strong>该目录内的文件、目录位置</td></tr><tr><td align="left">access directory</td><td align="left">目录不能被执行，但目录的<code>x</code>表示用户是否能够进入该目录，使之成为工作目录，即使用<code>cd</code>命令进入</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《鸟哥的 Linux 私房菜》</li></ul>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Learning III (开源项目的部署)</title>
      <link href="2020/06/25/Config-my-centos-server-III/"/>
      <url>2020/06/25/Config-my-centos-server-III/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>既然有了服务器，总想运行部署点什么，（之前自己写的 flask 太丑了），想着🐑哥之前力荐的<a href="https://ruoyi.vip/">若依</a>项目很适合拿来练手，而且🐑哥也出了一期“保姆级视频”，就想着也来部署一个玩玩，虽然有视频教程了，但是在部署的过程中还是遇到了不少麻烦，（流下了不学无术的泪水）</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1uK411p7Bp">🐑哥的部署视频</a></p><p><a href="https://gitee.com/y_project/RuoYi-Vue">若依项目地址[前后端分离版]</a></p></blockquote><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>前面我只配置了 <code>Python</code>、<code>Git</code>、<code>Node</code>、<code>MySQL</code>等环境，由于若依是用<code>SpringBoot</code>写的，所以我们还需要配置<code>JDK1.8</code>以及<code>Maven</code>、<code>Tomcat</code>、<code>Redis</code>等。</p><h2 id="JDK-的配置"><a href="#JDK-的配置" class="headerlink" title="JDK 的配置"></a>JDK 的配置</h2><h3 id="准备-JDK-安装包"><a href="#准备-JDK-安装包" class="headerlink" title="准备 JDK 安装包"></a>准备 JDK 安装包</h3><p>这里准备的是<code>jdk-8u161-linux-x64.tar.gz</code>，并放在了<code>root</code>目录下</p><h3 id="卸载已有的-OPENJDK"><a href="#卸载已有的-OPENJDK" class="headerlink" title="卸载已有的 OPENJDK"></a>卸载已有的 OPENJDK</h3><p>可以通过命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></table></figure><p>来查看，如果有输出，则将这些包全部卸载</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y remove java....(省略)</span><br></pre></td></tr></table></figure><h3 id="创建-Java-目录并解压"><a href="#创建-Java-目录并解压" class="headerlink" title="创建 Java 目录并解压"></a>创建 Java 目录并解压</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span></span><br><span class="line">mkdir java</span><br><span class="line"><span class="built_in">cd</span> java</span><br><span class="line">tar -zxvf /root/jdk-8u161-linux-x64.tar.gz -C ./</span><br></pre></td></tr></table></figure><p>解压完成，在<code>/usr/local/java</code>⽬录中会出现⼀个<code>jdk1.8.0_161</code>的文件夹</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>编辑<code>/etc/profile</code>文件，在文件尾部加入如下<code>JDK</code>环境配置即可</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">JAVA_HOME</span>=<span class="string">/usr/local/java/jdk1.8.0_161 </span></span><br><span class="line"><span class="attr">CLASSPATH</span>=<span class="string">$JAVA_HOME/lib/ </span></span><br><span class="line"><span class="attr">PATH</span>=<span class="string">$PATH:$JAVA_HOME/bin </span></span><br><span class="line"><span class="attr">export</span> <span class="string">PATH JAVA_HOME CLASSPATH</span></span><br></pre></td></tr></table></figure><p>刷新环境变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h3 id="验证安装结果"><a href="#验证安装结果" class="headerlink" title="验证安装结果"></a>验证安装结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">javac</span><br></pre></td></tr></table></figure><h2 id="Maven-项目管理工具"><a href="#Maven-项目管理工具" class="headerlink" title="Maven 项目管理工具"></a>Maven 项目管理工具</h2><h3 id="准备安装包并解压"><a href="#准备安装包并解压" class="headerlink" title="准备安装包并解压"></a>准备安装包并解压</h3><p>这⾥下载的是<code>apache-maven-3.6.3-bin.tar.gz</code>并将其放置在新创建的<code>/opt/maven/</code>目录下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf apache-maven-3.6.3-bin.tar.gz</span><br></pre></td></tr></table></figure><h3 id="配置镜像源"><a href="#配置镜像源" class="headerlink" title="配置镜像源"></a>配置镜像源</h3><p>修改<code>/opt/maven/apache-maven-3.6.3/conf/settings.xml</code>文件，在<code>&lt;mirrors&gt;&lt;/mirrors&gt;</code>标签中加入如下内容</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置环境变量-1"><a href="#配置环境变量-1" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>编辑<code>/etc/profile</code>文件，在文件尾部添加如下内容</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">export</span> <span class="string">MAVEN_HOME=/opt/maven/apache-maven-3.6.3 </span></span><br><span class="line"><span class="attr">export</span> <span class="string">PATH=$MAVEN_HOME/bin:$PATH</span></span><br></pre></td></tr></table></figure><p>刷新环境变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h3 id="检验安装结果"><a href="#检验安装结果" class="headerlink" title="检验安装结果"></a>检验安装结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure><h2 id="Redis-缓存安装"><a href="#Redis-缓存安装" class="headerlink" title="Redis 缓存安装"></a>Redis 缓存安装</h2><h3 id="准备安装包"><a href="#准备安装包" class="headerlink" title="准备安装包"></a>准备安装包</h3><p>这⾥下载的是<code>redis-5.0.8.tar.gz</code>并放在了<code>root</code>目录下</p><p>新建<code>/usr/local/redis</code>，解压到次文件夹中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf /root/redis-5.0.8.tar.gz -C ./</span><br></pre></td></tr></table></figure><h3 id="编译并安装"><a href="#编译并安装" class="headerlink" title="编译并安装"></a>编译并安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-5.0.8/ </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="将-Redis-安装为系统服务并后台启动"><a href="#将-Redis-安装为系统服务并后台启动" class="headerlink" title="将 Redis 安装为系统服务并后台启动"></a>将 Redis 安装为系统服务并后台启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> utils/</span><br><span class="line">./install_server.sh</span><br></pre></td></tr></table></figure><p>一路回车，默认配置</p><h3 id="查看-Redis-服务启动情况"><a href="#查看-Redis-服务启动情况" class="headerlink" title="查看 Redis 服务启动情况"></a>查看 Redis 服务启动情况</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status redis_6379.service</span><br></pre></td></tr></table></figure><h3 id="允许远程连接"><a href="#允许远程连接" class="headerlink" title="允许远程连接"></a>允许远程连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/redis/6379.conf</span><br></pre></td></tr></table></figure><p>将 <code>bind 127.0.0.1</code>修改为<code>bind 0.0.0.0</code></p><p>重启<code>Redis</code>服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart redis_6379.service</span><br></pre></td></tr></table></figure><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/redis/6379.conf</span><br></pre></td></tr></table></figure><p>找到如下<code>#requirepass foobared</code></p><p>去掉注释，将后面的<code>foobared</code>修改为自己的密码，保存即可</p><p>重启<code>Redis</code>服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart redis_6379.conf</span><br></pre></td></tr></table></figure><h1 id="本地更改配置"><a href="#本地更改配置" class="headerlink" title="本地更改配置"></a>本地更改配置</h1><h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h2><p>文件中有两个目录，分别是<code>ruoyi</code>和<code>ruoyi-ui</code>，前者是后端，后者是前端。</p><p>🐑哥使用了两台虚拟机来部署，而我这里只有一台云服务器，操作有些许不同，而且我之前还部署了我的博客，所以要对<code>nginx.conf</code>的配置要再进行修改</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>我们需要修改<code>MySQL</code>和<code>Redis</code>和日志的配置</p><h3 id="修改数据库配置"><a href="#修改数据库配置" class="headerlink" title="修改数据库配置"></a>修改数据库配置</h3><ol><li><p>在服务器的数据库上新建一个<code>ry-vue</code>的数据库，可以使用可视化工具进行创建，我使用的是<code>TablePlus</code></p><p> <img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/new-ry-db.png" alt="new-database"></p></li><li><p>下载文件中在<code>ruoyi/sql</code>下有两个<code>sql</code>文件，直接可以使用可视化工具执行这两个文件，刷新之后便可以看到新建了一些表</p></li><li><p>修改<code>ruoyi/src/main/resources/application-druid.yml</code>的文件，将其中数据库的<code>url</code>,<code>username</code>,<code>password</code>修改为自己的数据库配置</p></li></ol><h3 id="修改缓存配置"><a href="#修改缓存配置" class="headerlink" title="修改缓存配置"></a>修改缓存配置</h3><p>修改<code>ruoyi/src/main/resources/application.yml</code>文件</p><p>将其中 <code>redis</code>的<code>host</code>改为 IP 地址，<code>password</code>修改为之前设置的密码</p><h3 id="修改日志路径"><a href="#修改日志路径" class="headerlink" title="修改日志路径"></a>修改日志路径</h3><p>修改<code>/ruoyi/src/main/resources/logback.xml</code>的配置文件，修改<code>&lt;configuration&gt; &lt;property value&gt;</code>中的值，改为自定义路径</p><h3 id="修改字符集"><a href="#修改字符集" class="headerlink" title="修改字符集"></a>修改字符集</h3><p>在此<code>xml</code>文件下所有的<code>&lt;encoder&gt;&lt;/encoder&gt;</code>中加上<code>UTF-8</code>的字符集支持，避免日志看到乱码</p><h1 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h1><h2 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h2><p>我们直接将<code>ruoyi-ui</code>和<code>ruoyi</code>两个文件夹压缩，如压缩为<code>zip</code>格式，然后使用 <code>SFTP</code>工具直接拖拽到服务器文件夹中，这里直接拖到<code>/home</code>目录下</p><p>使用解压命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip ruoyi.zip</span><br><span class="line">unzip ruoyi-ui.zip</span><br></pre></td></tr></table></figure><p>得到了两个新的文件夹</p><h3 id="前端打包"><a href="#前端打包" class="headerlink" title="前端打包"></a>前端打包</h3><ol><li><p>进入<code>ruoyi-ui</code>目录下，运行如下命令，安装依赖</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --unsafe-perm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li><p>构建打包</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build:prod</span><br></pre></td></tr></table></figure><p> 成功后出现了<code>dist</code>目录，在部署时使用</p></li></ol><h3 id="后端打包"><a href="#后端打包" class="headerlink" title="后端打包"></a>后端打包</h3><p>这里只使用了<code>jar</code>包方式，比较简单</p><p>进入后端项目文件夹<code>ruoyi</code>下</p><ol><li><p>运行如下打包命令</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure></li><li><p>进入<code>target</code>文件夹下，新增了一个<code>jar</code>包</p></li></ol><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><h3 id="前端项目部署"><a href="#前端项目部署" class="headerlink" title="前端项目部署"></a>前端项目部署</h3><p>这里需要更改<code>nginx.conf</code>文件，不记得位置的话可以使用<code>nginx -t</code>命令查看</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">listen</span>       <span class="string">80 default_server;</span></span><br><span class="line">        <span class="attr">listen</span>       <span class="string">[::]:80 default_server;</span></span><br><span class="line">        <span class="attr">server_name</span>  <span class="string">www.lihangzhu.com;</span></span><br><span class="line">        <span class="attr">root</span>         <span class="string">/home/hexoBlog;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">        # Load configuration files for the default server block.</span></span><br><span class="line">        <span class="attr">include</span> <span class="string">/etc/nginx/default.d/*.conf;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">error_page</span> <span class="string">404 /404.html;</span></span><br><span class="line">            <span class="attr">location</span> = <span class="string">/40x.html &#123;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">error_page</span> <span class="string">500 502 503 504 /50x.html;</span></span><br><span class="line">            <span class="attr">location</span> = <span class="string">/50x.html &#123;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>这是我们原来的 <code>conf</code>文件</p><p>我们可以直接照着原来的配置写一个，不过需要把端口改掉，将下列代码加入上面<code>server</code>的后面</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">listen</span>       <span class="string">90;</span></span><br><span class="line">        <span class="attr">server_name</span>  <span class="string">localhost;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">        # Load configuration files for the default server block.</span></span><br><span class="line">        <span class="attr">include</span> <span class="string">/etc/nginx/default.d/*.conf;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">            <span class="attr">root</span>  <span class="string">/home/ruoyi-ui/dist;</span></span><br><span class="line">            <span class="attr">index</span> <span class="string">index.html index.htm;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">location</span> <span class="string">/prod-api/ &#123; </span></span><br><span class="line">            <span class="attr">proxy_set_header</span> <span class="string">Host $http_host; </span></span><br><span class="line">            <span class="attr">proxy_set_header</span> <span class="string">X-Real-IP $remote_addr; </span></span><br><span class="line">            <span class="attr">proxy_set_header</span> <span class="string">REMOTE-HOST $remote_addr; </span></span><br><span class="line">            <span class="attr">proxy_set_header</span> <span class="string">X-Forwarded-For $proxy_add_x_forwarded_for; </span></span><br><span class="line">            <span class="attr">proxy_pass</span> <span class="string">http://106.54.65.104:8080/; </span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">error_page</span> <span class="string">404 /404.html;</span></span><br><span class="line">            <span class="attr">location</span> = <span class="string">/40x.html &#123;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">error_page</span> <span class="string">500 502 503 504 /50x.html;</span></span><br><span class="line">            <span class="attr">location</span> = <span class="string">/50x.html &#123;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>其中<code>location /prod-api/</code>是前后端的接口</p><p>重新加载一下<code>nginx</code>配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service nginx reload</span><br></pre></td></tr></table></figure><h3 id="后端项目部署"><a href="#后端项目部署" class="headerlink" title="后端项目部署"></a>后端项目部署</h3><p>在<code>ruoyi/target</code>目录下，执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java –jar ruoyi.jar</span><br></pre></td></tr></table></figure><h2 id="部署结果"><a href="#部署结果" class="headerlink" title="部署结果"></a>部署结果</h2><p>打开浏览器输入我们的地址和端口号<code>http://106.54.65.104:90</code></p><p>部署成功</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/ruoyi-login.jpg"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/ruoyi-admin.jpg"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>感谢前辈们精彩的开源项目和部署教程，让我一个小白也能体会到乐趣，虽然我什么也不会写。</p><p>希望今后我也能努力学习，全栈冲冲冲！</p>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
          <category> BuildDevEnv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RuoYi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Learning II (Hexo 从 GitPage 到腾讯云)</title>
      <link href="2020/06/22/Config-my-centos-server-II/"/>
      <url>2020/06/22/Config-my-centos-server-II/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h1><p>详情见上一篇<a class="btn-beautify button--animated blue larger" href="/2020/06/20/Config-my-centos-server-I/#%E5%AE%89%E8%A3%85-git"   title="Linux Learning I"><i class="far fa-hand-point-right fa-fw"></i><span>Linux Learning I</span></a></p><h2 id="创建-Git-裸仓库"><a href="#创建-Git-裸仓库" class="headerlink" title="创建 Git 裸仓库"></a>创建 Git 裸仓库</h2><p>我选择在<code>/home/git</code>目录下，创建一个名为<code>hexoBlog</code>的仓库，然后修改目录的所有权和用户权限。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /home/git/</span><br><span class="line">chown -R <span class="variable">$USER</span>:<span class="variable">$USER</span> /home/git/</span><br><span class="line">chmod -R 755 /home/git/</span><br></pre></td></tr></table></figure><h2 id="git-初始化"><a href="#git-初始化" class="headerlink" title="git 初始化"></a>git 初始化</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/git/</span><br><span class="line">git init --bare hexoBlog.git</span><br></pre></td></tr></table></figure><p>在<code>/home/git/hexoBlog.git</code>下，自动生成了<code>hooks</code>文件夹。我们在里边新建一个钩子文件夹<code>post-receive</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /home/git/hexoBlog.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>在文件追加以下内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --work-tree=/home/hexoBlog --git-dir=/home/git/hexoBlog.git checkout -f</span><br></pre></td></tr></table></figure><p>保存退出</p><h2 id="修改文件权限，使其可执行"><a href="#修改文件权限，使其可执行" class="headerlink" title="修改文件权限，使其可执行"></a>修改文件权限，使其可执行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x /home/git/hexoBlog.git/hooks/post-receive</span><br></pre></td></tr></table></figure><h1 id="Nginx的配置"><a href="#Nginx的配置" class="headerlink" title="Nginx的配置"></a>Nginx的配置</h1><p>安装步骤请见上一篇<a class="btn-beautify button--animated blue larger" href="/2020/06/20/Config-my-centos-server-I/#Nginx-%E5%AE%89%E8%A3%85"   title="Linux Learning I"><i class="far fa-hand-point-right fa-fw"></i><span>Linux Learning I</span></a></p><h2 id="更改-Nginx-托管文件目录"><a href="#更改-Nginx-托管文件目录" class="headerlink" title="更改 Nginx 托管文件目录"></a>更改 Nginx 托管文件目录</h2><p>创建<code>/home/hexoBlog</code>目录，用于 Nginx 托管</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /home/hexoBlog/</span><br><span class="line">chown -R <span class="variable">$USER</span>:<span class="variable">$USER</span> /home/hexoBlog/</span><br><span class="line">chmod -R 755 /home/hexoBlog/</span><br></pre></td></tr></table></figure><h2 id="修改-Nginx-的默认配置"><a href="#修改-Nginx-的默认配置" class="headerlink" title="修改 Nginx 的默认配置"></a>修改 Nginx 的默认配置</h2><p>注：安装位置可能不一样</p><p>使用<code>nginx -t</code>查看</p><p>我的在<code>/etc/nginx/nginx.conf</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>我们需要修改：</p><ol><li><code>root</code>的值改为<code>/home/hexoBlog</code></li><li>将<code>server_name</code>改成你的域名</li></ol><p>保存退出</p><h2 id="将端口改为443"><a href="#将端口改为443" class="headerlink" title="将端口改为443"></a>将端口改为443</h2><p>如果要抢占走<code>https</code>，那么要把<code>nginx.conf</code>的配置进行如下更改：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">listen</span> <span class="string">80;</span></span><br><span class="line">        <span class="attr">server_name</span> <span class="string">www.lihangzhu.com;</span></span><br><span class="line">        <span class="attr">rewrite</span> <span class="string">^(.*)$ https://$&#123;server_name&#125;$1 permanent; </span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">       <span class="attr">listen</span>       <span class="string">443 ssl http2 default_server;</span></span><br><span class="line">       <span class="attr">listen</span>       <span class="string">[::]:443 ssl http2 default_server;</span></span><br><span class="line">       <span class="attr">server_name</span>  <span class="string">www.lihangzhu.com;</span></span><br><span class="line">       <span class="attr">root</span>         <span class="string">/home/hexoBlog;</span></span><br><span class="line"></span><br><span class="line">       <span class="attr">ssl_certificate</span> <span class="string">&quot;crt路径&quot;;</span></span><br><span class="line">       <span class="attr">ssl_certificate_key</span> <span class="string">&quot;key路径&quot;;</span></span><br><span class="line">       <span class="attr">ssl_session_cache</span> <span class="string">shared:SSL:1m;</span></span><br><span class="line">       <span class="attr">ssl_session_timeout</span>  <span class="string">10m;</span></span><br><span class="line">       <span class="attr">ssl_ciphers</span> <span class="string">HIGH:!aNULL:!MD5;</span></span><br><span class="line">       <span class="attr">ssl_prefer_server_ciphers</span> <span class="string">on;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">       # Load configuration files for the default server block.</span></span><br><span class="line">       <span class="attr">include</span> <span class="string">/etc/nginx/default.d/*.conf;</span></span><br><span class="line"></span><br><span class="line">       <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">       <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">       <span class="attr">error_page</span> <span class="string">404 /404.html;</span></span><br><span class="line">           <span class="attr">location</span> = <span class="string">/40x.html &#123;</span></span><br><span class="line">       <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">       <span class="attr">error_page</span> <span class="string">500 502 503 504 /50x.html;</span></span><br><span class="line">           <span class="attr">location</span> = <span class="string">/50x.html &#123;</span></span><br><span class="line">       <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="重启-Nginx-服务"><a href="#重启-Nginx-服务" class="headerlink" title="重启 Nginx 服务"></a>重启 Nginx 服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure><h1 id="修改-hexo-站点-git-配置"><a href="#修改-hexo-站点-git-配置" class="headerlink" title="修改 hexo 站点 git 配置"></a>修改 hexo 站点 git 配置</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> </span><br><span class="line">    <span class="attr">centos:</span> <span class="string">root@&lt;你的ip地址&gt;:/home/git/hexoBlog</span></span><br><span class="line">    <span class="comment"># github: https://github.com/jzhmcoo1/jzhmcoo1.github.io.git</span></span><br><span class="line">    <span class="comment"># gitee: https://gitee.com/jzhmcoo1/jzhmcoo1.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h2 id="执行部署命令"><a href="#执行部署命令" class="headerlink" title="执行部署命令"></a>执行部署命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;你的博客根目录&gt;</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>然后访问公网 IP，部署成功。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><ul><li><a href="https://cloud.tencent.com/developer/article/1140005">Hexo 博客部署到腾讯云教程</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
          <category> BuildDevEnv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Learning I (云服务器的购买与配置)</title>
      <link href="2020/06/20/Config-my-centos-server-I/"/>
      <url>2020/06/20/Config-my-centos-server-I/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>由于下学期将要开始学习 <code>Linux</code>和<code>计算机网络</code>，虚拟机环境感觉不过瘾，乘次机会想要摆弄摆弄云服务器，学生价也不贵，于是就在腾讯云上整了一台，开始学习 <code>Linux</code>。</p><p>打算写<code>Linux</code>学习的一系列文章</p><p>打算先写一些基础的环境搭建文章</p><p>目前打算写的有：</p><ul><li>Linux 云服务器的购买与配置</li><li>Hexo 博客从 Gitpages 到腾讯云的迁移</li><li>…</li></ul><hr><h1 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h1><h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><p>首先进入腾讯云学生优惠官网选购 <code>CentOS7.6</code></p><p>这里给出购买链接</p><ul><li><a href="https://cloud.tencent.com/act/campus">学生购买链接</a></li><li><a href="https://dnspod.cloud.tencent.com/">域名购买</a></li></ul><p>购买完成后可以从控制台登录云服务器，不过还是通过 ssh 客户端来登录比较方便，</p><p>mac 平台上我使用的是 <code>secureCRT+Transmit</code>来输入命令以及传输文件</p><h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h2><p>在控制台解析域名，可以使用快速解析将域名指向云服务器</p><p>不过刚买的域名实名认证之后需要三天才可以申请备案</p><p>具体请参考腾讯云的<a href="https://cloud.tencent.com/document/product/213/2936">云服务器的快速入门</a></p><h2 id="申请-SSL-证书"><a href="#申请-SSL-证书" class="headerlink" title="申请 SSL 证书"></a>申请 SSL 证书</h2><p>想要走 https 就要去<a href="https://console.cloud.tencent.com/ssl">申请 SSl 证书</a>了</p><p>我们可以直接申请免费证书 1 年有效期，验证还是非常快的</p><hr><h1 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h1><h2 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h2><p>包管理器安装很方便</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>安装的版本是<code>1.8.3.1</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/gitversion1.8.png"></p><p>要安装最新版的 git 需要去官网上下载源码后安装</p><h2 id="安装-Python3-环境"><a href="#安装-Python3-环境" class="headerlink" title="安装 Python3 环境"></a>安装 Python3 环境</h2><p>系统自带的 Python 环境为</p><p><code>Python 2.7.5</code></p><p>我们想要安装最新的 <code>Python</code>环境</p><h3 id="准备最新的-Python3-安装包"><a href="#准备最新的-Python3-安装包" class="headerlink" title="准备最新的 Python3 安装包"></a>准备最新的 Python3 安装包</h3><p>先从官网上下载安装包，实验时的最新版为<code>Python3.8.3</code></p><p>可以利用<code>Transmit</code>之类的传输工具很方便的拖拽到服务器上，</p><p>这里直接拖到<code>/root</code>目录下</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/py383tgz.png" alt="image-20200621231542906"></p><p>输入命令解压</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf Python-3.8.3.tgz</span><br></pre></td></tr></table></figure><h3 id="安装相关环境"><a href="#安装相关环境" class="headerlink" title="安装相关环境"></a>安装相关环境</h3><p>直接运行下列命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlitedevel readline-devel tk-devel gcc make</span><br></pre></td></tr></table></figure><h3 id="编译与安装"><a href="#编译与安装" class="headerlink" title="编译与安装"></a>编译与安装</h3><p>这里指定了安装目录为<code>/usr/local/python3</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Python-3.8.3/</span><br><span class="line">./configure prefix=/usr/<span class="built_in">local</span>/python3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="添加符号链接"><a href="#添加符号链接" class="headerlink" title="添加符号链接"></a>添加符号链接</h3><p>将链接接到<code>/usr/bin</code>目录下，方便以后使用 <code>Python3</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/python3 /usr/bin/python3</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/py383installed.png" alt="Python3.8.3安装完成"></p><h2 id="Node-js-环境安装"><a href="#Node-js-环境安装" class="headerlink" title="Node.js 环境安装"></a>Node.js 环境安装</h2><h3 id="准备最新的安装包"><a href="#准备最新的安装包" class="headerlink" title="准备最新的安装包"></a>准备最新的安装包</h3><p>我们直接从官网上下载最新版本的源码<code>node-v12.18.1.tar.gz</code>，将其放在了<code>\root</code>目录下</p><h3 id="创建目录并解压"><a href="#创建目录并解压" class="headerlink" title="创建目录并解压"></a>创建目录并解压</h3><p>在<code>/usr/local</code>下创建<code>node</code>文件夹并进入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/ </span><br><span class="line">mkdir node </span><br><span class="line"><span class="built_in">cd</span> node</span><br></pre></td></tr></table></figure><p>将<code>Node</code>安装包解压到<code>/usr/local/node</code>中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xJvf /root/node-v12.18.1-linux-x64.tar.xz -C ./</span><br></pre></td></tr></table></figure><p>解压完成，在<code>/usr/local/node</code>目录中出现一个<code>node-v12.18.1-linux-x64</code>文件夹</p><h3 id="配置Node系统环境变量"><a href="#配置Node系统环境变量" class="headerlink" title="配置Node系统环境变量"></a>配置Node系统环境变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~./bash_profile</span><br></pre></td></tr></table></figure><p>在文件末尾添加信息：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Nodejs</span></span><br><span class="line"><span class="attr">export</span> <span class="string">PATH=/usr/local/node/node-v12.18.1-linux-x64/bin:$PATH</span></span><br></pre></td></tr></table></figure><p>然后刷新环境变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><h3 id="检查安装结果"><a href="#检查安装结果" class="headerlink" title="检查安装结果"></a>检查安装结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm version</span><br><span class="line">npx -v</span><br></pre></td></tr></table></figure><p>均有版本输出信息即可</p><h2 id="Nginx-安装"><a href="#Nginx-安装" class="headerlink" title="Nginx 安装"></a>Nginx 安装</h2><p>我们直接使用 <code>yum</code>进行安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure><p>启动<code>Nginx</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service nginx start</span><br></pre></td></tr></table></figure><p>测试<code>Nginx</code>服务器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://127.0.0.1</span><br></pre></td></tr></table></figure><p>接下来输入公网 ip，测试网页是否能够打开，看到 <code>Nginx</code> 欢迎页面即可</p><p>托管文件目录的改变将会放到下一篇<a class="btn-beautify button--animated blue larger" href="/2020/06/22/Config-my-centos-server-II/#Nginx%E7%9A%84%E9%85%8D%E7%BD%AE"   title="Linux Learning II"><i class="far fa-hand-point-right fa-fw"></i><span>Linux Learning II</span></a></p><h2 id="MySQL-数据库的安装"><a href="#MySQL-数据库的安装" class="headerlink" title="MySQL 数据库的安装"></a>MySQL 数据库的安装</h2><p>由于 Centos 的 yum 源中没有 MySQL，需要到 MySQL 官网下载 yum repo 的配置文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/mysql-yum-no.png" alt="no-mysql-server"></p><h3 id="下载配置文件"><a href="#下载配置文件" class="headerlink" title="下载配置文件"></a>下载配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure><h3 id="进行-repo-的安装"><a href="#进行-repo-的安装" class="headerlink" title="进行 repo 的安装"></a>进行 repo 的安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure><h3 id="启动-MySQL"><a href="#启动-MySQL" class="headerlink" title="启动 MySQL"></a>启动 MySQL</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure><h3 id="查看临时密码"><a href="#查看临时密码" class="headerlink" title="查看临时密码"></a>查看临时密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&#x27;temporary password&#x27;</span> /var/<span class="built_in">log</span>/mysqld.log</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/mysqltemppwd.png" alt="temporary-password"></p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set password&#x3D;password(&quot;&lt;你的密码&gt;&quot;);</span><br></pre></td></tr></table></figure><p>要注意密码需要有一定的强度</p><h3 id="修改远程访问"><a href="#修改远程访问" class="headerlink" title="修改远程访问"></a>修改远程访问</h3><p>MySQL 默认不开启远程访问，默认只能是自己的机器，</p><p>接下来使用<code>grant</code>命令来修改</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant all privileges on *.* to root@&quot;你的 ip 地址&quot; identified by &quot;你的密码&quot;;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>*.*</code>表示所有数据库</li><li><code>root</code>代表用户名</li><li><code>root</code>后的 IP地址如果写成<code>%</code>则表示任意的客户端，写成<code>localhost</code>则只能本地访问</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/testconnectmysql.jpg" alt="testconnectmysql"></p><p>成功连接即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/mysqlconnectsuccess.png" alt="mysql-connection-success"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><ul><li><a href="https://blog.csdn.net/wohiusdashi/article/details/89358071">MySQL 的安装</a></li><li><a href="https://github.com/hansonwang99/JavaCollection">JavaCollection</a></li></ul></blockquote><p>下一篇将会讲 Hexo 博客的迁移</p>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
          <category> BuildDevEnv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask博客开发记录</title>
      <link href="2020/06/03/Flask-dev-note/"/>
      <url>2020/06/03/Flask-dev-note/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="一、项目简介"><a href="#一、项目简介" class="headerlink" title="一、项目简介"></a>一、项目简介</h1><h2 id="1-做了什么？"><a href="#1-做了什么？" class="headerlink" title="1. 做了什么？"></a>1. 做了什么？</h2><ul><li>我做的这个项目是一个基于 flask（一个Python 后端框架） 的博客网站</li></ul><h2 id="2-为什么想到要做这么一个项目？"><a href="#2-为什么想到要做这么一个项目？" class="headerlink" title="2. 为什么想到要做这么一个项目？"></a>2. 为什么想到要做这么一个项目？</h2><ol><li>因为平时有不懂的问题在搜索引擎上进行搜索时，一般跳出来的前几名答案都来自诸如 csdn，博客园，简书等等博客网站的回答，故觉得博客很有用；</li><li>很多大牛都在写自己的博客，比如阮一峰、廖雪峰等，我们写了是不是可以与他们稍稍拉近距离呢？</li><li>我们学习时往往只注重了输入，一味地学习通常会感觉知识点记不住，每次用到时都要去查，我觉得不如能自己写博客，培养自己的总结能力与习惯，当我们有知识的输出时，我们才会对知识记忆和理解得更深刻，这样即使以后忘了，看一眼自己总结过的知识点，回忆起来会想当迅速。</li></ol><h2 id="3-如何实现或者有哪些解决方案？"><a href="#3-如何实现或者有哪些解决方案？" class="headerlink" title="3. 如何实现或者有哪些解决方案？"></a>3. 如何实现或者有哪些解决方案？</h2><ul><li>最方便的当然是去各大知名博客网站，在那里进行写作，这是最轻松方便的，不需要操心任何事情专心写作即可；</li><li>或者可以使用一些博客框架，比如一些静态博客框架如 <code>hexo</code>（基于<code>node.js</code>），<code>hugo</code>（基于<code>go</code>）和一些动态博客框架如 <code>WordPress</code>，<code>typecho</code> 等，这些博客框架搭建完环境后也非常容易写作，主要是可以将网站的主题改成自己喜爱的样子；</li><li>还有一种当然是所有的都是自己实现了，也就是自己写一个博客网站，我感觉这个要做的好，要求比较很高，需要有扎实 web 开发的基础。</li></ul><h1 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h1><p>一个博客需要有什么功能呢？</p><p>我们可以从各大博客网站，博客框架中进行归纳总结，我总结出来一些功能：</p><ol><li>注册、登录、注销、后台管理界面（本条针对动态博客）</li><li>写文章、编辑更新文章、查看文章、删除文章</li><li>点赞、评论、分享</li><li>支持 markdown 语法写作</li><li>个人资料页的展示（包括作者资料，最近发表的文章）</li><li>…</li></ol><h1 id="三、技术点简介"><a href="#三、技术点简介" class="headerlink" title="三、技术点简介"></a>三、技术点简介</h1><h2 id="1-flask"><a href="#1-flask" class="headerlink" title="1. flask"></a>1. flask</h2><p>flask 是我项目用到的一个 Python Web后端框架，特点是轻量级，支持自由灵活高度定制，（虽然对我一个没有什么开发经验的人来说没有什么区别）。</p><p>当然，与 flask 同一类型的 Python 开发框架就是大名鼎鼎的 <code>Django</code> 了，我们可以根据官方文档总结一下他们的特点</p><table><thead><tr><th align="center">项目</th><th align="center">Flask</th><th align="center">Django</th></tr></thead><tbody><tr><td align="center">量级</td><td align="center">轻量级</td><td align="center">重量级</td></tr><tr><td align="center">特点</td><td align="center">只提供 web 框架的核心功能，自由灵活高度定制</td><td align="center">为方便业务程序的开发，提供了丰富的工具、组件</td></tr><tr><td align="center">用此框架实现的网站</td><td align="center">LinkedIn，Netflix，Twilio，Uber</td><td align="center">Bitbucket，Eventbrite， Instagram，Pinterest</td></tr></tbody></table><p>我选择 flask 的原因很大一部分原因是因为简单，因为我只是开发一个小网站，并不是大型网站，使用<code>Django</code>的话感觉学习成本更高。</p><h2 id="2-数据库的选择"><a href="#2-数据库的选择" class="headerlink" title="2. 数据库的选择"></a>2. 数据库的选择</h2><p>根据 flask 的官方文档，推荐可供选择的数据库是：<code>SQLite</code> 和 <code>SQLAlchemy</code></p><p>他们的特点是</p><table><thead><tr><th align="center">SQLite 3</th><th align="center">SQLAlchemy</th></tr></thead><tbody><tr><td align="center">Python 内置，简单</td><td align="center">需要额外配置，比较麻烦</td></tr><tr><td align="center">适用于小型应用，不适合并发场合</td><td align="center">适用于大型应用、高并发场合</td></tr></tbody></table><p>很显然，SQLite 适合我这个小项目，用不上并发编程，所以我选了 SQLite3。</p><h2 id="3-前端的模版"><a href="#3-前端的模版" class="headerlink" title="3. 前端的模版"></a>3. 前端的模版</h2><p>从服务器端取出的数据当然需要在前端展示，flask 中引入了一个叫<code>Jinja</code>的模版引擎，这个引擎可以很方便地来实现：</p><ul><li>子页面继承母版页面；</li><li>从服务器端取出的数据通过变量插入模版展示在前端；</li><li>前端页面插入<code>if</code>条件语句,<code>for</code>循环语句来帮助我们控制前端展示的逻辑。</li></ul><p>这是一个<code>Jinja</code>文档中简单的例子：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/jinja.png" alt="image-20200602161135385"></p><p>可以看到，使用<code>&#123;&#123;一个变量/表达式&#125;&#125;</code>的形式可以很轻松地插入表达式或传递变量。</p><h1 id="四、功能的实现"><a href="#四、功能的实现" class="headerlink" title="四、功能的实现"></a>四、功能的实现</h1><p>从我分析的需求中，（由于能力和精力有限）我挑选了一些功能进行实现。</p><ul><li><p><input checked="" disabled="" type="checkbox">  登录，注册，注销 </p></li><li><p><input checked="" disabled="" type="checkbox">  评论</p></li><li><p><input checked="" disabled="" type="checkbox">  写文章，查看文章，编辑文章，删除文章</p></li><li><p><input checked="" disabled="" type="checkbox">  markdown语法写作支持</p></li><li><p><input checked="" disabled="" type="checkbox">  个人资料页的展示</p></li><li><p><input checked="" disabled="" type="checkbox">  上传图片(文章封面图，作者个人图片)</p></li><li><p><input disabled="" type="checkbox">  点赞、分享</p></li><li><p><input disabled="" type="checkbox">  文章目录（点了就能直接跳转的那种）</p></li><li><p><input disabled="" type="checkbox">  分享功能（分享到 QQ，微信）</p></li><li><p><input disabled="" type="checkbox">  …</p></li></ul><p>刚开始觉得看着简单，但真正地实现这些功能，不自己动手写一写真实不知道会遇到的坑和 bug 真是数不胜数，下面简单地说一下实现思路：</p><ol><li><p>账号管理</p><ul><li>基本的账号管理，牵涉到数据库的CRUD；</li><li>注册时，首先需要判断是否和已有账号重复，前端对密码验证时，进行了两次验证，确保密码输入一致，保存密码到数据库时，不建议直接明文保存，还好 flask 提供了一个<code>generate_password_hash(password)</code>的函数，对明文密码先进行 hash，再存储到数据库中；</li><li>登录时对用户输入的用户名密码进行检查，若无误，则把<code>session</code>赋值为登录用户；</li><li>注销时，对<code>session</code>进行清除即可。</li></ul></li><li><p>文章的操作</p><ul><li>写（编辑）需要用到前端的<code>Webform</code>，将文章的信息，内容保存到数据库中；</li><li>为了实现<code>markdown</code>写作，Python 中正好题库了这么一个库，就叫<code>markdown</code>，它可以将<code>markdown</code>语法的字符串转换为带有<code>html</code>标记，再通过<code>jinja</code>模版引擎，把已经转换到带有<code>html</code>标记的文章嵌入前端页面中，即可实现，展示效果通过<code>css</code>实现；</li></ul></li><li><p>图片（文件）上传</p><ul><li>图片如何上传呢？图片不是文本文件，不能直接保存到数据库中；</li><li>我在网上搜索了解决方案，一种是使用编码方式，将图片转换为编码文本（如<code>Base64</code>）再存入数据库。仔细想了一下，感觉不适用，首先是因为麻烦，每次浏览时都需要从数据库中取出编码文本，进行译码，形成图片文件，其次是前端展示时需要用到<code>&lt;img src=&quot;&quot;&gt;</code>标签，那么我们的文件超链接哪里来呢？感觉实现困难。</li><li>第二种方式比较可行，即当上传一张图片时，服务器将图片保存到本地的文件系统中，同时形成绝对地址，再将地址保存到数据库中，这样不仅方便取，也方便更新文件。</li><li>保存文件使用了 Python 中的<code>os</code>内置库，非常方便。想到文件的重名问题，我还引入了 time 库，用户上传文件时，通过获取当前的系统时间，对文件重命名为<code>年月日时分秒.jpg</code>这样的格式，保证不会重复；</li><li>当用户更新自己的图片时，从数据库中取出已有的文件路径，对其进行删除，再保存新文件到本地文件系统，将路径存放到数据库中。</li></ul></li><li><p>评论</p><ul><li>评论我没有自己进行实现，由于我自己 hexo 博客是引入的是<code>valine</code>的无数据库评论模块，简单，方便，美观（何必重复造轮子呢？）只需要引入<code>js</code>就能够嵌入前端页面中。</li></ul></li></ol><h1 id="五、项目结构"><a href="#五、项目结构" class="headerlink" title="五、项目结构"></a>五、项目结构</h1><p>下面是项目的主要组成结构树形图，对主要的文件（夹）我进行了说明：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">37 directories</span><br><span class="line"> lixing  ~/PycharmProjects/MyBlog/flaskr   master  tree</span><br><span class="line">.</span><br><span class="line">├── __init__.py // 工厂函数文件</span><br><span class="line">├── auth.py // 账号相关操作的代码</span><br><span class="line">├── blog.py // 博客文章相关代码</span><br><span class="line">├── config.py // 对文件路径进行配置</span><br><span class="line">├── db.py // 数据库相关代码</span><br><span class="line">├── schema.sql // 初始化数据库（建表）的代码</span><br><span class="line">├── setup.py // 配置相关代码</span><br><span class="line">├── static // 静态文件（css，图片，js）</span><br><span class="line">│   ├── blog.css</span><br><span class="line">│   ├── images</span><br><span class="line">│   │   ├── bg4.jpg</span><br><span class="line">│   │   ├── default</span><br><span class="line">│   │   │   ├── default.jpg</span><br><span class="line">│   │   │   └── post.jpg</span><br><span class="line">│   │   ├── footer-bg.png</span><br><span class="line">│   │   └── upload</span><br><span class="line">│   │       ├── avatars</span><br><span class="line">│   │       └── postImages</span><br><span class="line">│   ├── styles.css</span><br><span class="line">│   └── theme // 这个是我套用的一个 bootstrap 模版的相关文件</span><br><span class="line">│       ├── css</span><br><span class="line">│       │   ├── maps</span><br><span class="line">│       │   │   └── style.css.map</span><br><span class="line">│       │   └── style.css</span><br><span class="line">│       ├── images</span><br><span class="line">│       ├── js</span><br><span class="line">│       │   └── script.js</span><br><span class="line">│       ├── plugins</span><br><span class="line">│       │   ├── bootstrap</span><br><span class="line">│       │   ├── fonts</span><br><span class="line">│       │   ├── jQuery</span><br><span class="line">│       │   ├── shuffle</span><br><span class="line">│       │   ├── slick</span><br><span class="line">│       │   └── themify-icons</span><br><span class="line">│       └── scss</span><br><span class="line">└── templates // 母版文件夹</span><br><span class="line">    ├── Homepage.html</span><br><span class="line">    ├── auth</span><br><span class="line">    │   ├── info.html</span><br><span class="line">    │   ├── login.html</span><br><span class="line">    │   ├── register.html</span><br><span class="line">    │   └── update.html</span><br><span class="line">    └── blog</span><br><span class="line">        ├── create.html</span><br><span class="line">        ├── detail.html</span><br><span class="line">        ├── index.html</span><br><span class="line">        └── update.html</span><br></pre></td></tr></table></figure><h1 id="六、项目展示"><a href="#六、项目展示" class="headerlink" title="六、项目展示"></a>六、项目展示</h1><ol><li><p>配置<code>flask</code>运行环境，初始化数据库，启动项目</p> <figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">(venv)  lixing  ~/PycharmProjects/MyBlog   master  <span class="built_in">export</span> FLASK_APP=flaskr     </span><br><span class="line">(venv)  lixing  ~/PycharmProjects/MyBlog   master  <span class="built_in">export</span> FLASK_ENV=development</span><br><span class="line">(venv)  lixing  ~/PycharmProjects/MyBlog   master  flask init-db               </span><br><span class="line">Initialized the database.</span><br><span class="line">(venv)  lixing  ~/PycharmProjects/MyBlog   master  flask run</span><br><span class="line"> * Serving Flask app <span class="string">&quot;flaskr&quot;</span> (lazy loading)</span><br><span class="line"> * Environment: development</span><br><span class="line"> * Debug mode: on</span><br><span class="line"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br><span class="line"> * Restarting with <span class="built_in">stat</span></span><br><span class="line"> * Debugger is active!</span><br><span class="line"> * Debugger PIN: 757-386-815</span><br></pre></td></tr></table></figure></li><li><p>后序步骤省略（因为不想贴图了）具体可以去项目地址看：</p><ul><li><a href="https://github.com/jzhmcoo1/MyBlog">https://github.com/jzhmcoo1/MyBlog</a></li></ul></li></ol><h1 id="七、项目总结"><a href="#七、项目总结" class="headerlink" title="七、项目总结"></a>七、项目总结</h1><ol><li>我遇到的困难<ul><li>这是我第一次自己写小项目，我懂得了从一个需求到具体功能的实现是非常不易的，有的时候思路不对，有的时候是遇到了 bug，这个过程是十分艰辛的。</li><li>我的 web 开发基础非常差，是这个学期现学现卖，而且懂得也太少了，经常会传递错页面的参数，以及页面的布局达不到想要的效果。</li><li>大多数的技术点，Python 库，框架的使用，如果不能查到类似的中文博客实现的话，就只能去看官方文档，往往需要查看英文文档，看着英文头疼往往成了最大的阻碍，只能硬着头皮看。</li></ul></li><li>我的收获<ul><li>非常感谢有这个机会来动手实践，实际操作一下，让我知道了自己的不足，我也收获了自己的第一个小项目。</li><li>培养了我的自学能力和动手能力，并且也锻炼了我的抽象能力和逻辑思维能力。</li><li>知道了不足之后，就用了努力的目标和方向，今后会加强基础，学习web开发框架。</li></ul></li><li>其他<ul><li>作为我的第一个项目，我将它开源到了 Github 上，希望有时间能够多多维护更新<ul><li><a href="https://github.com/jzhmcoo1/MyBlog">https://github.com/jzhmcoo1/MyBlog</a></li></ul></li></ul></li></ol><h1 id="八、参考文档"><a href="#八、参考文档" class="headerlink" title="八、参考文档"></a>八、参考文档</h1><ul><li><a href="https://dormousehole.readthedocs.io/en/latest/index.html">欢迎来到 Flask 的世界 — Flask 中文文档（ 1.1.1 ）</a></li><li><a href="https://jinja.palletsprojects.com/en/2.11.x/templates/">Template Designer Documentation — Jinja Documentation (2.11.x)</a></li><li><a href="https://github.com/Blackyukun/quiet">Blackyukun/quiet: 支持上传 markdown 文件生成 html 的 flask 静态博客</a></li><li><a href="https://python-markdown.github.io/sitemap.html">Sitemap — Python-Markdown 3.2.2 documentation</a></li><li><a href="https://juejin.im/entry/5a8d8776f265da4e8b2feac7">基于flask的静态博客 - 后端 - 掘金</a></li><li><a href="https://valine.js.org/quickstart.html">快速开始 | Valine 一款快速、简洁且高效的无后端评论系统。</a></li><li><a href="https://themefisher.com/products/kross-creative-portfolio-template/">kross - bootstrap 前端模版</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> DevNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Share Some Useful Tools</title>
      <link href="2020/05/22/app-share-I/"/>
      <url>2020/05/22/app-share-I/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第一次写随笔奥，今天就来分享一些好用的小工具/有用的网站吧。</p><hr><h1 id="代码截图生成——Carbon"><a href="#代码截图生成——Carbon" class="headerlink" title="代码截图生成——Carbon"></a>代码截图生成——Carbon</h1><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>carbon 是一个生成代码截图的网站。网站上可以复制进代码，然后返回代码高亮的代码截图图片。可以自定义样式或者使用预定义样式，支持使用 github 登录，这样，自定义样式就能被保存下来了。</p><p>具体可以看：<a href="https://carbon.now.sh/about">about - carbon</a></p><h2 id="网址："><a href="#网址：" class="headerlink" title="网址："></a>网址：</h2><p><a href="https://carbon.now.sh/">https://carbon.now.sh</a></p><h2 id="截图："><a href="#截图：" class="headerlink" title="截图："></a>截图：</h2><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/carbon.png" style="zoom:50%;" /><hr><h1 id="画图工具——draw-io"><a href="#画图工具——draw-io" class="headerlink" title="画图工具——draw.io"></a>画图工具——draw.io</h1><h2 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h2><p>一款开源的、在线的画图工具，支持多种图形，支持分享，支持存储在云盘</p><p>具体可以看介绍：<a href="https://www.diagrams.net/">draw.io介绍</a> ，网站支持简体中文。</p><h2 id="网址：-1"><a href="#网址：-1" class="headerlink" title="网址："></a>网址：</h2><p><a href="https://app.diagrams.net/">https://app.diagrams.net</a></p><h2 id="截图：-1"><a href="#截图：-1" class="headerlink" title="截图："></a>截图：</h2><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/drawio.png" style="zoom:50%;" /><hr><h1 id="歌单导入——Spot"><a href="#歌单导入——Spot" class="headerlink" title="歌单导入——Spot"></a>歌单导入——Spot</h1><h2 id="简介：-2"><a href="#简介：-2" class="headerlink" title="简介："></a>简介：</h2><p>支持从网易云、QQ、虾米、百度音乐歌单导入到 spotify 中。只需要复制歌单的链接，黏贴进去即可自动导入。</p><h2 id="网站："><a href="#网站：" class="headerlink" title="网站："></a>网站：</h2><p><a href="https://spot.uselesses.com/#/">https://spot.uselesses.com/#/</a></p><h2 id="截图：-2"><a href="#截图：-2" class="headerlink" title="截图："></a>截图：</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/spotspot.jpg"></p><hr><h1 id="PDF-文档电子书查找——鸠摩搜书"><a href="#PDF-文档电子书查找——鸠摩搜书" class="headerlink" title="PDF 文档电子书查找——鸠摩搜书"></a>PDF 文档电子书查找——鸠摩搜书</h1><h2 id="简介：-3"><a href="#简介：-3" class="headerlink" title="简介："></a>简介：</h2><p>一个界面简介的搜索 PDF 的网站，资源还是很丰富的</p><p>具体可以看：<a href="https://www.jiumodiary.com/info.php">Info | Jiumo E-Book Search</a></p><h2 id="网站：-1"><a href="#网站：-1" class="headerlink" title="网站："></a>网站：</h2><p><a href="https://www.jiumodiary.com/">https://www.jiumodiary.com</a></p><h2 id="截图：-3"><a href="#截图：-3" class="headerlink" title="截图："></a>截图：</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/soushu.png"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 工具分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS盒子模型I</title>
      <link href="2020/05/18/CSS-Box-Model/"/>
      <url>2020/05/18/CSS-Box-Model/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Block-and-inline-boxes"><a href="#Block-and-inline-boxes" class="headerlink" title="Block and inline boxes"></a>Block and inline boxes</h1><h2 id="定义为-block："><a href="#定义为-block：" class="headerlink" title="定义为 block："></a>定义为 <code>block</code>：</h2><ul><li>盒子会换行</li><li>盒子会向内联方向延展，填充容器中的可用空间（大多数情况会填满所有空间，和容器大小一样）</li><li><code>width</code>和<code>height</code>属性可以发挥作用</li><li><code>padding</code>,<code>margin</code>,<code>height</code>属性将会把其他元素推离盒子</li><li><code>&lt;p&gt;</code>和所有的标题<code>&lt;h1&gt;</code>等是 <strong>默认采用 block</strong>的</li></ul><h2 id="定义为inline"><a href="#定义为inline" class="headerlink" title="定义为inline:"></a>定义为<code>inline</code>:</h2><ul><li>盒子不会换行</li><li><code>width</code>和<code>height</code>属性将不会起作用</li><li><strong>垂直方向</strong>的<code>padding</code>,<code>margin</code>,<code>border</code>能起作用但不会使得其他<code>inline</code>盒子被推离</li><li><strong>水平方向</strong>的<code>padding</code>,<code>margin</code>,<code>border</code>能起作用并且会推离其他盒子</li><li><code>&lt;a&gt;</code>，<code>&lt;span&gt;</code>,<code>&lt;em&gt;</code>,<code>&lt;strong&gt;</code>都是 <strong>默认采用 inline</strong>显示的</li></ul><hr><h1 id="Aside-Inner-and-outer-display-types"><a href="#Aside-Inner-and-outer-display-types" class="headerlink" title="Aside: Inner and outer display types"></a>Aside: Inner and outer display types</h1><ul><li><p>block 和 inline 都是代表 outer display type</p></li><li><p>Box 的 inner display type 则表示了 box 内部是如何布局的，默认是正常的</p></li><li><p>当我们使用<code>display:flex</code>之类的设置时，外部的显示类型是<code>block</code>，但是内部的显示类型是<code>flex</code>的，此盒子的任何直接子级都将成为<code>flex</code>项目，并且根据 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox">Flexbox</a> 规则布局。</p></li><li><p><code>block</code>和<code>inline</code>布局都是被视作正常的情况，即没有任何指定时，盒子都是根据这两个来布局的</p></li></ul><p>我自己的理解：</p><p>当盒子被声明为 flex 时，盒子本身是 block 的，对（默认为block的标签来说），而内部的显示为 flex</p><p>当盒子被声明为 inline-flex 时，盒子本身将成为 inline，而内部显示为 flex</p><p>为了确定我看完文档，理解是正确的，不妨我们动手实践一下，修改 mdn 上的代码</p><p>源代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>I am a paragraph. A short one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item One<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item Two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item Three<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>I am another paragraph. Some of the <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;block&quot;</span>&gt;</span>words<span class="tag">&lt;/<span class="name">span</span>&gt;</span> have been wrapped in a <span class="tag">&lt;<span class="name">span</span>&gt;</span>span element<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>, </span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid rebeccapurple;</span><br><span class="line">  <span class="attribute">padding</span>: .<span class="number">5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block</span>,</span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid blue;</span><br><span class="line">  <span class="attribute">padding</span>: .<span class="number">5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure><p>我们将代码 14 行<code>display</code>改成<code>inline-flex</code>, （为了查看效果，<code>&lt;p&gt;</code> 默认的是<code>block</code>的，这里显示地更改其为<code>inline</code>)，应该会看到<code>&lt;p&gt;</code>元素与<code>&lt;ul&gt;</code>元素拼入同一行了。</p><p>查看效果对比：</p><p>原来：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/css-box-flex.png"></p><p>修改完毕：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/css-box-inline-flex.png"></p><p>虽然显示效果不好，但是的确修改之后，<code>&lt;ul&gt;</code>和<code>&lt;p&gt;</code>元素成为了内联元素，拼接在了同一行了。</p><hr><h1 id="CSS-box-model"><a href="#CSS-box-model" class="headerlink" title="CSS box model"></a>CSS box model</h1><h2 id="标准盒子模型"><a href="#标准盒子模型" class="headerlink" title="标准盒子模型"></a>标准盒子模型</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/box-model.png"></p><p>这是 block box 模型的图，其中：</p><ul><li>Content box: 作为展示内容的区域，可以通过<code>width</code>和<code>height</code>来调整大小</li><li>Padding box: 位于内容区域的周围空白部分，可以通过<code>padding</code>来调整</li><li>Border box: 边框包围了内容和内边距，通过<code>border</code>和相关属性来调整</li><li>Margin box: 外边距包围了内容，内边距和边框，作为此盒子与其他元素的空白部分，通过<code>margin</code>和相关属性调整</li></ul><h2 id="替代盒子模型"><a href="#替代盒子模型" class="headerlink" title="替代盒子模型"></a>替代盒子模型</h2><p>标准盒子模型的实际宽度是$content.width+2\times padding+2\times border$的结果，同理实际高度</p><p>而这对于计算实际大小是不方便的，因此可以设置为 <strong>替代盒子模型</strong> </p><p>使用了替代盒子模型后，内容区域的实际宽度是：$content.width=width_{real}-2\times padding -2\times border$</p><p>即对盒子显式设置的宽度和高度，就是盒子显示的大小</p><p>通过<code>box-sizing:border-box;</code> 来设置。</p><p>如果需要所有元素都是用替代框盒子，可以设置<code>box-sizing</code>属性，以及将所有其他元素设置为继承该值，如下面的代码片段：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line">*, *<span class="selector-pseudo">::before</span>, *<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MDN-上的例子"><a href="#MDN-上的例子" class="headerlink" title="MDN 上的例子"></a>MDN 上的例子</h2><p>通过计算，修改<code>.alternate</code>里的<code>height</code>和<code>width</code>属性分别为<code>240px</code>和<code>390px</code>即可解决</p>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> BoxModel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS selectors I</title>
      <link href="2020/04/17/CSS-Selectors-I/"/>
      <url>2020/04/17/CSS-Selectors-I/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>本文根据 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors">MDN文档</a> 进行总结</p></blockquote><hr><h1 id="类型选择器（Type-selectors）"><a href="#类型选择器（Type-selectors）" class="headerlink" title="类型选择器（Type selectors）"></a>类型选择器（Type selectors）</h1><blockquote><p><strong>类型选择器</strong>，也叫“标签名选择器”或“元素选择器”，在文档中选择一个 HTML 标签。</p></blockquote><p>如：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: rebeccapurple;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">em</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: rebeccapurple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="全局选择器（Universal-selector）"><a href="#全局选择器（Universal-selector）" class="headerlink" title="全局选择器（Universal selector）"></a>全局选择器（Universal selector）</h1><blockquote><p>全局选择器，是由一个星号（<code>*</code>）代指的，它选中了文档中的所有内容（或者是父元素中的所有内容，比如，它紧随在其他元素以及邻代运算符之后的时候）。</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用全局选择器、让选择器更易读"><a href="#使用全局选择器、让选择器更易读" class="headerlink" title="使用全局选择器、让选择器更易读"></a>使用全局选择器、让选择器更易读</h2><blockquote><p>全局选择器的一种用法是让选择器更易读，更明显地表明它们的作用。</p><p>例如，如果我想选中任何元素的第一子元素，不论它是什么元素，都给它加粗，我可以将<code>:first-child</code>选择器用作元素选择器的一个兄弟选择器：</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    select any &lt;article&gt; element that is the first child of another element.</span></span><br><span class="line"><span class="comment">    /*</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>但是这会和<code>article:first-child</code>混淆，而后者选择了作为其他元素的第一子元素的<code>&lt;article&gt;</code>元素。</p><p>为了避免这种混淆，我们可以向<code>:first-child</code>选择器加入全局选择器，这样选择器所做的事情很容易就能看懂。选择器正选中<code>&lt;article&gt;</code>元素的<em>任何</em>第一子元素：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> *<span class="selector-pseudo">:first</span>-child &#123; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     选中&lt;article&gt;元素的第一子元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h1 id="类选择器（Class-selectors）"><a href="#类选择器（Class-selectors）" class="headerlink" title="类选择器（Class selectors）"></a>类选择器（Class selectors）</h1><blockquote><p>类选择器以一个句点（<code>.</code>）开头，会选择文档中应用了这个类的所有物件。</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">选中所有类为 highlight 的标签</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-class">.highlight</span>&#123;</span><br><span class="line">     <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指向特点元素的类"><a href="#指向特点元素的类" class="headerlink" title="指向特点元素的类"></a>指向特点元素的类</h2><blockquote><p>You can create a selector that will target specific elements with the class applied. </p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">选中类为 hightlight 的 span 元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-class">.highlight</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">选中类为 hightlight 的 h1 元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-class">.highlight</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多个类被应用的时候指向一个元素"><a href="#多个类被应用的时候指向一个元素" class="headerlink" title="多个类被应用的时候指向一个元素"></a>多个类被应用的时候指向一个元素</h2><p>你能对一个元素应用多个类，然后分别指向它们，或者仅仅在选择器中存在所有这些类的时候选择这一元素。在你的站点上，构建可以以不同方式组合起来的组件的时候，这会有用。为了告诉浏览器我们只想匹配带有所有这些类的元素，我们可以将这些类不加空格地连成一串。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.notebox</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">4px</span> solid <span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.notebox</span><span class="selector-class">.warning</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">4px</span> solid orange;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.notebox</span><span class="selector-class">.danger</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">4px</span> solid red;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;notebox&quot;</span>&gt;</span></span><br><span class="line">    This is an informational note.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;notebox warning&quot;</span>&gt;</span></span><br><span class="line">    This note shows a warning.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;notebox danger&quot;</span>&gt;</span></span><br><span class="line">    This note shows danger!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h1 id="ID-选择器（ID-selector）"><a href="#ID-选择器（ID-selector）" class="headerlink" title="ID 选择器（ID selector）"></a>ID 选择器（ID selector）</h1><p>ID选择器开头为<code>#</code>而非句点，不过基本上和类选择器是同种用法。可是在一篇文档中，一个ID只会用到一次。它能选中设定了<code>id</code>的元素，你能把ID放在类型选择器之前，只指向元素和ID都匹配的类。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">选择 id=one 的标签</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-id">#one</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">选择 id=heading 的 h1 标签</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-id">#heading</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: rebeccapurple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="属性选择器（Attribute-selectors）"><a href="#属性选择器（Attribute-selectors）" class="headerlink" title="属性选择器（Attribute selectors）"></a>属性选择器（Attribute selectors）</h1><h2 id="存在和值选择器（Presence-and-value-selectors）"><a href="#存在和值选择器（Presence-and-value-selectors）" class="headerlink" title="存在和值选择器（Presence and value selectors）"></a>存在和值选择器（Presence and value selectors）</h2><blockquote><p>These selectors enable the selection of an element based on the presence of an attribute alone (for example <code>href</code>), or on various different matches against the value of the attribute.</p></blockquote><table><thead><tr><th align="center">选择器</th><th align="center">示例</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>[attr]</code></td><td align="center"><code>a[title]</code></td><td align="center">匹配带有一个名为 <em>attr</em>的属性元素</td></tr><tr><td align="center"><code>[attr=value]</code></td><td align="center"><code>a[href=&quot;https://example.com&quot;]</code></td><td align="center">匹配带有一个名为 attr 且其值恰好为 value 的元素</td></tr><tr><td align="center"><code>[attr~=value]</code></td><td align="center"><code>p[class~=&quot;special&quot;]</code></td><td align="center">匹配具有 attr 属性的元素，且其值恰好是 value 或者在其（空格分隔）的值列表中包含 value</td></tr><tr><td align="center"><code>[attr</code>&#124;<code>=value]</code></td><td align="center"><code>div[lang</code>&#124;<code>=&#39;zh&#39;]</code></td><td align="center">匹配具有attr 属性的元素，该属性的值恰好是 value 或者以 value 开头，后跟连字符</td></tr></tbody></table><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[class]</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    匹配带有 class 属性的 li 元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[class=<span class="string">&quot;a&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    匹配带有值恰好为&quot;a&quot;的 class 属性的 li 元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[class~=<span class="string">&quot;a&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    匹配带有值恰好为&quot;a&quot;或值列表中包含&quot;a&quot;的 li 元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Attribute presence and value selectors<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;a b&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;ab&quot;</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>By using <code>li[class]</code> we can match any selector with a class attribute. This matches all but the first list item.</li><li><code>li[class=&quot;a&quot;]</code> matches a selector with a class of <code>a</code>, but not a selector with a class of <code>a</code> with another space-separated class as part of the value. It selects the second list item.</li><li><code>li[class~=&quot;a&quot;]</code> will match a class of <code>a</code> but also a value that contains the class of <code>a</code>as part of a whitespace-separated list. It selects the second and third list items.</li></ul><hr><h2 id="子串匹配选择器（Substring-matching-selectors）"><a href="#子串匹配选择器（Substring-matching-selectors）" class="headerlink" title="子串匹配选择器（Substring matching selectors）"></a>子串匹配选择器（Substring matching selectors）</h2><blockquote><p>These selectors allow for more advanced matching of substrings inside the value of your attribute. For example, if you had classes of <code>box-warning</code> and <code>box-error</code> and wanted to match everything that started with the string “box-“, you could use <code>[class^=&quot;box-&quot;]</code> to select them both (or <code>[class|=&quot;box&quot;]</code> as described in section above).</p></blockquote><table><thead><tr><th align="center">Selector</th><th align="center">Example</th><th>Description</th></tr></thead><tbody><tr><td align="center"><code>[attr^=value]</code></td><td align="center"><code>li[class^=&quot;box-&quot;]</code></td><td>匹配具有 <em>attr</em> 属性（其名称是方括号中的值）的元素，该属性的值以 <em>value</em> 开头</td></tr><tr><td align="center"><code>[attr$=value]</code></td><td align="center"><code>li[class$=&quot;-box&quot;]</code></td><td>匹配具有 <em>attr</em>属性（其值以 value 结尾）的元素</td></tr><tr><td align="center"><code>[attr*=value]</code></td><td align="center"><code>li[class*=&quot;box&quot;]</code></td><td>匹配具有 <em>attr</em> 属性的元素，该属性在字符串中的任何位置都含有该值</td></tr></tbody></table><p>(Aside: It may help to note that <code>^</code> and <code>$</code> have long been used as <em>anchors</em> in so-called <em>regular expressions</em> to mean <em>begins with</em> and <em>ends with</em>.)（正则表达式的开头和结尾）</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[class^=<span class="string">&quot;a&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">200%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[class$=<span class="string">&quot;a&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[class*=<span class="string">&quot;a&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Attribute substring matching selectors<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;ab&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;bca&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;bcabc&quot;</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li><code>li[class^=&quot;a&quot;]</code> matches any attribute value which starts with <code>a</code>, so matches the first two list items.</li><li><code>li[class$=&quot;a&quot;]</code> matches any attribute value that ends with <code>a</code>, so matches the first and third list item.</li><li><code>li[class*=&quot;a&quot;]</code> matches any attribute value where <code>a</code> appears anywhere in the string, so it matches all of our list items.</li></ul><hr><h2 id="区分大小写（Case-sensitivity）"><a href="#区分大小写（Case-sensitivity）" class="headerlink" title="区分大小写（Case-sensitivity）"></a>区分大小写（Case-sensitivity）</h2><blockquote><p>If you want to match attribute values case-insensitively you can use the value <code>i</code> before the closing bracket. This flag tells the browser to match ASCII characters case-insensitively. Without the flag the values will be matched according to the case-sensitivity of the document language — in HTML’s case it will be case sensitive.（使用<code> i</code>来使大小写不明感）</p></blockquote><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[class^=<span class="string">&quot;a&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    it only matches the first list item because the other two list items start with an uppercase A</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[class^=<span class="string">&quot;a&quot;</span> i]</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    The second selector uses the case-insensitive flag and so matches all of the list items.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Case-insensitivity<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;A&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;Ab&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
          <category> WebDevelopment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS selectors </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Document and website structure</title>
      <link href="2020/04/01/Document-and-website-structure/"/>
      <url>2020/04/01/Document-and-website-structure/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Document-and-website-structure"><a href="#Document-and-website-structure" class="headerlink" title="Document and website structure"></a>Document and website structure</h1><h2 id="Written-in-front"><a href="#Written-in-front" class="headerlink" title="Written in front"></a>Written in front</h2><p>Recently, I’ve been reading this article. And I  just started learning HTML . I don’t know much about HTML tags, and liked using <code>&lt;div&gt;</code>s a lot, which made me almost crazy maintaining my website. </p><p>The article is great. It’s easy for me, a greenhorn in web development to understand. It clearly tells the functions of these tags, and when to use it. I read the English version on <a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Document_and_website_structure">MDN</a>, and make some note in it for better understanding, and for learning English.</p><blockquote><p>Original Article:  <a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Document_and_website_structure">MDN</a></p></blockquote><hr><blockquote><p>In addition to defining individual parts of your page (such as “a paragrapgh” or “an image”),</p><p>HTML also boasts a number of block level elements used to define areas of your website (such as “the header”, “the navigation menu”, “the main content column”).</p><p>This article looks into how to plan a basic website struture, and write the HTML to represent this structure.</p></blockquote><h2 id="Basic-section-of-a-document"><a href="#Basic-section-of-a-document" class="headerlink" title="Basic section of a document"></a>Basic section of a document</h2><p>Webpages can and will look pretty different from one another, but they all tend to share similar standard components, unless the page is displaying a fullscreen video or game, is part of some kind of art project, or is just badly structured.</p><ul><li>header</li><li>navigation bar</li><li>Main content</li><li>sidebar</li><li>footer</li></ul><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>Usually a big strip across the top with a big heading, logo, and perhaps a ==tagline（品牌口号标语）==. This usually stays the same from one webpage to another.</p><h3 id="navigation-bar"><a href="#navigation-bar" class="headerlink" title="navigation bar:"></a>navigation bar:</h3><p>Links to the site’s main sections; usually represented by menu buttons, links, or tabs. Like the header, this content usually remains consistent from one webpage to another — having inconsistent navigation on your website will just lead to confused, frustrated users. </p><h3 id="Main-content"><a href="#Main-content" class="headerlink" title="Main content"></a>Main content</h3><p>A big area in the center that contains most of the unique content of a given webpage, for example, the video you want to watch, or the main story you’re reading, or the map you want to view, or the news headlines, etc. This is the one part of the website that definitely will vary from page to page!</p><h3 id="Sidebar"><a href="#Sidebar" class="headerlink" title="Sidebar"></a>Sidebar</h3><p>Some ==peripheral（外部的）== info, links, quotes, ads, etc. Usually, this is contextual to what is contained in the main content (for example on a news article page, the sidebar might contain the author’s bio, or links to related articles) but there are also cases where you’ll find some recurring elements like a secondary navigation system.</p><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>A strip across the bottom of the page that generally contains fine print, copyright notices, or contact info. It’s a place to put common information (like the header) but usually, that information is not critical or secondary to the website itself. The footer is also sometimes used for SEO purposes, by providing links for quick access to popular content.</p><h2 id="HTML-for-structuring-content"><a href="#HTML-for-structuring-content" class="headerlink" title="HTML for structuring content"></a>HTML for structuring content</h2><p>With the right CSS, you could use pretty much any elements to wrap around the different sections and get it looking how you wanted, but as discussed before, we need to respect ==semantics（语义）== and <strong>use the right element for the right job</strong>.</p><p>This is because visuals don’t tell the whole story. We use color and font size to draw sighted users’ attention to the most useful parts of the content, like the navigation menu and related links, but what about ==visually impaired people(视障者)== for example, who might not find concepts like “pink” and “large font” very useful?</p><p>In your HTML code, you can mark up sections of content based on their <em>functionality</em> — you can use elements that represent the sections of content described above ==unambiguously（明确地）==, and ==assistive（辅助的）== technologies like screenreaders can recognise those elements and help with tasks like “find the main navigation”, or “find the main content.” As we mentioned earlier in the course, there are a number of <a href="https://developer.mozilla.org/en-US/Learn/HTML/Introduction_to_HTML/HTML_text_fundamentals#Why_do_we_need_structure">consequences of not using the right element structure and semantics for the right job</a>.</p><p>To implement such semantic mark up, HTML provides dedicated tags that you can use to represent such sections, for example:</p><ul><li><strong>header:</strong><code>&lt;header&gt;</code></li><li><strong>navigation bar:</strong><code>&lt;nav&gt;</code></li><li><strong>main content</strong>:<code>&lt;main&gt;</code>, with various content ==subsections（小节）== represented by <code>&lt;article&gt;</code>, <code>&lt;section&gt;</code>, and <code>&lt;div&gt;</code> elements.</li><li><strong>sidebar:</strong><code>&lt;aside&gt;</code>, often placed inside <code>&lt;main&gt;</code>.</li><li><strong>footer:</strong><code>&lt;footer&gt;</code>.</li></ul><blockquote><p>An example</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My page title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300|Sonsie+One&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- the below three lines are a fix to get HTML5 semantic elements working in old versions of Internet Explorer--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">      &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Here is our main header that is used across all the pages of our website --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Our team<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Projects<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- A Search form is another commmon non-linear way to navigate through a website. --&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> <span class="attr">name</span>=<span class="string">&quot;q&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search query&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Go!&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Here is our page&#x27;s main content --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- It contains an article --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Article heading<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Donec a diam lectus. Set sit amet ipsum mauris. Maecenas congue ligula as quam viverra nec consectetur ant hendrerit. Donec et mollis dolor. Praesent et diam eget libero egestas mattis sit amet vitae augue. Nam tincidunt congue enim, ut porta lorem lacinia consectetur.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Subsection<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Donec ut librero sed accu vehicula ultricies a non tortor. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aenean ut gravida lorem. Ut turpis felis, pulvinar a semper sed, adipiscing id dolor.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Pelientesque auctor nisi id magna consequat sagittis. Curabitur dapibus, enim sit amet elit pharetra tincidunt feugiat nist imperdiet. Ut convallis libero in urna ultrices accumsan. Donec sed odio eros.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Another subsection<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Donec viverra mi quis quam pulvinar at malesuada arcu rhoncus. Cum soclis natoque penatibus et manis dis parturient montes, nascetur ridiculus mus. In rutrum accumsan ultricies. Mauris vitae nisi at sem facilisis semper ac in est.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Vivamus fermentum semper porta. Nunc diam velit, adipscing ut tristique vitae sagittis vel odio. Maecenas convallis ullamcorper ultricied. Curabitur ornare, ligula semper consectetur sagittis, nisi diam iaculis velit, is fringille sem nunc vet mi.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- the aside content can also be nested within the main content --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Related<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Oh I do like to be beside the seaside<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Oh I do like to be beside the sea<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Although in the North of England<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>It never stops raining<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Oh well...<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- And here is our main footer that is used across all the pages of our website --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>©Copyright 2050 by nobody. All rights reversed.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>We aren’t asking you to do much else in this article, because <strong>the key to understanding document layout is writing a sound HTML structure, and then laying it out with CSS.</strong> </p><h2 id="HTML-layout-elements-in-more-detail"><a href="#HTML-layout-elements-in-more-detail" class="headerlink" title="HTML layout elements in more detail"></a>HTML layout elements in more detail</h2><ul><li><p><code>&lt;main&gt;</code> is for content <em>unique to this page</em>. Use <code>&lt;main&gt;</code> only once per page, and put it directly inside <code>&lt;body&gt;</code>. Ideally this shouldn’t be nested within other elements.</p></li><li><p><code>&lt;article&gt;</code> encloses a block of related content that makes sense on its own without the rest of the page (e.g., a single blog post).</p></li><li><p><code>&lt;section&gt;</code> is similar to <code>&lt;article&gt;</code>, but it is more for grouping together a single part of the page that ==constitutes one single piece of functionality== (e.g., a mini map, or a set of article headlines and summaries). It’s considered best practice to begin each section with a heading; also note that you can break <code>&lt;article&gt;</code>s up into different <code>&lt;section&gt;</code>s, or <code>&lt;section&gt;</code>s up into different <code>&lt;article&gt;</code>s,depending on the context.</p></li><li><p><code>&lt;aside&gt;</code> contains content that is not directly related to the main content but can provide addtional information indirectly related to it (==glossary entries(词汇表条目)==, ==author biography(作者传记)==, related links, etc.).</p></li><li><p><code>&lt;header&gt;</code> represents a group of introductory content. If it is a child of <code>&lt;body&gt;</code> it defines the global header of a webpage, but if it’s a child of an <code>&lt;article&gt;</code> or <code>&lt;section&gt;</code> it defines a specific header for that section (try not to confuse this with titles and headings).</p></li><li><p><code>&lt;nav&gt;</code> contains the main navigation functionally for the page.</p><p>  Secondary links, etc., would not go in the navigation.</p></li><li><p><code>&lt;footer&gt;</code>represents a group of end content for a page.</p></li></ul><h2 id="Non-semantic-wrappers"><a href="#Non-semantic-wrappers" class="headerlink" title="Non-semantic wrappers"></a>Non-semantic wrappers</h2><p>Sometimes you’ll come across a situation where you can’t find an ideal semantic element to group some items together or wrap some content. Sometimes you might want to just group a set of elements together to affect them all as a single entity with some CSS or JavaScript. For cases like these, HTML provides the <code>&lt;div&gt;</code> and <code>&lt;span&gt;</code> elements. You should use these preferably with a suitable class attribute, to provide some kind of label for them so they can be easily targeted.</p><p><code>&lt;span&gt;</code>  is an inline non-semantic element, which you should only use if you can’t think of a better semantic text element to wrap your content, or don’t want to add any specific meaning. For example:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The King walked drunkenly back to his room at 01:00, the beer doing nothing to aid</span><br><span class="line">him as he staggered through the door <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;editor-note&quot;</span>&gt;</span>[Editor&#x27;s note: At this point in the</span><br><span class="line">play, the lights should be down low]<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>In this case, the editor’s note is supposed to merely provide extra direction for the director of the play; it is not supposed to have extra semantic meaning. For sighted users, CSS would perhaps be used to distance the note slightly from the main text.</p><p><code>&lt;div&gt;</code> is a block level non-semantic element, which you should only use if you can’t think of a better semantic block element to use, or don’t want to add any specific meaning. For example, imagine a shopping cart widget that you could choose to pull up at any point during your time on an e-commerce site:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;shopping-cart&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Shopping cart<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>Silver earrings<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>: $99.95.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../products/3333-0985/thumb.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Silver earrings&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Total cost: $237.89<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>This isn’t really an <code>&lt;aside&gt;</code>, as it doesn’t necessarily relate to the main content of the page (you want it viewable from anywhere). It doesn’t even particularly warrant using a <code>&lt;section&gt;</code>, as it isn’t part of the main content of the page. So a <code>&lt;div&gt;</code> is fine in this case. </p><blockquote><p><strong>Warning</strong>: Divs are so convenient to use that it’s easy to use them too much. As they carry no semantic value, they just ==clutter(混乱）== your HTML code. Take care to use them only when there is no better semantic solution and try to reduce their usage to the minimum otherwise you’ll have a hard time updating and maintaining your documents.</p></blockquote><h2 id="Line-breaks-and-horizontal-rules"><a href="#Line-breaks-and-horizontal-rules" class="headerlink" title="Line breaks and horizontal rules"></a>Line breaks and horizontal rules</h2><p>Two elements that you’ll use occasionally and will want to know about are <code>&lt;br&gt;</code> and <code>&lt;hr&gt;</code>:</p><p><code>&lt;br&gt; </code> creates a line break in a paragraph; it is the only way to force a ==rigid structure（刚性结构）== in a situation where you want a series of fixed short lines, such as in a postal address or a poem. For example:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>There once was a man named O&#x27;Dell<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Who loved to write HTML<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">But his structure was bad, his semantics were sad<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">and his markup didn&#x27;t read very well.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Without the <code>&lt;br&gt;</code> elements, the paragraph would just be rendered in one long line (HTML ignores most whitespace); with <code>&lt;br&gt;</code> elements in the code, the markup renders like this:</p><blockquote><p>There once was a man named O’Dell<br>Who loved to write HTML<br>But his structure was bad, his semantics were sad<br>and his markup didn’t read very well.</p></blockquote><p><code>&lt;hr&gt;</code> elements create a horizontal rule in the document that ==denotes a thematic change（表示主题变化）== in the text (such as a change in topic or scene)。</p><h2 id="Planning-a-simple-website"><a href="#Planning-a-simple-website" class="headerlink" title="Planning a simple website"></a>Planning a simple website</h2><p>Once you’ve planned out the structure of a simple webpage, the next logical step is to try to work out what content you want to put on a whole website, what pages you need, and how they should be arranged and link to one another for the best possible user experience. This is called <a href="https://developer.mozilla.org/en-US/docs/Glossary/Information_architecture">Information architecture</a>. In a large, complex website, a lot of planning can go into this process, but for a simple website of a few pages, this can be fairly simple, and fun!</p><ol><li>Bear in mind that you’ll have a few elements common to most (if not all) pages — such as the navigation menu, and the footer content. If your site is for a business, for example, it’s a good idea to have your contact information available in the footer on each page. Note down what you want to have common to every page.</li><li>Next, draw a rough sketch of what you might want the structure of each page to look like (it might look like our simple website above). Note what each block is going to be.</li><li>Now, brainstorm all the other (not common to every page) content you want to have on your website — write a big list down.</li><li>Next, try to sort all these content items into groups, to give you an idea of what parts might ==live together on different pages（在不同页面上一起显示）==. This is very similar to a technique called <a href="https://developer.mozilla.org/en-US/docs/Glossary/Card_sorting">Card sorting</a>.(卡片分类)</li><li>Now try to sketch a rough sitemap — have a bubble for each page on your site, and draw lines to show the typical workflow between pages. The homepage will probably be in the center, and link to most if not all of the others; most of the pages in a small site should be available from the main navigation, although there are exceptions. You might also want to include notes about how things might be presented.</li></ol>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
          <category> WebDevelopment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Document structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的Markdown语法总结</title>
      <link href="2020/03/10/Simple-Markdown-Syntax/"/>
      <url>2020/03/10/Simple-Markdown-Syntax/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h1><p>刚开始写博, 对md的语法还不熟悉, 决定先整理一下md的<strong>basic syntax</strong>.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.markdownguide.org/basic-syntax/">markdownguide.org</a></p></blockquote><span id="more"></span><h1 id="2-文章标题Headings"><a href="#2-文章标题Headings" class="headerlink" title="2. 文章标题Headings"></a>2. 文章标题Headings</h1><p>创建标题只需要使用’#’, 使用几个’#’就对应了几级标题.</p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="section"># heading level1</span></span><br><span class="line"><span class="section">## heading level2</span></span><br><span class="line"><span class="section">### heading level3</span></span><br><span class="line"><span class="section">#### heading level4</span></span><br><span class="line"><span class="section">##### heading level5</span></span><br><span class="line"><span class="section">###### heading level6</span></span><br></pre></td></tr></table></figure><br><p>效果如下:<img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/headings.png" alt="headings"></p><h1 id="3-文章段落-Paragraphs"><a href="#3-文章段落-Paragraphs" class="headerlink" title="3. 文章段落 Paragraphs"></a>3. 文章段落 Paragraphs</h1><p>要创建段落,使用空白行分隔一行或多行文本</p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">I really like using Markdown.</span><br><span class="line"></span><br><span class="line">I think I&#x27;ll use it to write my blog online.</span><br></pre></td></tr></table></figure><br><p>效果如下:</p><p>I really like using Markdown.</p><p>I think I’ll use it to write blogs online.</p><h1 id="4-换行-Line-Breaks"><a href="#4-换行-Line-Breaks" class="headerlink" title="4. 换行 Line Breaks"></a>4. 换行 Line Breaks</h1><p>换行时,在行位打<strong>两个或以上</strong>的空格符,然后按下回车.   </p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&lt;!--请注意区别--&gt;</span><br><span class="line">1.This is the first line.      &lt;!--此处行末有多个空格&gt;</span><br><span class="line">And this is the second line.</span><br><span class="line"></span><br><span class="line">2.This is the first line.&lt;!--此处行末无空格&gt;</span><br><span class="line">And this is still at the first line.</span><br><span class="line"></span><br><span class="line">3.This is the first line. &lt;!--此处行末有一个空格&gt;</span><br><span class="line">And this is also at the first line.</span><br></pre></td></tr></table></figure><p>效果如下:<br>1.This is the first line.<br>And this is the second line.</p><p>2.This is the first line.And this is still at the first line.</p><p>3.This is the first line.And this is also at the first line.</p><blockquote><p>这里在博客的实际输出效果可能不一样, 与config文件中marked.gfm属性有关<br>详见<a href="https://github.com/hexojs/hexo/issues/2200">Github/hexojs/hexo/Issue#2200</a></p></blockquote><h1 id="5-强调-Emphasis"><a href="#5-强调-Emphasis" class="headerlink" title="5. 强调 Emphasis"></a>5. 强调 Emphasis</h1><p>为了强调文本,可以使用加粗/斜体</p><p>加粗为      <code>**想要加粗的内容**</code><br>斜体为      <code>*想要斜体的内容*</code><br>粗体+斜体为  <code>***内容***</code>   </p><p>效果如下:    </p><p><strong>Bold Text</strong></p><p><em>Italic Text</em></p><p><em><strong>Both</strong></em>   </p><blockquote><p><a href="https://www.markdownguide.org/basic-syntax/#emphasis">参考文档</a> 上不推荐使用下划线的方式, 这里就不整理进去了.</p></blockquote><h1 id="6-块引用-Blockquotes"><a href="#6-块引用-Blockquotes" class="headerlink" title="6. 块引用 Blockquotes"></a>6. 块引用 Blockquotes</h1><h2 id="6-1-块引用"><a href="#6-1-块引用" class="headerlink" title="6.1 块引用"></a>6.1 块引用</h2><p>在行首使用 <code>&gt;</code> 符号进行块引用</p><p><code>&gt; 这是引用,效果看上去是这样子的.</code></p><p>效果如下</p><blockquote><p>这是引用, 效果看上去是这样子的.</p></blockquote><h2 id="6-2-多行块引用-Blockqutos-with-Multiple-Paragrapgs"><a href="#6-2-多行块引用-Blockqutos-with-Multiple-Paragrapgs" class="headerlink" title="6.2 多行块引用 Blockqutos with Multiple Paragrapgs"></a>6.2 多行块引用 Blockqutos with Multiple Paragrapgs</h2><p>只需要在每行开头使用 <code>&gt;</code> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;块</span><br><span class="line">&gt;引</span><br><span class="line">&gt;用</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>块<br>引<br>用    </p></blockquote><h2 id="6-3-嵌套块引用-Nested-Blockquotes"><a href="#6-3-嵌套块引用-Nested-Blockquotes" class="headerlink" title="6.3 嵌套块引用 Nested Blockquotes"></a>6.3 嵌套块引用 Nested Blockquotes</h2><p>使用多个 <code>&gt;</code> 来实现嵌套引用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;这</span><br><span class="line">&gt;&gt;是</span><br><span class="line">&gt;&gt;&gt;嵌套</span><br><span class="line">&gt;&gt;&gt;&gt;引用</span><br></pre></td></tr></table></figure><blockquote><p>这</p><blockquote><p>是</p><blockquote><p>嵌套</p><blockquote><p>引用</p></blockquote></blockquote></blockquote></blockquote><h2 id="6-4-引用中嵌套其他md元素"><a href="#6-4-引用中嵌套其他md元素" class="headerlink" title="6.4 引用中嵌套其他md元素"></a>6.4 引用中嵌套其他md元素</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; #### The quarterly results look great!</span><br><span class="line">&gt;</span><br><span class="line">&gt; - Revenue was off the chart.</span><br><span class="line">&gt; - Profits were higher than ever.</span><br><span class="line">&gt;</span><br><span class="line">&gt;  *Everything* is going according to **plan**.</span><br></pre></td></tr></table></figure><blockquote><h4 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h4><ul><li>Revenue was off the chart.</li><li>Profits were higher than ever.</li></ul><p> <em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><h1 id="7-列表-Lists"><a href="#7-列表-Lists" class="headerlink" title="7. 列表 Lists"></a>7. 列表 Lists</h1><p>用来组织一系列项目,可以是有序/无序的</p><h2 id="7-1-有序列表-Ordered-List"><a href="#7-1-有序列表-Ordered-List" class="headerlink" title="7.1 有序列表 Ordered List"></a>7.1 有序列表 Ordered List</h2><p>直接使用 <code>&lt;数字&gt; + &lt;.&gt; + &lt;物品&gt;</code> 的形式</p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> first item</span><br><span class="line"><span class="bullet">2.</span> seconde item</span><br><span class="line"><span class="bullet">3.</span> third item</span><br></pre></td></tr></table></figure><p>效果如下:</p><ol><li>first item</li><li>seconde item</li><li>third item</li></ol><p>神奇的是,你xjb编号,实际的效果序号还是正确的<br>但要注意列表的开头一项必须为<code>1.</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. first</span><br><span class="line">8. eighth</span><br><span class="line">4. fourth</span><br></pre></td></tr></table></figure><p>效果如下:</p><ol><li>first</li><li>eighth</li><li>fourth</li></ol><p>列表中还能嵌套子列表</p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> first</span><br><span class="line"><span class="bullet">2.</span> second</span><br><span class="line"><span class="bullet">    -</span> hhh</span><br><span class="line"><span class="bullet">    -</span> 233</span><br></pre></td></tr></table></figure><ol><li>first</li><li>second<ul><li> hhh</li><li> 233</li></ul></li></ol><h2 id="7-2-无序列表-Unordered-Lists"><a href="#7-2-无序列表-Unordered-Lists" class="headerlink" title="7.2 无序列表 Unordered Lists"></a>7.2 无序列表 Unordered Lists</h2><p>项目名称前面可以使用 <code>-</code>,<code>*</code>,<code>+</code> 效果都是一样的,并且和有序列表一样也能嵌套</p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> first item</span><br><span class="line"><span class="bullet">+</span> second item</span><br><span class="line"><span class="bullet">-</span> third item</span><br><span class="line"><span class="bullet">*</span> fourth item</span><br><span class="line"><span class="bullet">    -</span> indented item</span><br><span class="line"><span class="bullet">    -</span> indented item</span><br></pre></td></tr></table></figure><ul><li>first item</li></ul><ul><li>second item</li></ul><ul><li>third item</li></ul><ul><li>fourth item<ul><li>indented item</li><li>indented item</li></ul></li></ul><h2 id="7-3-在列表中添加其他元素-Adding-Elements-in-Lists"><a href="#7-3-在列表中添加其他元素-Adding-Elements-in-Lists" class="headerlink" title="7.3 在列表中添加其他元素 Adding Elements in Lists"></a>7.3 在列表中添加其他元素 Adding Elements in Lists</h2><p>添加元素时,为了保证列表还是延续的, 需要在元素前添加4个空格或者1个tab</p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span>  This is the first list item.      </span><br><span class="line"><span class="bullet">-</span>  Here&#x27;s the second list item.</span><br><span class="line"></span><br><span class="line"><span class="code">    I need to add another paragraph below the second list item</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">-  And here&#x27;s the third list item.</span></span><br></pre></td></tr></table></figure><ul><li><p> This is the first list item.      </p></li><li><p>Here’s the second list item.           </p><p>  I need to add another paragraph below the second list item</p></li><li><p> And here’s the third list item.</p></li></ul><p>需要注意的是,在列表中嵌入<strong>代码块</strong>,需要比平常多4个空格,也就是8个空格</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1.  Open the file.</span><br><span class="line">2.  Find the following code block on line 21:</span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">3.  Update the title to match the name of your website.</span><br></pre></td></tr></table></figure><p>效果如下:</p><ol><li><p> Open the file.</p></li><li><p>Find the following code block on line 21:</p><pre><code> &lt;html&gt;     &lt;head&gt;     &lt;title&gt;Test&lt;/title&gt;     &lt;/head&gt; &lt;/html&gt;</code></pre></li><li><p> Update the title to match the name of your website.</p></li></ol><h1 id="8-代码-Code"><a href="#8-代码-Code" class="headerlink" title="8. 代码 Code"></a>8. 代码 Code</h1><h2 id="8-1-单行代码"><a href="#8-1-单行代码" class="headerlink" title="8.1 单行代码"></a>8.1 单行代码</h2><p>用一对反单引号把文本包含起来(`)</p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="code">`x = x + 1`</span></span><br></pre></td></tr></table></figure><p>效果如下:</p><p><code>x = x + 1</code></p><h2 id="8-2-多行代码"><a href="#8-2-多行代码" class="headerlink" title="8.2 多行代码"></a>8.2 多行代码</h2><p>使用三个(`)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#96;&#96;&#96;)python &lt;!--实际使用中不需要括号&gt;</span><br><span class="line"># print Hello World!</span><br><span class="line">print(&quot;Hello, World!&quot;)</span><br><span class="line">(&#96;&#96;&#96;) </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print Hello World!</span></span><br><span class="line">print(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="8-3-反引号转意"><a href="#8-3-反引号转意" class="headerlink" title="8.3 反引号转意"></a>8.3 反引号转意</h2><p>要表示带有<code>``的文本,将一对(``) </code>括在文本的外面<br>比如:<br><code>use `code` in your markdown file.</code></p><p>此处code带有一对反斜杠</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;use &#96;code&#96; in your markdown file.&#96;&#96;</span><br><span class="line">&lt;!-- 只需将两个&#96;&#96;括在文本外面 --&gt;</span><br></pre></td></tr></table></figure><p>效果如下:<br><code>use `code` in your markdown file.</code></p><!-- 只需将两个``括在文本外面 --><h1 id="9-横向分隔线"><a href="#9-横向分隔线" class="headerlink" title="9. 横向分隔线"></a>9. 横向分隔线</h1><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&lt;!-- 三个或多个星号<span class="emphasis">* --&gt;</span></span><br><span class="line"><span class="emphasis"><span class="strong">**<span class="emphasis">* </span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">&lt;!-- 三个或多个短横- --&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">---</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">&lt;!-- 三个或多个下划线_ --&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong">____</span><span class="strong">____</span><span class="strong">____</span><span class="strong">____</span><span class="strong">____</span><span class="strong">__</span></span></span></span></span><br></pre></td></tr></table></figure><p>效果如下</p><hr><hr><hr><hr><h1 id="10-超链接"><a href="#10-超链接" class="headerlink" title="10. 超链接"></a>10. 超链接</h1><h2 id="10-1-贴个链接"><a href="#10-1-贴个链接" class="headerlink" title="10.1 贴个链接"></a>10.1 贴个链接</h2><p><code>[link text](url)</code></p><p>比如<br><code> My Favorite search engine is [Duck Duck Go](https://duckduckgo.com)</code></p><p>效果如下:<br>My Favorite search engine is <a href="https://duckduckgo.com/">Duck Duck Go</a></p><h2 id="10-2-快速链接"><a href="#10-2-快速链接" class="headerlink" title="10.2 快速链接"></a>10.2 快速链接</h2><p>使用<code>&lt;&gt;</code>将链接包围,不需要写描述文本了</p><p><code>&lt;https://www.markdownguide.org&gt;</code></p><p>效果如下:<br><a href="https://www.markdownguide.org/">https://www.markdownguide.org</a></p><h2 id="10-3-参考样式链接"><a href="#10-3-参考样式链接" class="headerlink" title="10.3 参考样式链接"></a>10.3 参考样式链接</h2><p>和引用论文差不多</p><p><code>[Link Text][number] </code><br><code>再写上[number]对应的链接 &lt;url&gt;</code></p><p>比如:    </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 第一部分 --&gt;</span><br><span class="line">[DuckDuckGo][1]</span><br><span class="line">[百度][2]</span><br><span class="line"></span><br><span class="line">&lt;!-- 第二部分 --&gt;</span><br><span class="line">[1]:&lt;https:&#x2F;&#x2F;duckduckgo.com&gt;</span><br><span class="line">[2]:http:&#x2F;&#x2F;www.baidu.com</span><br></pre></td></tr></table></figure><p>效果如下:</p><p><a href="https://duckduckgo.com/">DuckDuckGo</a>     </p><p><a href="http://www.baidu.com/">百度</a>    </p><blockquote><p>You can place this second part of the link anywhere in your Markdown document. Some people place them immediately after the paragraph in which they appear while other people place them at the end of the document (like endnotes or footnotes).<br>引用自<a href="https://www.markdownguide.org/basic-syntax/#horizontal-rules">markdownguide.org</a></p></blockquote><p>这个参考式链接的第二部分可以出现在md文件的任何地方</p><hr><h1 id="11-插入图片"><a href="#11-插入图片" class="headerlink" title="11. 插入图片"></a>11. 插入图片</h1><p><code>![对图片的描述文字](url 给图片加个title(可选)) </code></p><p>比如:<br>插一张我的头像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![myavatar](&#x2F;img&#x2F;avatar.jpeg &quot;杰尼龟🐛啊&quot;)</span><br></pre></td></tr></table></figure><p>效果如下:<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jzhmcoo1/jzhmcoo1picrepo/raw/master/img/avatar.jpeg"></p><hr><h1 id="12-写在最后"><a href="#12-写在最后" class="headerlink" title="12. 写在最后"></a>12. 写在最后</h1><p>第一次写博文. 👶👶👶<br>写这篇博是想学习Basic Syntax, 在博客中常用的md语法.<br>总结的不是很全面, 加入了自己的理解, 与官方文档有所偏差.<br>以后有需要的话可能会再出一篇Extended Synatx(官方说法)<br>hexo和我的vscode预览的效果有些差异, 没有时间去一个个解决,有点遗憾.<br>如果这篇文章能够帮助到你那就再好不过了.</p>]]></content>
      
      
      <categories>
          
          <category> StudyNotes </category>
          
          <category> Syntax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> syntax </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
